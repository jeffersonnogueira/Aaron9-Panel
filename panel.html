<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>AARON 9 – Painel Institucional em Tempo Real </title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root {
      --bg: #020617;
      --bg-elevated: #020617;
      --card: #020617;
      --card-border: #1f2937;
      --accent: #22d3ee;
      --accent-soft: rgba(34, 211, 238, 0.12);
      --danger: #f97373;
      --success: #4ade80;
      --text-soft: #9ca3af;
      --text-main: #e5e7eb;
      --error: #f97373;
    }

    * {
      box-sizing: border-box;
    }

   body {
  margin: 0;
  padding: 0;
  background: #020617;
  color: var(--text-main);
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  overflow-x: hidden;
}


/* wrapper principal da página */
.app-shell {
  min-height: 100vh;
  display: flex;
  justify-content: flex-start;  /* fica encostado à esquerda */
}

.app-inner {
  width: 100%;
  max-width: 100%;              /* tira o limite de 1680px */
  margin: 16px 24px 32px 24px;  /* margens finas só pra não colar na borda */
}


 .page{
  min-height: 100vh;
  width: 100%;
  max-width: none;            /* remove o limite (some o vazio lateral) */
  margin: 0;                  /* para de centralizar com “auto” */
  padding: 16px 24px 32px 24px; /* mantém respiro nas bordas */
  display: flex;
  flex-direction: column;
  gap: 10px;
}




    /* TOPO / HEADER */

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 14px;
      border-radius: 14px;
      background: radial-gradient(circle at top left, rgba(34, 211, 238, 0.12), transparent 55%);
      border: 1px solid rgba(31, 41, 55, 0.95);
      box-shadow: 0 14px 40px rgba(15, 23, 42, 0.85);
      position: relative;
      overflow: hidden;
    }

    .top-bar::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 0 0, rgba(34, 211, 238, 0.3), transparent 60%),
        radial-gradient(circle at 100% 0, rgba(59, 130, 246, 0.25), transparent 60%);
      opacity: 0.75;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .top-left,
    .top-right {
      position: relative;
      z-index: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 6px 14px;
      align-items: center;
    }

    .brand-title {
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--text-soft);
    }

    .brand-title span {
      color: var(--accent);
    }

        /* === The Six Seats – logo no topo === */
    .brand-logo {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 4px;
    }

    .brand-logo-img {
      height: 34px;        /* aumenta/diminui o tamanho aqui */
      width: auto;
      filter: drop-shadow(0 0 12px rgba(248, 250, 252, 0.85));
    }

    .brand-logo-text {
      display: flex;
      flex-direction: column;
      line-height: 1.05;
    }

    .brand-logo-main {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #f9fafb;
    }

    .brand-logo-sub {
      font-size: 9px;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      color: var(--text-soft);
    }


    .status-dot-live {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(248, 113, 113, 0.12);
      border: 1px solid rgba(248, 113, 113, 0.5);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: #fecaca;
    }

    .status-dot-live::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #f97373;
      box-shadow: 0 0 14px rgba(239, 68, 68, 0.9);
    }

    .pill-small {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      font-size: 11px;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      white-space: nowrap;
    }

    .pill-small strong {
      color: var(--text-main);
      font-weight: 500;
      margin-left: 3px;
    }
/* === TIMEFRAME PICKER (AARON10) === */
.tf-picker{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:2px 6px;
  border-radius:999px;
  border:1px solid rgba(148,163,184,0.35);
  background: rgba(2, 6, 23, 0.6);
}

.tf-btn{
  appearance:none;
  border:0;
  cursor:pointer;
  padding:4px 10px;
  border-radius:999px;
  font-size:11px;
  letter-spacing:0.12em;
  text-transform:uppercase;
  color: var(--text-soft);
  background: transparent;
  transition: transform .12s ease, background .12s ease, color .12s ease, box-shadow .12s ease;
}

.tf-btn:hover{
  transform: translateY(-1px);
  background: rgba(148,163,184,0.12);
  color: var(--text-main);
}

.tf-btn.active{
  background: rgba(34,211,238,0.22);
  border:1px solid rgba(34,211,238,0.55);
  color:#e0f2fe;
  box-shadow: 0 0 0 1px rgba(34,211,238,0.15), 0 10px 24px rgba(34,211,238,0.12);
}

    .pill-state {
      display: inline-flex;
      align-items: center;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(34, 211, 238, 0.8);
      background: rgba(8, 47, 73, 0.85);
      color: #e0f2fe;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      gap: 6px;
      white-space: nowrap;
    }

    .pill-state::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #22d3ee;
      box-shadow: 0 0 12px rgba(34, 211, 238, 0.9);
    }

    .pill-soft {
      display: inline-flex;
      align-items: center;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: rgba(15, 23, 42, 0.85);
      font-size: 11px;
      color: var(--text-soft);
      white-space: nowrap;
    }

    .pill-soft strong {
      color: var(--text-main);
      font-weight: 500;
      margin-left: 4px;
    }

    .pill-soft-accent {
      border-color: rgba(34, 211, 238, 0.85);
      color: #e0f2fe;
    }

    .btn-refresh {
      position: relative;
      z-index: 1;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(34, 211, 238, 0.7);
      background: radial-gradient(circle at top, rgba(34, 211, 238, 0.2), rgba(15, 23, 42, 0.9));
      color: #e0f2fe;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      cursor: pointer;
    }

    .btn-refresh::before {
      content: "⟳";
      font-size: 12px;
    }

    .btn-refresh[disabled] {
      opacity: 0.5;
      cursor: default;
    }
        .lang-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
      margin-right: 6px;
    }

    .lang-btn {
      border: none;
      background: transparent;
      color: #9ca3af;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 999px;
      cursor: pointer;
    }

    .lang-btn.active {
      background: rgba(34, 211, 238, 0.16);
      color: #e0f2fe;
    }


    /* BANNER ERRO */

    .error-banner {
      display: none;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid rgba(248, 113, 113, 0.8);
      background: rgba(127, 29, 29, 0.3);
      color: #fecaca;
      font-size: 12px;
    }

    .error-banner strong {
      color: #fee2e2;
    }

    /* LAYOUT PRINCIPAL */

    .layout {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.1fr) minmax(0, 1.4fr);
      gap: 12px;
      align-items: flex-start;
    }

    @media (max-width: 1024px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card {
      position: relative;
      border-radius: 16px;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.98), rgba(3, 7, 18, 0.98));
      border: 1px solid rgba(30, 64, 175, 0.9);
      box-shadow:
        0 18px 42px rgba(15, 23, 42, 0.95),
        0 0 28px rgba(15, 23, 42, 0.9);
      padding: 12px 14px;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(34, 211, 238, 0.12), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
    }

    .card-header {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }

    .card-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-soft);
    }

    .card-subtitle {
      font-size: 11px;
      color: var(--text-soft);
    }

    .badge-outline {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
      gap: 6px;
    }

    .badge-outline.green {
      border-color: rgba(74, 222, 128, 0.8);
      color: #bbf7d0;
    }

    .badge-outline.red {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .badge-outline span.dot {
      width: 5px;
      height: 5px;
      border-radius: 999px;
      background: currentColor;
      box-shadow: 0 0 10px currentColor;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: minmax(0, 1.6fr) minmax(0, 1.4fr);
      gap: 10px;
    }

    .panel-section {
      position: relative;
      z-index: 1;
      padding: 10px 10px 10px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(30, 64, 175, 0.8);
      box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.9);
      margin-bottom: 8px;
    }

    .panel-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 4px;
    }

    .panel-section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--text-soft);
    }
/* ====== AARON CHART + STUDIES (ALPACA) ====== */
.aaron-studies{
  margin-top: 8px;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(148, 163, 184, 0.18);
  background: rgba(2, 6, 23, 0.55);
}

.aaron-studies-title{
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: var(--text-soft);
  margin-bottom: 8px;
}

.aaron-studies-pills{
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.pill-toggle{
  display: inline-flex;
  align-items: center;
  cursor: pointer;
  user-select: none;
}

.pill-toggle input{
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

.pill-toggle span{
  display: inline-flex;
  align-items: center;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.75);
  color: var(--text-soft);
  font-size: 11px;
  letter-spacing: 0.06em;
  transition: transform .08s ease, background .15s ease, border-color .15s ease, color .15s ease;
}

.pill-toggle span:hover{
  transform: translateY(-1px);
  border-color: rgba(34, 211, 238, 0.55);
  color: var(--text-main);
}

.pill-toggle input:checked + span{
  border-color: rgba(34, 211, 238, 0.85);
  background: rgba(34, 211, 238, 0.12);
  color: #e0f2fe;
  box-shadow: 0 0 18px rgba(34, 211, 238, 0.22);
}

/* shell do chart */
.aaron10-chart-shell{
  position: relative;
  margin-top: 10px;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(15, 23, 42, 0.9);
  min-height: 420px;
  background: #020617;
}

.aaron10-chart{
  width: 100%;
  height: 430px;
}

.aaron10-chart-overlay{
  position: absolute;
  top: 10px;
  right: 10px;
  pointer-events: none;
  opacity: 0.95;
}

    .pill {
      display: inline-flex;
      align-items: center;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 11px;
      color: var(--text-main);
      background: rgba(15, 23, 42, 0.9);
      white-space: nowrap;
    }

    .pill-green {
      border-color: rgba(74, 222, 128, 0.8);
      color: var(--success);
    }

    .pill-red {
      border-color: rgba(248, 113, 113, 0.8);
      color: var(--danger);
    }

    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 11px;
      margin-bottom: 2px;
    }

    /* === DIREÇÃO COM FLECHA === */
    .direction-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 4px;
    }

    .arrow-badge {
      width: 46px;
      height: 46px;
      border-radius: 999px;
      border: 1px solid rgba(34, 211, 238, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 18px rgba(34, 211, 238, 0.7);
      font-size: 24px;
      font-weight: 700;
      color: #e5e7eb;
      flex-shrink: 0;
    }

    .arrow-badge.arrow-up {
      border-color: rgba(74, 222, 128, 0.9);
      box-shadow: 0 0 22px rgba(74, 222, 128, 0.8);
      color: #4ade80;
    }

    .arrow-badge.arrow-down {
      border-color: rgba(248, 113, 113, 0.9);
      box-shadow: 0 0 22px rgba(248, 113, 113, 0.85);
      color: #f97373;
    }

    .direction-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
    }

    .direction-text strong {
      font-size: 13px;
    }

    .text-soft {
      color: var(--text-soft);
    }
    /* ====== AARON 9 – COLUNA DIREITA (DECISION PANEL) ====== */

.decision-column {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.decision-card {
  background: var(--card, #020617);
  border-radius: 18px;
  border: 1px solid var(--card-border, #1f2937);
  padding: 16px 18px;
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.75);
}

/* títulos e textos pequenos */
.decision-title {
  font-size: 0.75rem;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: var(--text-soft, #9ca3af);
  margin-bottom: 8px;
}

.decision-label-strong {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--text-main, #e5e7eb);
}

/* radar de direção */
.radar-header {
  display: flex;
  align-items: center;
  gap: 12px;
}

.radar-circle {
  width: 54px;
  height: 54px;
  border-radius: 999px;
  border: 2px solid #f97373;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 26px;
}

.radar-circle.buy {
  border-color: var(--accent, #22d3ee);
}

.radar-percent {
  font-size: 0.9rem;
  color: var(--text-soft, #9ca3af);
}

/* barrinhas horizontal (a favor x contra, etc.) */
.decision-bar {
  position: relative;
  width: 100%;
  height: 6px;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.18);
  overflow: hidden;
}

.decision-bar-fill {
  position: absolute;
  inset: 0;
  width: 70%; /* será ajustado depois com JS ou no backend */
  border-radius: inherit;
  background: linear-gradient(90deg, #22c55e, #facc15);
}

.decision-bar-fill-danger {
  position: absolute;
  inset: 0;
  width: 30%;
  border-radius: inherit;
  background: linear-gradient(90deg, #f97373, #facc15);
}

/* pill do estado (NO TRADE / GO FULL etc.) */
.decision-pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 3px 10px;
  border-radius: 999px;
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 0.16em;
  text-transform: uppercase;
}

.decision-pill.go-full {
  background: rgba(248, 113, 113, 0.16);
  color: #fecaca;
}

.decision-pill.scalp {
  background: rgba(56, 189, 248, 0.16);
  color: #bae6fd;
}

.decision-pill.wait {
  background: rgba(234, 179, 8, 0.16);
  color: #facc15;
}

.decision-pill.no-trade {
  background: rgba(148, 163, 184, 0.16);
  color: #cbd5f5;
}

/* checklist de padrões */
.checklist-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
}

.check-pill {
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 0.8rem;
  border: 1px solid rgba(148, 163, 184, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

.check-pill.on {
  border-color: rgba(45, 212, 191, 0.9);
  background: rgba(34, 197, 94, 0.12);
  color: #bbf7d0;
}

/* pattern radar + pullback */
.pattern-layout {
  display: grid;
  grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.5fr);
  gap: 12px;
}

.pattern-box {
  border-radius: 14px;
  border: 1px solid rgba(148, 163, 184, 0.4);
  padding: 8px 10px;
  font-size: 0.78rem;
}

.pattern-name {
  font-weight: 600;
  margin-bottom: 4px;
}

.pullback-highlight {
  font-size: 0.78rem;
  margin-top: 8px;
  padding: 6px 8px;
  border-radius: 10px;
  background: rgba(34, 197, 94, 0.08);
  border: 1px solid rgba(34, 197, 94, 0.4);
}

/* responsivo: em telas estreitas essa coluna vira full-width */
@media (max-width: 1024px) {
  .decision-column {
    margin-top: 16px;
  }
}
/* ====== HERO STATUS (MODO CEGO) ====== */

.status-hero {
  background: radial-gradient(circle at top left, rgba(34,197,94,0.18), rgba(15,23,42,1));
  border-radius: 20px;
  border: 1px solid rgba(34,197,94,0.7);
  padding: 14px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.9);
}

.status-hero-label {
  font-size: 0.7rem;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: rgba(148,163,184,0.9);
}

/* ===== AUTOPILOT (simulador) ===== */
.trade-autopilot { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
.ap-switch { position:relative; width:42px; height:22px; display:inline-block; }
.ap-switch input { opacity:0; width:0; height:0; }
.ap-slider {
  position:absolute; cursor:pointer; inset:0;
  background: rgba(148,163,184,0.25);
  border:1px solid rgba(148,163,184,0.35);
  transition:.2s; border-radius:999px;
}
.ap-slider:before {
  content:""; position:absolute; height:16px; width:16px; left:3px; top:2px;
  background: rgba(226,232,240,0.9);
  transition:.2s; border-radius:999px;
}
.ap-switch input:checked + .ap-slider {
  background: rgba(34,197,94,0.25);
  border-color: rgba(34,197,94,0.45);
}
.ap-switch input:checked + .ap-slider:before { transform: translateX(19px); }

.ap-btn {
  border:1px solid rgba(148,163,184,0.25);
  background: rgba(15,23,42,0.35);
  color:#e2e8f0; font-weight:800; letter-spacing:.4px;
  padding:7px 10px; border-radius:12px; cursor:pointer;
}
.ap-btn:hover { filter:brightness(1.08); }

.ap-meta { opacity:.85; font-size:0.86rem; }

#ap-state { padding:4px 10px; border-radius:999px; font-weight:800; }
#ap-state.ap-on { border-color: rgba(34,197,94,0.55); }
#ap-state.ap-off { border-color: rgba(148,163,184,0.35); opacity:.8; }
#ap-state.ap-buy { border-color: rgba(56,189,248,0.55); }
#ap-state.ap-sell { border-color: rgba(248,113,113,0.55); }

/* ===== AUTOPILOT UI v2 (premium) ===== */
#autopilot-panel.autopilot-v2{
  padding: 14px;
  border: 1px solid rgba(148,163,184,0.18);
  background:
    radial-gradient(1200px 500px at 20% 0%, rgba(56,189,248,0.10), transparent 60%),
    radial-gradient(900px 420px at 85% 10%, rgba(34,197,94,0.08), transparent 55%),
    rgba(2,6,23,0.35);
}

#autopilot-panel .ap2-top{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:10px;
}

#autopilot-panel .ap2-sub{
  margin-top:2px;
  font-size:0.78rem;
  opacity:0.75;
}

#autopilot-panel .ap2-controls{
  display:flex;
  align-items:center;
  gap:10px;
}

#autopilot-panel .ap2-bottom{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}

#autopilot-panel .ap-btn{
  min-width: 98px;
  border-radius: 14px;
  padding: 9px 12px;
  letter-spacing: .6px;
}

#autopilot-panel .ap-btn:active{
  transform: translateY(1px);
}

#autopilot-panel .ap2-ico{
  display:inline-block;
  margin-right:7px;
  opacity:.85;
  font-weight:900;
}

#autopilot-panel #ap-meta{
  margin-left:auto;
  padding-left:10px;
  opacity:0.85;
  font-size:0.86rem;
}

/* Deixa o estado mais "badge premium" */
#autopilot-panel #ap-state{
  padding: 6px 12px;
  border-radius: 999px;
  font-weight: 900;
  letter-spacing: .6px;
}

/* ===== AUTOPILOT 2.0 (cores fortes + sizing) ===== */
#autopilot-panel .ap-btn.ap-buy{
  background: linear-gradient(135deg, rgba(34,197,94,0.22), rgba(34,197,94,0.08));
  border-color: rgba(34,197,94,0.55);
  color: rgba(236,253,245,0.98);
}
#autopilot-panel .ap-btn.ap-sell{
  background: linear-gradient(135deg, rgba(248,113,113,0.22), rgba(248,113,113,0.08));
  border-color: rgba(248,113,113,0.62);
  color: rgba(255,241,242,0.98);
}
#autopilot-panel .ap-btn.ap-close{
  background: rgba(15,23,42,0.25);
  border-color: rgba(148,163,184,0.28);
}
#autopilot-panel .ap-btn:disabled{
  opacity: .45;
  cursor: not-allowed;
}

#autopilot-panel .ap2-sizing{
  margin: 10px 0 12px 0;
  padding: 12px;
  border-radius: 16px;
  border: 1px solid rgba(148,163,184,0.16);
  background: rgba(0,0,0,0.18);
  box-shadow: inset 0 0 0 1px rgba(2,6,23,0.15);
}

#autopilot-panel .ap2-price-row{
  display:grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 10px;
  align-items: center;
  margin-bottom: 10px;
}

#autopilot-panel .ap2-quote{
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(148,163,184,0.18);
  background: rgba(2,6,23,0.28);
}

#autopilot-panel .ap2-quote-sell{
  border-color: rgba(248,113,113,0.30);
}
#autopilot-panel .ap2-quote-buy{
  border-color: rgba(34,197,94,0.30);
}

#autopilot-panel .ap2-quote-label{
  font-size: 0.72rem;
  opacity: .78;
  letter-spacing: .08em;
  text-transform: uppercase;
}

#autopilot-panel .ap2-quote-price{
  margin-top: 2px;
  font-size: 1.05rem;
  font-weight: 900;
}

#autopilot-panel .ap2-quote-mid{
  padding: 0 4px;
  text-align:center;
  opacity: .82;
}
#autopilot-panel .ap2-quote-mid-label{
  font-size: 0.70rem;
  letter-spacing: .08em;
  text-transform: uppercase;
}
#autopilot-panel .ap2-quote-mid-price{
  margin-top: 2px;
  font-weight: 800;
}

#autopilot-panel .ap2-input-row{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}
@media (max-width: 520px){
  #autopilot-panel .ap2-input-row{ grid-template-columns: 1fr; }
  #autopilot-panel .ap2-price-row{ grid-template-columns: 1fr; }
  #autopilot-panel .ap2-quote-mid{ display:none; }
}

#autopilot-panel .ap2-field{
  display:flex;
  flex-direction: column;
  gap: 6px;
}

#autopilot-panel .ap2-label{
  font-size: 0.72rem;
  opacity: .78;
  letter-spacing: .08em;
  text-transform: uppercase;
}

#autopilot-panel .ap2-input{
  width: 100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.20);
  background: rgba(2,6,23,0.35);
  color: rgba(226,232,240,0.96);
  outline: none;
}
#autopilot-panel .ap2-input:focus{
  border-color: rgba(34,211,238,0.45);
  box-shadow: 0 0 0 4px rgba(34,211,238,0.10);
}


.status-hero-main {
  font-size: 1.35rem;
  font-weight: 500; /* <-- aqui para de deixar tudo bold */
  color: #e5e7eb;
}

/* mantém os labels (strong) com destaque */
.status-hero-main strong {
  font-weight: 800;
}

/* Comentário do AARON formatado em linhas */
.comment-lines {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 6px;
}

.comment-line {
  font-weight: 500;
  line-height: 1.35;
  font-size: 0.92rem;
}

.comment-line strong {
  font-weight: 800;
}


.status-hero-sub {
  font-size: 0.8rem;
  color: var(--text-soft, #9ca3af);
}

/* bolha da direita (GO FULL / WAIT etc.) */
.status-hero-badge {
  min-width: 88px;
  text-align: center;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 0.75rem;
  font-weight: 700;
  letter-spacing: 0.18em;
  text-transform: uppercase;
}

/* cores por estado */
.status-buy {
  background: radial-gradient(circle at top left, rgba(34,197,94,0.22), #020617);
  border-color: rgba(34,197,94,0.8);
}

.status-sell {
  background: radial-gradient(circle at top left, rgba(248,113,113,0.22), #020617);
  border-color: rgba(248,113,113,0.9);
}

.status-wait {
  background: radial-gradient(circle at top left, rgba(234,179,8,0.22), #020617);
  border-color: rgba(234,179,8,0.9);
}

.status-no-trade {
  background: radial-gradient(circle at top left, rgba(148,163,184,0.22), #020617);
  border-color: rgba(148,163,184,0.9);
}

/* cores da badge */
.status-hero-badge.buy { background: rgba(34,197,94,0.18); color:#bbf7d0; }
.status-hero-badge.sell { background: rgba(248,113,113,0.18); color:#fecaca; }
.status-hero-badge.wait { background: rgba(234,179,8,0.18); color:#facc15; }
.status-hero-badge.no-trade { background: rgba(148,163,184,0.18); color:#e5e7eb; }

/* piscando leve para EXECUTAR AGORA */
.blink-hero {
  animation: heroPulse 1.4s ease-in-out infinite;
}

@keyframes heroPulse {
  0%   { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0.7); }
  50%  { transform: scale(1.01); box-shadow: 0 0 0 12px rgba(248,113,113,0); }
  100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(248,113,113,0); }
}
/* pulsante vermelho (para SL 1x1) */
.pulse-sl {
  animation: slTextPulse 1.05s ease-in-out infinite;
}

@keyframes slTextPulse {
  0%, 100% {
    text-shadow: 0 0 0 rgba(248,113,113,0);
    filter: brightness(1);
  }
  50% {
    text-shadow: 0 0 16px rgba(248,113,113,0.75);
    filter: brightness(1.25);
  }
}
/* pulsante verde (Premonição Micro LIVE - valor verde) */
.pulse-micro{
  display: inline-block;
  animation: microTextPulse 1.05s ease-in-out infinite;
}

@keyframes microTextPulse{
  0%, 100%{
    text-shadow: 0 0 0 rgba(74,222,128,0);
    filter: brightness(1);
  }
  50%{
    text-shadow: 0 0 16px rgba(74,222,128,0.75);
    filter: brightness(1.18);
  }
}

/* ====== PATTERN DRAWINGS (PADRÃO DO DIA / MOMENTO) ====== */

.pattern-canvas {
  background: rgba(15,23,42,0.9);
  border-radius: 10px;
  padding: 4px 6px;
  margin-bottom: 6px;
  border: 1px solid rgba(148,163,184,0.35);
}

.pattern-svg {
  width: 100%;
  height: 34px;
}

.prob-phrase {
  font-size: 0.76rem;
  margin-top: 4px;
  color: var(--text-soft, #9ca3af);
}

.prob-phrase.favor {
  color: #bbf7d0;
}

.prob-phrase.contra {
  color: #fecaca;
}
    /* ====== ESTRUTURA RECENTE — HH / HL / LH / LL ====== */

.structure-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.structure-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 8px;
}

.structure-chip {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.55);
  background: rgba(15, 23, 42, 0.95);
  font-size: 0.78rem;
}

.structure-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.16em;
  color: var(--text-soft);
}

.structure-status {
  font-weight: 500;
  color: var(--text-main);
}

.structure-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: #4b5563;
  box-shadow: 0 0 0 1px rgba(15, 23, 42, 1);
  margin-left: 6px;
}

.structure-dot.on {
  background: #fb7185;
  box-shadow: 0 0 10px rgba(248, 113, 113, 0.85);
}

/* ZigZag / Market Structure */

.structure-zigzag-title {
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: var(--text-soft);
  margin-bottom: 4px;
}

.structure-zigzag-box {
  border-radius: 10px;
  border: 1px solid rgba(148, 163, 184, 0.35);
  background: rgba(15, 23, 42, 0.96);
  padding: 4px 6px;
}

.structure-zigzag-svg {
  width: 100%;
  height: 40px;
}

/* ====== GERENCIADOR DE RISCO · ATR ====== */

.risk-card {
  background: var(--card);
  border-radius: 18px;
  border: 1px solid var(--card-border);
  padding: 14px 16px;
  margin-bottom: 14px;
  box-shadow: 0 18px 40px rgba(15,23,42,0.7);
}

.risk-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.risk-title {
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: var(--text-soft);
}

.risk-subtitle {
  font-size: 0.75rem;
  color: var(--text-soft);
}

.risk-toggle {
  border-radius: 999px;
  padding: 4px 12px;
  border: 1px solid var(--accent);
  background: transparent;
  color: var(--accent);
  font-size: 0.75rem;
  cursor: pointer;
}

.risk-toggle:hover {
  background: var(--accent-soft);
}

.risk-body {
  margin-top: 12px;
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 10px 12px;
}

.risk-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.risk-label {
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--text-soft);
}

.risk-group input,
.risk-group select {
  background: #020617;
  border-radius: 10px;
  border: 1px solid #1f2937;
  padding: 6px 8px;
  font-size: 0.78rem;
  color: var(--text-main);
}

.risk-group input:focus,
.risk-group select:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(34,211,238,0.35);
}

.risk-actions {
  grid-column: 1 / -1;
  display: flex;
  justify-content: flex-start;
  margin-top: 4px;
}

.risk-actions button {
  border-radius: 999px;
  padding: 6px 16px;
  border: none;
  background: var(--accent);
  color: #020617;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
}

.risk-results {
  grid-column: 1 / -1;
  margin-top: 8px;
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 10px 12px;
}

.risk-result-label {
  font-size: 0.72rem;
  color: var(--text-soft);
}

.risk-result-value {
  font-size: 0.9rem;
  font-weight: 600;
}

.risk-result-value.small {
  font-size: 0.78rem;
  opacity: 0.8;
}
    /* ====== TOGGLE DE IDIOMA PT / EN ====== */
    .lang-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(148, 163, 184, 0.45);
      margin-right: 12px;
    }

    .lang-btn {
      border: none;
      background: transparent;
      color: var(--text-soft);
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      cursor: pointer;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .lang-btn.active {
      background: rgba(34, 211, 238, 0.18);
      color: var(--accent);
    }
    /* ====== PULLBACK BRAIN – UX AVANÇADO ====== */

.pullback-header-row {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 10px;
  margin-bottom: 6px;
}

.pullback-status-block {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.pullback-status-label {
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: var(--text-soft);
}

.pullback-status-main {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--text-main);
}

.pullback-meta-block {
  text-align: right;
  font-size: 0.76rem;
  color: var(--text-soft);
}

.pullback-tag-row {
  display: flex;
  gap: 6px;
  margin-top: 4px;
  justify-content: flex-end;
}

.pullback-tag {
  border-radius: 999px;
  padding: 3px 8px;
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  border: 1px solid rgba(148,163,184,0.5);
  background: rgba(15,23,42,0.9);
  white-space: nowrap;
}

.pullback-tag.side-buy {
  border-color: rgba(34,197,94,0.9);
  color: #bbf7d0;
}

.pullback-tag.side-sell {
  border-color: rgba(248,113,113,0.9);
  color: #fecaca;
}

.pullback-tag.side-neutral {
  border-color: rgba(148,163,184,0.8);
  color: #e5e7eb;
}

.pullback-tag.stage {
  border-color: rgba(56,189,248,0.9);
  color: #bae6fd;
}

/* termômetro horizontal */
/* PB Candle (do Digest) */
.pb-candle { font-weight: 800; }
.pb-candle.on-buy { color: rgba(34, 197, 94, 0.95); }
.pb-candle.on-sell { color: rgba(248, 113, 113, 0.95); }
.pb-candle.on-conflict { color: rgba(234, 179, 8, 0.95); }
/* PB Candle mini (dentro do SL FLEX) */
.slflex-pbmini{
  display:flex;
  align-items:center;
  gap:8px;
  margin:6px 0 10px 0;
  padding:6px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(15,23,42,.55);
}
.slflex-pb-label{
  font-size:0.70rem;
  letter-spacing:.14em;
  text-transform:uppercase;
  color: var(--text-soft);
}
#slflex-pb-ago{
  font-size:0.72rem;
  color: var(--text-soft);
  opacity:.95;
}

.pullback-meter {
  margin-top: 8px;
  margin-bottom: 8px;
}

.pullback-meter-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.72rem;
  color: var(--text-soft);
  margin-bottom: 4px;
}

.pullback-meter-bar {
  position: relative;
  width: 100%;
  height: 7px;
  border-radius: 999px;
  background: rgba(15,23,42,0.9);
  border: 1px solid rgba(31,41,55,0.9);
  overflow: hidden;
}

.pullback-meter-fill {
  position: absolute;
  inset: 0;
  width: 40%;
  border-radius: inherit;
  background: linear-gradient(90deg, #22c55e, #facc15);
  transition: width 0.25s ease-out;
}

.pullback-meter-fill.neutral {
  background: linear-gradient(90deg, #eab308, #f97316);
}

.pullback-meter-fill.danger {
  background: linear-gradient(90deg, #f97373, #fb7185);
}

/* já existia, mas este bloco usa muito: */
.pullback-highlight {
  font-size: 0.78rem;
  margin-top: 8px;
  padding: 6px 8px;
  border-radius: 10px;
  background: rgba(34, 197, 94, 0.08);
  border: 1px solid rgba(34, 197, 94, 0.4);
}

    /* === SIZING BRAIN – GERENCIADOR DE RISCO (OFFLINE) – EXTRA UI === */

/* Stop e Take bem destacados */
#sb-stop-price {
  color: var(--danger);
  font-weight: 600;
  font-size: 0.95rem;
}

#sb-take-price {
  color: var(--success);
  font-weight: 600;
  font-size: 0.95rem;
}

/* Termômetro offline */
.sb-meter {
  margin-top: 10px;
}

.sb-meter-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.72rem;
  color: var(--text-soft);
  margin-bottom: 4px;
}

.sb-meter-bar {
  position: relative;
  width: 100%;
  height: 7px;
  border-radius: 999px;
  background: rgba(15,23,42,0.9);
  border: 1px solid rgba(31,41,55,0.9);
  overflow: hidden;
}

.sb-meter-fill {
  position: absolute;
  inset: 0;
  width: 0%;
  border-radius: inherit;
  background: linear-gradient(90deg, #22c55e, #facc15);
  transition: width 0.25s ease-out;
}

/* variações de cor conforme o risco usado */
.sb-meter-fill.safe {
  background: linear-gradient(90deg, #22c55e, #22d3ee);
}

.sb-meter-fill.warn {
  background: linear-gradient(90deg, #facc15, #fb923c);
}

.sb-meter-fill.danger {
  background: linear-gradient(90deg, #f97373, #fb7185);
}

    /* ====== SIZING BRAIN – GESTÃO DE CAPITAL DO DIA ====== */

.sizing-header-row {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
  margin-bottom: 6px;
}

.sizing-main-numbers {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.sizing-label {
  font-size: 0.72rem;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: var(--text-soft);
}

.sizing-target-value {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--accent);
}

.sizing-secondary-numbers {
  font-size: 0.76rem;
  color: var(--text-soft);
  text-align: right;
}

.sizing-tag-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 4px;
  margin-bottom: 6px;
}

.sizing-tag {
  border-radius: 999px;
  padding: 3px 9px;
  font-size: 0.7rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  border: 1px solid rgba(148,163,184,0.6);
  background: rgba(15,23,42,0.9);
  white-space: nowrap;
}

.sizing-tag.profile-conservative {
  border-color: rgba(56,189,248,0.9);
  color: #bae6fd;
}

.sizing-tag.profile-normal {
  border-color: rgba(34,197,94,0.9);
  color: #bbf7d0;
}

.sizing-tag.profile-aggressive {
  border-color: rgba(234,179,8,0.9);
  color: #fef9c3;
}

.sizing-tag.style-daytrade {
  border-color: rgba(94,234,212,0.9);
  color: #a5f3fc;
}

.sizing-tag.style-swing {
  border-color: rgba(129,140,248,0.9);
  color: #e0e7ff;
}

.sizing-tag.style-momentum {
  border-color: rgba(251,146,60,0.9);
  color: #fed7aa;
}

.sizing-tag.style-noedge {
  border-color: rgba(148,163,184,0.9);
  color: #e5e7eb;
}

.sizing-meter {
  margin-top: 4px;
  margin-bottom: 6px;
}

.sizing-meter-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.72rem;
  color: var(--text-soft);
  margin-bottom: 4px;
}

.sizing-meter-bar {
  position: relative;
  width: 100%;
  height: 7px;
  border-radius: 999px;
  background: rgba(15,23,42,0.9);
  border: 1px solid rgba(31,41,55,0.9);
  overflow: hidden;
}

.sizing-meter-fill {
  position: absolute;
  inset: 0;
  width: 40%;
  border-radius: inherit;
  background: linear-gradient(90deg, #22c55e, #facc15);
  transition: width 0.25s ease-out;
}

.sizing-comment {
  margin-top: 4px;
  font-size: 0.78rem;
  color: var(--text-main);
  background: rgba(15,23,42,0.85);
  border-radius: 10px;
  padding: 6px 8px;
  border: 1px dashed rgba(148,163,184,0.6);
}

    /* --- SIZING BRAIN · inputs de capital/risco/stop + frases --- */

.sizing-inputs {
  margin-top: 6px;
  margin-bottom: 6px;
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 8px;
}

.sizing-input {
  display: flex;
  flex-direction: column;
  gap: 3px;
  font-size: 0.75rem;
}

.sizing-input label {
  color: var(--text-soft);
  text-transform: none;
  letter-spacing: 0.02em;
}

.sizing-input input {
  border-radius: 999px;
  border: 1px solid rgba(31,41,55,0.9);
  background: #020617;
  padding: 5px 10px;
  font-size: 0.8rem;
  color: var(--text-main);
}

.sizing-input input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px var(--accent-soft);
}

.sizing-phrase {
  margin-top: 2px;
  margin-bottom: 6px;
  font-size: 0.8rem;
  line-height: 1.35;
}

.sizing-phrase-main {
  color: var(--text-main);
}

.sizing-phrase-detail {
  color: var(--text-soft);
  margin-top: 2px;
}

/* responsivo */
@media (max-width: 900px) {
  .sizing-inputs {
    grid-template-columns: 1fr;
  }
}

/* === SIZING BRAIN – GERENCIADOR DE RISCO === */
.sizing-brain-card {
  border: 1px solid var(--card-border);
  border-radius: 16px;
  padding: 16px 20px;
  background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 0.4));
  box-shadow: 0 0 40px rgba(15, 23, 42, 0.8);
}

.sizing-brain-card .card-header h2 {
  margin: 0;
  font-size: 1.1rem;
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.sizing-brain-card .card-subtitle {
  margin: 4px 0 0;
  font-size: 0.75rem;
  color: var(--text-soft);
}

.sb-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px 16px;
  margin-top: 12px;
}

.sb-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.sb-field label {
  font-size: 0.8rem;
  color: var(--text-soft);
}

.sb-field input {
  background: #020617;
  border-radius: 10px;
  border: 1px solid var(--card-border);
  padding: 6px 8px;
  color: var(--text-main);
  font-size: 0.9rem;
}

.sb-field input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.3);
}

.sb-hint {
  font-size: 0.7rem;
  color: var(--text-soft);
}

.sb-divider {
  margin: 14px 0;
  border: none;
  border-top: 1px dashed rgba(148, 163, 184, 0.4);
}

.sb-side-toggle {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 0.8rem;
}

.sb-side-toggle label {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

.sb-side-toggle input[type="radio"] {
  accent-color: var(--accent);
}

.sb-results-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 16px;
  margin-top: 8px;
}

.sb-result-block h3 {
  margin: 0 0 6px;
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-soft);
}

.sb-result-main {
  font-size: 1rem;
  font-weight: 600;
  margin: 2px 0;
}

.sb-result-sub {
  font-size: 0.8rem;
  margin: 2px 0;
  color: var(--text-soft);
}

.sb-actions {
  margin-top: 14px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.primary-btn {
  border-radius: 999px;
  padding: 6px 14px;
  border: 1px solid var(--accent);
  background: radial-gradient(circle at top, var(--accent-soft), transparent);
  color: var(--accent);
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
}

.primary-btn:hover {
  filter: brightness(1.1);
}

.sb-status {
  font-size: 0.75rem;
  color: var(--text-soft);
}

/* ================== GARIMPO DE HOJE ================== */
.garimpo-banner {
  width: 100%;
  /* menos espaço em cima e embaixo, encaixa melhor entre o header e o painel */
  margin: 8px auto 12px auto;
  display: flex;
  justify-content: center;
}

.garimpo-container {
  width: 100%;
  max-width: 100%;         /* agora acompanha a largura inteira da .page */
  padding: 14px 24px;      /* um pouco mais de “respiro” nas laterais */
  border-radius: 18px;
  background: radial-gradient(circle at top left, rgba(80, 220, 255, 0.25), transparent 55%),
              linear-gradient(135deg, rgba(7, 16, 40, 0.95), rgba(10, 26, 70, 0.98));
  border: 1px solid rgba(120, 220, 255, 0.35);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
  display: flex;
  flex-direction: column;
  gap: 10px;
}


.garimpo-badge {
  display: inline-flex;
  align-self: flex-start;
  padding: 4px 10px;
  border-radius: 999px;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  background: rgba(9, 189, 140, 0.18);
  color: #5df2c8;
  border: 1px solid rgba(93, 242, 200, 0.5);
}

.garimpo-main {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.garimpo-header-row {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}

    .garimpo-header-right {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 6px;
}

/* Botão "Ver página do garimpo" no painel principal */
.garimpo-link-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 6px 14px;
  border-radius: 999px;
  border: 1px solid rgba(120, 200, 255, 0.5);
  background: rgba(3, 10, 25, 0.85);
  color: #e5f2ff;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  text-decoration: none;
  cursor: pointer;
  transition:
    background 0.18s ease,
    transform 0.18s ease,
    box-shadow 0.18s ease,
    color 0.18s ease;
}

.garimpo-link-btn:hover {
  background: linear-gradient(135deg, #04d9ff, #22ff88);
  color: #02101f;
  box-shadow: 0 0 12px rgba(34, 211, 238, 0.6);
  transform: translateY(-1px);
}


    .garimpo-right-block {
  display: flex;
  align-items: center;
  gap: 10px;       /* espaço entre o botão e o chip de confiança */
}


.garimpo-title-block {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.garimpo-label {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #a5b4fc;
}

.garimpo-ticker-line {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.garimpo-ticker {
  font-size: 26px;
  font-weight: 700;
  color: #e5e7ff;
}

.garimpo-profile-tag {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  padding: 4px 9px;
  border-radius: 999px;
  background: rgba(59, 130, 246, 0.15);
  color: #bfdbfe;
  border: 1px solid rgba(129, 199, 255, 0.5);
}

.garimpo-confidence-chip {
  display: inline-flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 3px;
  padding: 6px 10px;
  border-radius: 12px;
  background: rgba(15, 118, 110, 0.24);
  border: 1px solid rgba(45, 212, 191, 0.6);
}

.garimpo-confidence-chip .chip-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #a7f3d0;
}

.garimpo-confidence-chip .chip-value {
  font-size: 16px;
  font-weight: 700;
  color: #ecfeff;
}

.garimpo-metrics-row {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  margin-top: 4px;
}

.garimpo-metric {
  min-width: 120px;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.garimpo-metric .metric-label {
  font-size: 11px;
  color: #9ca3af;
}

.garimpo-metric .metric-value {
  font-size: 14px;
  font-weight: 600;
  color: #e5e7eb;
}

.garimpo-comment {
  margin-top: 4px;
  font-size: 12px;
  color: #d1d5db;
  max-width: 800px;
}

/* Responsivo */
@media (max-width: 768px) {
  .garimpo-container {
    padding: 12px 12px;
  }
  .garimpo-ticker {
    font-size: 22px;
  }

  .garimpo-right-actions {
  display: flex;
  align-items: center;
  gap: 10px;
}

/* Botão para abrir a página completa do garimpo */
.garimpo-page-btn {
  border-radius: 999px;
  padding: 6px 14px;
  border: 1px solid rgba(120, 220, 255, 0.6);
  background: radial-gradient(circle at top, rgba(56, 189, 248, 0.35), transparent);
  color: #e0f2fe;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  cursor: pointer;
  white-space: nowrap;
  transition:
    background 0.2s ease,
    transform 0.15s ease,
    box-shadow 0.15s ease;
}

.garimpo-page-btn:hover {
  background: radial-gradient(circle at top, rgba(56, 189, 248, 0.55), transparent);
  box-shadow: 0 0 18px rgba(56, 189, 248, 0.6);
  transform: translateY(-1px);
}

.garimpo-page-btn:active {
  transform: translateY(0);
  box-shadow: none;
}

  
}
/* ================== FIM GARIMPO DE HOJE ================== */
/* ================== COMENTÁRIO DO AARON (entre Garimpo e Premonição) ================== */
.aaron-commentary-container { padding: 12px 16px; }

.aaron-commentary-badges{
  display:flex;
  gap:10px;
  align-items:flex-start;
}

.aaron-badge{ white-space: nowrap; }

.aaron-badge-pattern{
  max-width: 340px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.aaron-commentary-text{
  margin-top: 12px;
  padding: 12px 14px;
  border-radius: 14px;
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.08);
  color: #e5e7eb;
  font-size: 15px;
  line-height: 1.45;
}

.aaron-commentary-text strong{ color: #f8fafc; }

.premonition-badge.aaron-badge.is-up{
  border-color: rgba(34,197,94,.55);
  background: rgba(34,197,94,.12);
  color: rgba(187,247,208,1);
}
.premonition-badge.aaron-badge.is-down{
  border-color: rgba(239,68,68,.55);
  background: rgba(239,68,68,.12);
  color: rgba(254,202,202,1);
}
.premonition-badge.aaron-badge.is-neutral{
  border-color: rgba(148,163,184,.35);
  background: rgba(148,163,184,.12);
  color: rgba(226,232,240,1);
}

@media (max-width: 768px){
  .aaron-commentary-badges{ flex-wrap: wrap; }
  .aaron-badge-pattern{ max-width: 100%; }
}

/* ================== PREMONIÇÃO (Breakout Window Card) ================== */
.premonition-banner{
  margin: 14px 0 12px;
}

.premonition-container{
  background:
    radial-gradient(1200px 320px at 20% 10%, rgba(0,180,255,.16), rgba(0,0,0,0) 55%),
    linear-gradient(180deg, rgba(10,14,22,.65), rgba(10,14,22,.35));
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 18px;
  padding: 14px 16px;
  position: relative;
  overflow: hidden;
}

.premonition-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:12px;
  margin-bottom: 10px;
}

.premonition-title{
  font-size: 13px;
  font-weight: 900;
  letter-spacing: .18em;
  opacity:.92;
}

.premonition-sub{
  font-size: 12px;
  opacity:.70;
  margin-top: 2px;
}
/* Current Price no header (fora do gráfico) */
.prem-head-current{
  margin-top: 8px;
  margin-bottom: 0;
}

.premonition-badge{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity:.9;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  white-space: nowrap;
}

/* ✅ RR: overrides locais (ANTES estava #rr-panel, mas o id real é rr-section) */
#rr-section .premonition-container{
  overflow: visible; /* evita “corte” quando texto quebra linha */
}

#rr-section .premonition-badge{
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.15;
}

#rr-section .premonition-value{
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* ✅ RR: readout completo (lista estilo sua 2ª imagem) */
#rr-section .rr-readout{
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(255,255,255,.08);
  display: flex;
  flex-direction: column;
  gap: 6px;
}

#rr-section .rr-line{
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 12px;
}

#rr-section .rr-key{
  color: rgba(255,255,255,.65);
  text-transform: uppercase;
  letter-spacing: .08em;
  flex: 0 0 auto;
}

#rr-section .rr-val{
  color: rgba(255,255,255,.92);
  text-align: right;
  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  flex: 1 1 auto;
}

#rr-section .rr-action{
  font-weight: 800;
}



.premonition-grid{
  display:grid;
  grid-template-columns: 1.2fr .8fr;
  gap: 14px;
  align-items: stretch;
}

@media (max-width: 980px){
  .premonition-grid{ grid-template-columns: 1fr; }
}

.premonition-chart{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  background: rgba(0,0,0,.22);
  position: relative;
  overflow: hidden;
  padding: 10px;
}

.premonition-canvas{
  width: 100%;
  height: 240px;
  display:block;
}
/* ===== MICRO TIMELINE (substitui canvas no quadro grande) ===== */
.microtime-panel{
  min-height: 380px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.08);
  background:
    radial-gradient(900px 280px at 0% 0%, rgba(96,165,250,.10), rgba(0,0,0,0) 60%),
    rgba(0,0,0,.18);
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
/* ===== MICRO MAP (NOW) — card ao lado do Micro Timeline + WINDOWS ===== */
.microtime-split{
  display: flex;
  gap: 10px;
  align-items: stretch;
}
.microtime-split > .microtime-panel{
  flex: 1 1 420px;
}

/* NOVO: coluna da direita (Micro Map + Windows lado a lado) */
.micro-right-split{
  flex: 1 1 520px;
  display: flex;
  gap: 10px;
  align-items: stretch;
  min-width: 520px;
}

/* Micro Map “squish” (fica menor) */
.micro-right-split > .micro-map-card{
  flex: 0 1 330px;
  min-width: 300px;
}

/* NOVO: WINDOWS card */
.windows-card{
  flex: 1 1 260px;
  min-height: 380px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.08);
  background:
    radial-gradient(900px 280px at 0% 0%, rgba(56,189,248,.08), rgba(0,0,0,0) 60%),
    rgba(0,0,0,.18);
  padding: 14px;
}

.windows-title{
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .85;
  margin-bottom: 10px;
}

.windows-line{
  font-size: 14px;
  font-weight: 800;
  line-height: 1.35;
  margin: 0 0 10px 0;
  white-space: normal; /* pode quebrar linha */
  overflow-wrap: anywhere;
}

.win-badge{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 950;
  letter-spacing: .12em;
  text-transform: uppercase;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
}

.win-wait{
  background: rgba(148,163,184,.12);
  border-color: rgba(148,163,184,.22);
  color: rgba(226,232,240,.95);
}
.win-now{
  background: rgba(74,222,128,.15);
  border-color: rgba(74,222,128,.30);
  color: rgba(74,222,128,.95);
}
.win-warn{
  background: rgba(250,204,21,.15);
  border-color: rgba(250,204,21,.30);
  color: rgba(250,204,21,.95);
}

.windows-foot{
  font-size: 11px;
  opacity: .65;
  margin-top: 10px;
}

/* responsivo */
@media (max-width: 1100px){
  .microtime-split{ flex-direction: column; }
  .micro-right-split{ flex-direction: column; min-width: 0; }
  .micro-map-card{ min-height: auto; }
  .windows-card{ min-height: auto; }
}
/* ===== /MICRO MAP (NOW) + WINDOWS ===== */


.microtime-row{
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.22);
}

.mt-k{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .65;
  flex: 0 0 auto;
}

.mt-v{
  font-size: 16px;
  font-weight: 900;
  color: rgba(255,255,255,.92);
  text-align: right;
  flex: 1 1 auto;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.mt-target{ color: rgba(255,208,64,.95); }
.mt-up{ color: rgba(74,222,128,.95); }
.mt-down{ color: rgba(248,113,113,.95); }
.mt-muted{ opacity: .75; font-weight: 800; font-size: 13px; }
/* ===== /MICRO TIMELINE ===== */

.premonition-kpi{
  margin-top: 10px;
  display:flex;
  align-items: baseline;
  gap: 10px;
  flex-wrap: wrap;
}
/* ===== PREMONIÇÃO: CTA filtrado (AÇÃO + Micro >= 75%) ===== */
.prem-signal-wrap{
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(255,255,255,.08);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.prem-signal-btn{
  width: 100%;
  border-radius: 999px;
  padding: 16px 16px;
  font-size: 44px;
  font-weight: 950;
  letter-spacing: .14em;
  text-transform: uppercase;
  cursor: pointer;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.03);
  color: rgba(255,255,255,.40);
  transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;
}

.prem-signal-btn:disabled{
  cursor: not-allowed;
  opacity: .55;
}

.prem-signal-btn:not(:disabled):hover{
  transform: translateY(-1px);
  filter: brightness(1.08);
}

.prem-signal-off{
  border-color: rgba(255,255,255,.12);
  background: rgba(255,255,255,.03);
  color: rgba(255,255,255,.40);
  box-shadow: none;
}

.prem-signal-sell{
  border-color: rgba(255,208,64,.45);
  background: radial-gradient(800px 120px at 50% 0%, rgba(255,208,64,.28), rgba(0,0,0,0) 70%);
  color: rgba(255,208,64,.95);
  box-shadow: 0 0 22px rgba(255,208,64,.14);
}

.prem-signal-buy{
  border-color: rgba(56,189,248,.45);
  background: radial-gradient(800px 120px at 50% 0%, rgba(56,189,248,.26), rgba(0,0,0,0) 70%);
  color: rgba(200,245,255,.95);
  box-shadow: 0 0 22px rgba(56,189,248,.14);
}

.prem-signal-hint{
  font-size: 11px;
  opacity: .65;
  letter-spacing: .08em;
  text-transform: uppercase;
}
/* ===== EXEC GATE (Micro) — abaixo do botão grande ===== */
.exec-gate{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.22);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.eg-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
}

.eg-title{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .85;
}

.eg-mode{
  display:flex;
  gap: 6px;
}

.eg-mode-btn{
  border-radius: 999px;
  padding: 6px 10px;
  font-size: 10px;
  letter-spacing: .10em;
  text-transform: uppercase;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.03);
  color: rgba(255,255,255,.70);
  cursor: pointer;
}
.eg-mode-btn.is-on{
  border-color: rgba(255,208,64,.45);
  color: rgba(255,208,64,.95);
  box-shadow: 0 0 14px rgba(255,208,64,.10);
}

.eg-metrics{
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
}

@media (max-width: 980px){
  .eg-metrics{ grid-template-columns: repeat(2, 1fr); }
}

.eg-kv{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 12px;
  padding: 6px 8px;
  background: rgba(255,255,255,.02);
  display:flex;
  justify-content:space-between;
  align-items:baseline;
  gap: 8px;
}

.eg-kv .k{
  font-size: 9px;
  opacity: .65;
  letter-spacing: .12em;
  text-transform: uppercase;
}
.eg-kv .v{
  font-size: 13px;
  font-weight: 850;
}

.eg-strong{
  color: rgba(255,208,64,.95);
}

.eg-edge.is-ok .v{ color: var(--success, rgba(34,197,94,.95)); }
.eg-edge.is-no .v{ color: rgba(255,208,64,.95); }

.eg-microline{
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

@media (max-width: 980px){
  .eg-microline{ grid-template-columns: 1fr; }
}

.eg-inputs{
  display:grid;
  grid-template-columns: 1fr 1.35fr 1fr 1fr 1fr;
  gap: 8px;
  margin-top: 2px;
}

@media (max-width: 980px){
  .eg-inputs{ grid-template-columns: 1fr 1fr; }
}

.eg-lbl{
  display:block;
  font-size: 9px;
  opacity: .6;
  letter-spacing: .12em;
  text-transform: uppercase;
  margin-bottom: 4px;
}

.eg-input,
.eg-select{
  width: 100%;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.25);
  color: rgba(255,255,255,.88);
  padding: 8px 10px;
  font-size: 12px;
  outline: none;
}

.eg-stop-row{
  display:flex;
  gap: 6px;
}
.eg-stop-row .eg-select{
  flex: 0 0 90px;
}

.eg-table-wrap{
  margin-top: 6px;
  overflow:auto;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.08);
}

.eg-table{
  width: 100%;
  border-collapse: collapse;
  min-width: 760px;
  font-size: 12px;
}

.eg-table th{
  font-size: 9px;
  letter-spacing: .12em;
  text-transform: uppercase;
  opacity: .7;
  text-align: left;
  background: rgba(0,0,0,.25);
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  white-space: nowrap;
}

.eg-table td{
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  white-space: nowrap;
}

.eg-td-acct{
  font-weight: 850;
  color: rgba(255,255,255,.90);
}

.eg-row-off{
  opacity: .35;
}

.eg-foot{
  font-size: 10px;
  opacity: .7;
  letter-spacing: .08em;
  text-transform: uppercase;
}

.exec-gate.eg-1line .eg-hide-1line{
  display:none !important;
}

/* ===== PREMONIÇÃO: Breakout / Retest (abaixo do botão grande) ===== */
.prem-breakout-wrap{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.22);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.prem-breakout-title{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .65;
}

.prem-breakout-grid{
  display: grid;
  grid-template-columns: repeat(4, minmax(0,1fr));
  gap: 10px;
}

.pb-k{
  font-size: 9px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .55;
}

.pb-v{
  margin-top: 2px;
  font-size: 12px;
  font-weight: 800;
  color: rgba(255,208,64,.95);
}

.prem-breakout-note{
  font-size: 10px;
  opacity: .55;
}
/* ===== EXEC MICRO + EE BRAIN (lado a lado) ===== */
.prem-exec-grid{
  display: grid;
  grid-template-columns: minmax(0, 1.35fr) minmax(0, 0.65fr);
  gap: 14px;
  align-items: start;
}
.prem-exec-grid > *{ min-width: 0; }

/* em telas menores, empilha */
@media (max-width: 1180px){
  .prem-exec-grid{ grid-template-columns: 1fr; }
}

/* ===== EE BRAIN ===== */
.ee-badge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:4px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(0,0,0,.22);
  font-size:11px;
  font-weight:900;
  letter-spacing:.06em;
}
.ee-badge.go{ color:#34d399; border-color: rgba(52,211,153,.25); }
.ee-badge.wait{ color:#facc15; border-color: rgba(250,204,21,.25); }
.ee-badge.no{ color:#fb7185; border-color: rgba(251,113,133,.25); }

.ee-k{
  font-size:9px;
  letter-spacing:.14em;
  text-transform:uppercase;
  opacity:.55;
}
.ee-line{
  font-size:12px;
  line-height:1.35;
  color: rgba(255,255,255,.88);
}
.ee-strong{ font-weight:950; }
/* ===== ENTRY ENGINE (AARON) — acima do EE BRAIN ===== */
#ee-engine-card{ padding: 12px 14px; }

.ee-engine-top{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 14px;
  flex-wrap: wrap;
}

.ee-engine-left{
  display:flex;
  flex-direction:column;
  gap: 8px;
  min-width: 180px;
}

.ee-engine-pill{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding: 8px 14px;
  border-radius: 999px;
  font-size: 14px;
  font-weight: 950;
  letter-spacing: .16em;
  text-transform: uppercase;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
}

.ee-engine-pill.loading{ color: rgba(226,232,240,.92); border-color: rgba(148,163,184,.28); background: rgba(148,163,184,.10); }
.ee-engine-pill.armed{ color: #facc15; border-color: rgba(250,204,21,.30); background: rgba(250,204,21,.12); box-shadow: 0 0 18px rgba(250,204,21,.12); }
.ee-engine-pill.confirmed{ color: #34d399; border-color: rgba(52,211,153,.30); background: rgba(52,211,153,.10); box-shadow: 0 0 18px rgba(52,211,153,.10); }
.ee-engine-pill.failed{ color: #fb7185; border-color: rgba(251,113,133,.32); background: rgba(251,113,133,.10); box-shadow: 0 0 18px rgba(251,113,133,.10); }

.ee-engine-meta{ display:flex; gap: 10px; align-items:center; }

.ee-engine-mode{
  font-size: 11px;
  font-weight: 950;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .90;
}
.ee-engine-mode.strong{ color: rgba(52,211,153,.95); }
.ee-engine-mode.noise{ color: rgba(255,208,64,.95); }
.ee-engine-mode.notrade{ color: rgba(226,232,240,.70); }

.ee-engine-rule{
  font-size: 11px;
  font-weight: 900;
  opacity: .78;
  letter-spacing: .06em;
}

.ee-engine-dir{
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  font-size: 11px;
  font-weight: 950;
  letter-spacing: .10em;
  opacity: .88;
}

.ee-engine-prob{
  font-size: 18px;
  font-weight: 950;
  color: #ffcc66;
  letter-spacing: .02em;
}

/* layout (como no mockup) */
.ee-engine-right{
  flex: 1 1 560px;
  display:grid;
  grid-template-columns: 1.25fr 0.75fr;
  gap: 12px;
  align-items: stretch;
  min-width: 520px;
}

.ee-engine-stack{
  display:flex;
  flex-direction:column;
  gap: 12px;
}

.ee-engine-box{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  background: rgba(255,255,255,.02);
  padding: 12px 14px;
}

.ee-engine-box .k{
  font-size: 10px;
  letter-spacing: .16em;
  text-transform: uppercase;
  opacity: .70;
  margin-bottom: 6px;
  font-weight: 900;
}

.ee-engine-box .v{
  font-size: 46px;
  font-weight: 950;
  line-height: 1.05;
  border-radius: 16px;
  padding: 6px 12px;
  display:inline-block;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 0 18px rgba(0,0,0,.35);
}

.ee-engine-box.big{ padding: 16px 16px; border-radius: 18px; }
.ee-engine-box.big .v{ font-size: 84px; padding: 10px 14px; }
.ee-engine-box.stack .v{ font-size: 46px; }

@media (max-width: 980px){
  .ee-engine-right{ grid-template-columns: 1fr; min-width: 0; width: 100%; }
  .ee-engine-stack{ flex-direction: row; }
  .ee-engine-box.stack{ flex: 1 1 0; }
  .ee-engine-box.big .v{ font-size: 64px; }
}

#ee-engine-confirm{ color: #34d399; border-color: rgba(52,211,153,.28); background: rgba(52,211,153,.08); }
#ee-engine-touch{ color: #60a5fa; border-color: rgba(96,165,250,.28); background: rgba(96,165,250,.08); }
#ee-engine-cancel{ color: #fb7185; border-color: rgba(251,113,133,.28); background: rgba(251,113,133,.08); }

.ee-engine-note{
  margin-top: 6px;
  font-size: 12px;
  opacity: .78;
  letter-spacing: .02em;
}
/* ===== /ENTRY ENGINE ===== */
/* ===== EE BRAIN — BIG FONTS (igual Quick P&L / Most Optimal Entry) ===== */
#ee-brain-card{ padding: 12px 14px; }

#ee-brain-card .prem-breakout-title{
  font-size: 12px;
  opacity: .72;
}

#ee-brain-card .ee-badge{
  font-size: 14px;
  padding: 6px 12px;
}

#ee-brain-card .ee-hdr{
  font-size: 14px;
  font-weight: 900;
  opacity: .80;
  text-align: right;
}

#ee-brain-card .ee-k{ font-size: 10px; }

#ee-brain-card .ee-line{
  font-size: 16px;
  line-height: 1.35;
}

#ee-brain-card .ee-line .ee-strong{ font-size: 18px; }

#ee-brain-card #ee-entry,
#ee-brain-card #ee-conf,
#ee-brain-card #ee-target{ font-size: 18px; }

#ee-brain-card .prem-breakout-note{ font-size: 12px; }
/* ===== EE BRAIN — TRIGGER/CANCEL (quadrado amarelo) ===== */
#ee-brain-card #ee-trigger,
#ee-brain-card #ee-cancel{
  font-size: 22px;
  line-height: 1.25;
  font-weight: 900;
  opacity: .92;
}

/* preço gigante (igual Current Price) */
#ee-brain-card .ee-price{
  display:inline-block;
  padding: 0 8px;
  margin: 0 3px;
  font-size: 44px;          /* igual Current Price */
  font-weight: 950;
  letter-spacing: .02em;
  line-height: 1.05;
  border-radius: 14px;
  background: rgba(255,255,255,.04);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 0 18px rgba(0,0,0,.35);
  vertical-align: baseline;
}

#ee-brain-card .ee-price.ee-above{
  color: var(--success);
  border-color: rgba(74,222,128,.28);
  background: rgba(74,222,128,.08);
}

#ee-brain-card .ee-price.ee-below{
  color: var(--danger);
  border-color: rgba(248,113,113,.28);
  background: rgba(248,113,113,.08);
}

#ee-brain-card .ee-price.ee-at{
  color: #ffcc66;
  border-color: rgba(255,208,64,.22);
  background: rgba(255,208,64,.06);
}

/* footer mais legível */
#ee-brain-card #ee-foot{
  font-size: 18px;
  opacity: .88;
}
#ee-brain-card .ee-pct{ font-weight: 950; }
#ee-brain-card .ee-pct.ee-ok{ color: var(--success); }
#ee-brain-card .ee-pct.ee-bad{ color: var(--danger); }
#ee-brain-card .ee-pct.ee-warn{ color: #ffcc66; }

/* mobile */
@media (max-width: 720px){
  #ee-brain-card #ee-trigger,
  #ee-brain-card #ee-cancel{ font-size: 16px; }
  #ee-brain-card .ee-price{ font-size: 28px; }
  #ee-brain-card #ee-foot{ font-size: 14px; }
}
/* mobile: evita quebrar layout */
@media (max-width: 720px){
  #ee-brain-card .ee-line{ font-size: 14px; }
  #ee-brain-card .ee-line .ee-strong,
  #ee-brain-card #ee-entry,
  #ee-brain-card #ee-conf,
  #ee-brain-card #ee-target{ font-size: 16px; }
  #ee-brain-card .ee-badge,
  #ee-brain-card .ee-hdr{ font-size: 12px; }
}
@media (max-width: 720px){
  .prem-signal-btn{ font-size: 28px; padding: 14px 14px; }
}

/* RR: NÃO cortar conteúdo */
#rr-container{ overflow: visible !important; }

/* RR: readout estilo “bloco” (igual sua 2ª imagem) */
#rr-section .rr-readout{
  margin-top: 10px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.08);
  background: rgba(0,0,0,0.28);
  color: rgba(255,255,255,0.92);
  display: block !important;
  overflow: visible;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 12px;
  line-height: 1.35;
  letter-spacing: 0.02em;
}

#rr-section .rr-line{
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  justify-content: center;
  margin-top: 6px;
}
#rr-section .rr-line:first-child{ margin-top: 0; }

#rr-section .rr-k{
  opacity: 0.75;
  font-size: 10px;
  letter-spacing: 0.16em;
  text-transform: uppercase;
}
#rr-section .rr-v{
  font-weight: 800;
  opacity: 0.95;
}
#rr-section .rr-pipe{
  opacity: 0.35;
  font-weight: 700;
  margin: 0 2px;
}

/* 🔥 RR: hierarquia + highlight amarelo (áreas circuladas) */
#rr-section .premonition-title{
  color: rgba(255, 208, 64, 0.95);
  font-size: 14px;
  font-weight: 950;
}

#rr-section .premonition-sub{
  color: rgba(255, 208, 64, 0.65);
}

/* layout Respiro/Reversão (lado a lado) */
#rr-section .rr-grid{
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 18px;
  align-items: start;
}
@media (max-width: 720px){
  #rr-section .rr-grid{ grid-template-columns: 1fr; }
}

#rr-section .rr-label{
  color: rgba(255, 208, 64, 0.70);
  text-transform: uppercase;
  letter-spacing: 0.14em;
  font-size: 11px;
  margin-bottom: 4px;
}

#rr-section .rr-value{
  color: rgba(255, 208, 64, 0.95);
  font-size: 18px;
  font-weight: 950;
  line-height: 1.1;
}

#rr-section .rr-sub{
  color: rgba(255, 208, 64, 0.70);
  font-size: 12px;
  margin-top: 4px;
}

#rr-section .rr-badge{
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255, 208, 64, 0.20);
  background: rgba(255, 208, 64, 0.08);
  color: rgba(255, 208, 64, 0.95);
  font-weight: 900;
  letter-spacing: 0.10em;
  text-transform: uppercase;
}

/* barra do meio (readout) mais forte */
#rr-section .rr-readout{
  border-color: rgba(255, 208, 64, 0.16);
  background: rgba(0,0,0,0.32);
}

#rr-section .rr-line{
  font-size: 13px;
  gap: 10px;
}

#rr-section .rr-k{
  color: rgba(255, 208, 64, 0.72);
  opacity: 1;
  font-size: 11px;
}

#rr-section .rr-v{
  color: rgba(255, 255, 255, 0.92);
  font-size: 13px;
  font-weight: 900;
}

#rr-section #rr-acao{
  color: rgba(255, 208, 64, 0.95);
}

#rr-section .rr-pipe{
  color: rgba(255, 208, 64, 0.40);
  opacity: 1;
}


.premonition-kpi .kpi-label{
  opacity:.7;
  font-size: 12px;
}

.premonition-kpi .kpi-time{
  font-size: 34px;
  font-weight: 950;
  letter-spacing: .02em;
  color: #ffcc66;
}

.premonition-kpi .kpi-ampm{
  font-size: 12px;
  opacity:.85;
  margin-left: -6px;
}

.premonition-kpi .kpi-prob{
  font-size: 26px;
  font-weight: 950;
  color: #ffcc66;
}

.premonition-panel{
  border: 1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  background: rgba(0,0,0,.18);
  padding: 12px 12px;
}

.premonition-panel .row{
  padding: 10px 0;
  border-bottom: 1px solid rgba(255,255,255,.06);
}

.premonition-panel .row:last-child{
  border-bottom: none;
}

.premonition-panel .label{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .75;
  margin-bottom: 6px;
}

.premonition-panel .value{
  font-size: 13px;
  line-height: 1.35;
}

.premonition-panel .muted{
  opacity: .70;
}

/* ====== PREMONIÇÃO (Mockup upgrade) ====== */

/* deixa o KPI antigo embaixo do chart discreto (ou esconda se quiser) */
.premonition-kpi { opacity: .18; transform: scale(.95); }
@media (max-width: 980px){
  .premonition-kpi { opacity: .10; }
}

/* FIX: Premonição visível (KPI estava quase invisível) */
.premonition-banner .premonition-kpi{
  opacity: .78 !important;
  transform: scale(1) !important;
}

.premonition-banner .premonition-kpi{
  background: rgba(0,0,0,.28);
  border: 1px solid rgba(255,255,255,.14);
  backdrop-filter: blur(6px);
}

.premonition-banner .premonition-kpi .kpi-label{ opacity: .85; }
.premonition-banner .premonition-kpi .kpi-time,
.premonition-banner .premonition-kpi .kpi-prob{ opacity: 1; font-weight: 700; }


/* KPI grande no painel direito */
.prem-kpi-right{
  padding: 10px 10px 14px;
  margin-bottom: 10px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}

.prem-kpi-right-title{
  font-size: 14px;
  font-weight: 850;
  opacity: .85;
  margin-bottom: 10px;
}
/* Current Price (acima do horário no KPI grande) */
.prem-kpi-right-current{
  display:flex;
  align-items: baseline;
  gap: 12px;
  flex-wrap: wrap;
  width: 100%;
  flex-basis: 100%;
  margin-bottom: 6px;
}
.prem-kpi-right-current-price{
    color: #ffcc66 !important;
}
/* ===== Institutional Window (topo da Premonição) ===== */
.inst-window{
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  padding: 6px 10px;
  min-height: 34px;
  margin: 2px 14px 0 14px;
  border-radius: 12px;
  background: rgba(255,255,255,.03);
  border: 1px solid rgba(255,255,255,.06);
  box-shadow: 0 10px 30px rgba(0,0,0,.25) inset;
}

.inst-tag{
  font-size: 11px;
  font-weight: 900;
  letter-spacing: .10em;
  text-transform: uppercase;
  padding: 6px 10px;
  border-radius: 999px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  color: rgba(255,255,255,.92);
}

.inst-range{
  font-size: 12px;
  font-weight: 800;
  opacity: .85;
  color: rgba(255,255,255,.92);
}

.inst-msg{
  font-size: 12px;
  font-weight: 900;
  letter-spacing: .02em;
  color: rgba(255,255,255,.75);
}

/* estados (cores) */
.inst-on .inst-msg{ color: var(--success, #4ade80); }
.inst-caution .inst-msg{ color: #ffcc66; }
.inst-off .inst-msg{ color: rgba(255,255,255,.55); }

/* Current Price no chart (overlay no topo do gráfico) */
.prem-chart-current-wrap{
  position: absolute;
  top: 8px;
  left: 12px;
  z-index: 6;
  display: flex;
  align-items: baseline;
  gap: 10px;
  pointer-events: none;
  transform: scale(.78);
  transform-origin: top left;
}

.prem-kpi-right-main{
  display:flex;
  align-items: baseline;
  gap: 12px;
  flex-wrap: wrap;
}

.prem-kpi-right-time{
  font-size: 44px;
  font-weight: 950;
  letter-spacing: .02em;
  color: rgba(255,255,255,.95);
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
}

.prem-kpi-right-ampm{
  font-size: 14px;
  font-weight: 800;
  opacity: .85;
  margin-left: -8px;
}

.prem-kpi-right-prob{
  font-size: 36px;
  font-weight: 950;
  color: #ffcc66;
  text-shadow: 0 10px 30px rgba(0,0,0,.55);
}

.prem-kpi-right-sub{
  margin-top: 10px;
  font-size: 16px;
  opacity: .75;
}
/* ===== QUICK P&L (Premonição) ===== */
.prem-pnlcalc{
  margin-top: 10px;
  padding: 10px 10px 12px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  background: rgba(0,0,0,.22);
}

.prem-pnlcalc .pnl-h{
  font-size: 11px;
  font-weight: 950;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .80;
  margin-bottom: 8px;
}

.prem-pnlcalc .pnl-controls{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.prem-pnlcalc .pnl-field{
  display:flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  min-width: 180px;
}

.prem-pnlcalc .pnl-l{
  font-size: 11px;
  font-weight: 900;
  letter-spacing: .10em;
  text-transform: uppercase;
  opacity: .75;
  white-space: nowrap;
}

.prem-pnlcalc .pnl-in,
.prem-pnlcalc .pnl-sel{
  flex: 1;
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.92);
  outline: none;
  font-weight: 900;
}

.prem-pnlcalc .pnl-in:focus,
.prem-pnlcalc .pnl-sel:focus{
  border-color: rgba(250,204,21,.55);
  box-shadow: 0 0 0 2px rgba(250,204,21,.18);
}

.prem-pnlcalc .pnl-grid{
  display:grid;
  grid-template-columns: 120px 1fr;
  gap: 8px 12px;
  align-items: center; /* era baseline */
}

.prem-pnlcalc .pnl-k{
  font-size: 11px;
  font-weight: 950;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .75;
}

.prem-pnlcalc .pnl-v{
  font-size: 44px; /* igual ao Most optimal entry */
  line-height: 1.05;
  font-weight: 950;
  text-align: right;
  white-space: nowrap;
}

.prem-pnlcalc .pnl-loss{ color: #fb7185; }

.prem-pnlcalc .pnl-muted{
  font-size: 22px;
  opacity: .65;
  font-weight: 850;
  margin-left: 6px;
}
.prem-pnlcalc .pnl-foot{
  margin-top: 10px;
  font-size: 11px;
}

/* PREMONIÇÃO: readout (REGIME/REVERSÃO/CONSOLIDAÇÃO/...) com hierarquia visual */
.prem-kpi-right #prem-readout{
  margin: 10px 0 12px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.prem-kpi-right #prem-readout .rr-row{
  display:flex;
  justify-content: space-between;
  align-items: baseline;
  gap: 14px;
}

.prem-kpi-right #prem-readout .rr-k{
  font-size: 14px;
  font-weight: 950;
  letter-spacing: .14em;
  text-transform: uppercase;
  color: #ffcc66;
  opacity: 1;
  white-space: nowrap;
}


.prem-kpi-right #prem-readout .rr-v{
  font-size: 16px;
  font-weight: 850;
  opacity: .95;
  text-align: right;
  overflow-wrap: anywhere;
  word-break: break-word;
}

.prem-kpi-right #prem-readout .rr-row.rr-primary .rr-k,
.prem-kpi-right #prem-readout .rr-row.rr-primary .rr-v{
  color: #ffcc66;
  font-weight: 950;
}

.prem-kpi-right #prem-readout .rr-v.rr-strong{
  font-size: 18px;
}
/* ===== EXEC (MICRO) MINI + PLAN 1x1 (ao lado do readout) ===== */
.prem-kpi-right #prem-readout{
  float: left;
  width: 52%;
}

#prem-exec-mini{
  float: right;
  width: 46%;
  margin: 10px 0 12px;
  padding: 10px 10px 12px;
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  background: rgba(0,0,0,.22);
}

.prem-kpi-right .prem-kpi-right-main,
.prem-kpi-right .prem-kpi-right-sub{
  clear: both;
}

#prem-exec-mini .x-title{
  font-size: 11px;
  font-weight: 900;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .80;
  margin-bottom: 8px;
}

#prem-exec-mini .x-row{
  font-size: 12px;
  line-height: 1.35;
  color: rgba(255,255,255,.92);
  margin-bottom: 6px;
}

#prem-exec-mini .x-row:last-child{ margin-bottom: 0; }

#prem-exec-mini .x-val{
  color: #ffcc66;
  font-weight: 950;
}

#prem-exec-mini .x-dim{ opacity: .55; }

@media (max-width: 980px){
  .prem-kpi-right #prem-readout,
  #prem-exec-mini{
    float: none;
    width: 100%;
  }
}
/* ===== /EXEC (MICRO) MINI + PLAN 1x1 ===== */

/* ===== PREM: TOPCARDS (Readout + Exec Micro lado a lado) ===== */
.prem-topcards{
  display:flex;
  gap:12px;
  align-items:stretch;
  flex-wrap:wrap; /* evita quebrar em telas menores */
}

.prem-topcards #prem-readout{
  margin: 0;             /* remove o margin antigo dentro do layout novo */
  flex: 0 0 260px;       /* largura fixa do quadro do "REGIME/REVERSÃO/..." */
}

.execm-side-card{
  flex: 1 1 360px;       /* cresce e quebra se precisar */
  min-width: 360px;
  padding: 10px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.22);
}

.execm-side-title{
  font-size: 10px;
  letter-spacing: .14em;
  text-transform: uppercase;
  opacity: .70;
  margin-bottom: 8px;
}

.execm-side-body{
  display:flex;
  flex-direction:column;
  gap:8px;
  font-size:16px;
  line-height:1.25;
}

.execm-side-body .ek{ font-weight:950; }
.execm-side-body .ev{ color:#ffcc66; font-weight:900; }
.execm-side-body .pipe{ opacity:.55; margin:0 6px; }
.execm-side-body .muted{ opacity:.55; font-size:14px; }

/* deixa o painel direito mais “TV-like” */
.premonition-panel .label{
  font-size: 10px;
  letter-spacing: .18em;
  opacity: .62;
}

.premonition-panel .value{
  font-size: 14px;
}

.premonition-panel .value b,
.premonition-panel .value strong{
  color:#ffcc66;
}

/* ====== FIM upgrade ====== */

/* ================== FIM PREMONIÇÃO ================== */

/* ====== PATTERN REFERENCE (ABAIXO DO SIZING BRAIN) ====== */
.ref-card { margin-top: 14px; }

.ref-details { margin-top: 8px; }

.ref-summary {
  list-style: none;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(56, 189, 248, 0.28);
  background: rgba(10, 18, 35, 0.55);
  cursor: pointer;
  user-select: none;
}

.ref-summary::-webkit-details-marker { display: none; }

.ref-summary-left {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.ref-summary-title {
  font-weight: 700;
  letter-spacing: 0.2px;
}

.ref-summary-mini {
  font-size: 12px;
  opacity: 0.75;
}

.ref-summary-right {
  font-size: 12px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(148, 163, 184, 0.22);
  background: rgba(2, 6, 23, 0.35);
  opacity: 0.9;
}

.ref-details[open] .ref-summary-right { content: "Fechar"; }

.ref-body { padding-top: 12px; }

.ref-grid {
  display: grid;
  grid-template-columns: 1.25fr 1fr;
  gap: 12px;
}

@media (max-width: 980px) {
  .ref-grid { grid-template-columns: 1fr; }
}

.ref-img-wrap {
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid rgba(148, 163, 184, 0.18);
  background: rgba(2, 6, 23, 0.55);
}

.ref-img-wrap img {
  width: 100%;
  height: auto;
  display: block;
}

.ref-text {
  border-radius: 16px;
  border: 1px solid rgba(148, 163, 184, 0.14);
  background: rgba(2, 6, 23, 0.35);
  padding: 12px;
}

.ref-line { margin-bottom: 10px; }

.ref-link {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  margin-top: 6px;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(56, 189, 248, 0.25);
  text-decoration: none;
}
/* ====== /PATTERN REFERENCE ====== */
/* =========================
   TRADE CARD • RESPONDER OUTPUT (panel/ui/digest)
   ========================= */
.resp-snap{
  margin-top: 10px;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid rgba(80,120,200,.35);
  background: rgba(15,20,40,.55);
  box-shadow: 0 10px 28px rgba(0,0,0,.28);
}

.resp-snap-title{
  font-size: 11px;
  letter-spacing: .22em;
  opacity: .8;
  margin-bottom: 8px;
}

/* KPI row */
.resp-kpis{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid rgba(120,170,255,.18);
  background: rgba(10,14,28,.55);
  margin-bottom: 10px;
}

.resp-kpi{
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(120,170,255,.12);
  background: rgba(8,10,22,.55);
}

.resp-kpi-label{
  font-size: 10px;
  letter-spacing: .16em;
  text-transform: uppercase;
  opacity: .75;
  margin-bottom: 4px;
}

.resp-kpi-value{
  font-size: 12px;
  font-weight: 800;
  letter-spacing: .02em;
}

/* 3 col output */
.resp-snap-grid{
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}

.resp-snap-col{
  border-radius: 12px;
  border: 1px solid rgba(120,170,255,.12);
  background: rgba(8,10,22,.45);
  overflow: hidden;
}

.resp-snap-head{
  padding: 8px 10px;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: .08em;
  text-transform: uppercase;
  background: rgba(255,255,255,.03);
  border-bottom: 1px solid rgba(120,170,255,.12);
}

/* === OVERRIDE: UI + DIGEST sem rolagem (cresce a altura do card) === */
#resp-snap-ui,
#resp-snap-digest{
  max-height: none;
  overflow: visible;
}

.resp-snap-row{
  display: grid;
  grid-template-columns: 1fr 1.25fr;
  gap: 10px;
  padding: 6px 8px; /* <-- antes era 6px 0 (sem espaço nas laterais) */
  border-bottom: 1px dashed rgba(255,255,255,.07);
}

.resp-snap-row:last-child{ border-bottom: none; }

.resp-snap-key{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 11px;
  line-height: 1.35; /* <-- respiro entre linhas */
  opacity: .85;
}

.resp-snap-val{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 11px;
  line-height: 1.35; /* <-- respiro entre linhas */
  text-align: right;
  opacity: .95;
  word-break: break-word;
}

.resp-snap-null{ opacity: .55; font-style: italic; }

.resp-snap-strong .resp-snap-key{ opacity: 1; font-weight: 800; }
.resp-snap-strong .resp-snap-val{ opacity: 1; font-weight: 700; }

.resp-bool{
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  font-size: 11px;
}
.resp-bool-true{ background: rgba(60,190,120,.16); }
.resp-bool-false{ background: rgba(220,80,90,.14); }

/* flash quando muda */
.resp-snap-flash{
  animation: respSnapFlash .55s ease-out;
}
@keyframes respSnapFlash{
  from { background: rgba(80,160,255,.18); }
  to   { background: transparent; }
}

@media (max-width: 980px){
  .resp-kpis{ grid-template-columns: repeat(2,1fr); }
  .resp-snap-grid{ grid-template-columns: 1fr; }
  .resp-snap-row{ grid-template-columns: 1fr; }
  .resp-snap-val{ text-align: left; }
}


/* ===== SL FLEX (Respiro Profundo) — bloco inferior (retângulo amarelo) ===== */
#slflex-card{ grid-column: 1 / -1; margin-top: 12px; }

#slflex-card .slflex-grid{
  display:grid;
  grid-template-columns: repeat(5, minmax(0,1fr));
  gap:10px;
}

@media (max-width: 980px){
  #slflex-card .slflex-grid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
}

#slflex-prob-respiro{ color: rgba(52,211,153,.95); }
#slflex-prob-reversao{ color: rgba(251,113,133,.95); }

#slflex-card .slflex-bar-wrap{ margin-top: 10px; }

#slflex-card .slflex-bar{
  position: relative;
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  overflow: hidden;
}

#slflex-card .slflex-fill{
  height: 100%;
  width: 0%;
  background: rgba(250,204,21,.70);
}

#slflex-card .slflex-marker{
  position:absolute;
  top:-5px;
  width:12px;
  height:22px;
  border-radius:8px;
  background: rgba(96,165,250,.95);
  box-shadow: 0 0 0 2px rgba(0,0,0,.35);
  left: 0%;
}

#slflex-card .slflex-marker.p50{ background: rgba(52,211,153,.95); }
#slflex-card .slflex-marker.p75{ background: rgba(251,113,133,.90); }

#slflex-card .slflex-labels{
  margin-top: 6px;
  display:flex;
  justify-content: space-between;
  font-size: 10px;
  opacity: .60;
}

#slflex-card .slflex-advice{
  margin-top: 10px;
  font-size: 13px;
  opacity: .82;
}

  </style>
</head>

<body>
    <div class="page">
    <!-- ====== TOPO ====== -->
    <header class="top-bar">
      <div class="top-left">

        <!-- Logo The Six Seats Investments -->
        <div class="brand-logo">
          <img
            src="six-seats-logo.png"
            alt="The Six Seats Investments"
            class="brand-logo-img"
          />
          <div class="brand-logo-text">
            <div class="brand-logo-main">THE SIX SEATS</div>
            <div class="brand-logo-sub">INVESTMENTS</div>
          </div>
        </div>

        <!-- Título do painel AARON 9 -->
        <div class="brand-title">
          <span>AARON 9</span>&nbsp;INSTITUTIONAL PANEL
        </div>


    <div class="status-dot-live" data-i18n="top.live_feed">
      LIVE FEED
    </div>

    <div class="pill-small">
      <span data-i18n="top.symbol">Símbolo</span>
      <strong id="symbol-label">—</strong>
    </div>

    <div class="pill-small">
      <span data-i18n="top.timeframe">Timeframe</span>
      <strong id="timeframe-label">—</strong>
    </div>
<div class="tf-picker" id="tf-picker" title="Timeframe">
  <button class="tf-btn" type="button" data-tf="1m">1m</button>
  <button class="tf-btn" type="button" data-tf="5m">5m</button>
  <button class="tf-btn" type="button" data-tf="15m">15m</button>
  <button class="tf-btn" type="button" data-tf="1h">1h</button>
  <button class="tf-btn" type="button" data-tf="4h">4h</button>
  <button class="tf-btn" type="button" data-tf="1d">1D</button>
</div>

    <div class="pill-small">
      <span data-i18n="top.session">Sessão</span>
      <strong id="session-label">—</strong>
    </div>
  </div>

  <div class="top-right">
    <!-- TOGGLE PT / EN -->
    <div id="lang-toggle" class="lang-toggle">
      <button type="button" class="lang-btn active" data-lang="pt">PT</button>
      <button type="button" class="lang-btn" data-lang="en">EN</button>
    </div>

    <div class="pill-state" id="state-pill">
      AGUARDANDO
    </div>

    <div class="kv">
  <div class="k">RESPIRO</div>
  <div class="v" id="top_respiro_value">—</div>
</div>

<div class="kv">
  <div class="k">AÇÃO</div>
  <div class="v" id="top_action_value">—</div>
</div>


    <div class="pill-soft">
      <span data-i18n="top.last_update">Última atualização:</span>
      <strong id="last-update-label">—</strong>
    </div>

    <button class="btn-refresh" id="btn-refresh" data-i18n="top.refresh">
      ATUALIZAR
    </button>
  </div>
</header>

    <!-- ================== GARIMPO DE HOJE / BEST STOCK TO TRADE ================== -->
<section id="garimpo-today" class="garimpo-banner">
  <div class="garimpo-container">
    <div class="garimpo-badge" data-i18n="garimpo_badge">
      Garimpo de Hoje
    </div>

        <div class="garimpo-main">
      <div class="garimpo-header-row">
        <div class="garimpo-title-block">
          <span class="garimpo-label" data-i18n="garimpo_best_label">
            Melhor ativo para hoje
          </span>
          <div class="garimpo-ticker-line">
            <span id="garimpo-ticker" class="garimpo-ticker">NVDA</span>
            <span id="garimpo-profile" class="garimpo-profile-tag">
              Day Trade Momentum
            </span>
          </div>
        </div>

        <div class="garimpo-header-right">
          <!-- BOTÃO PARA IR AO GARIMPO -->
          <a
            href="garimpo.html"
            class="garimpo-link-btn"
            data-i18n="garimpo_view_page"
          >
            Ver página do garimpo
          </a>

          <!-- CHIP DE CONFIANÇA DO CÉREBRO -->
          <div class="garimpo-confidence-chip">
            <span class="chip-label" data-i18n="garimpo_metric_confidence">
              Confiança do cérebro
            </span>
            <span id="garimpo-confidence" class="chip-value">91%</span>
          </div>
        </div>
      </div>




      <div class="garimpo-metrics-row">
        <div class="garimpo-metric">
          <div class="metric-label" data-i18n="garimpo_metric_gap">Gap</div>
          <div id="garimpo-gap" class="metric-value">+2.3%</div>
        </div>
        <div class="garimpo-metric">
          <div class="metric-label" data-i18n="garimpo_metric_premarket">
            Pré-market vs média
          </div>
          <div id="garimpo-premarket" class="metric-value">1.8×</div>
        </div>
        <div class="garimpo-metric">
          <div class="metric-label" data-i18n="garimpo_metric_atr">
            ATR% (volatilidade)
          </div>
          <div id="garimpo-atr" class="metric-value">2.1%</div>
        </div>
      </div>

      <p class="garimpo-comment" data-i18n="garimpo_comment">
        Hoje este é o ativo com melhor combinação de fluxo, liquidez e
        volatilidade para o seu perfil.
      </p>
    </div>
  </div>
</section>
<!-- ================== FIM GARIMPO DE HOJE ================== -->
 <!-- ================== COMENTÁRIO DO AARON (DIREÇÃO + PADRÃO) ================== -->
<section id="aaron-commentary-section" class="premonition-banner">
  <div class="premonition-container aaron-commentary-container">
    <div class="premonition-head">
      <div>
        <div class="premonition-title">COMENTÁRIO DO AARON</div>
        <div class="premonition-sub">Direção do dia + padrão dominante</div>
      </div>

      <div class="aaron-commentary-badges">
        <div class="premonition-badge aaron-badge is-neutral" id="aaron-day-badge">DIA: —</div>
        <div class="premonition-badge aaron-badge aaron-badge-pattern" id="aaron-pattern-badge">PADRÃO: —</div>
      </div>
    </div>

    <div class="aaron-commentary-text">
      <strong>Comentário do AARON:</strong>
      <span id="aaron-commentary-body">—</span>
    </div>
  </div>
</section>
<!-- ================== FIM COMENTÁRIO DO AARON ================== -->

<section id="premonition-section" class="premonition-banner">
  <div class="premonition-container">
    <div class="premonition-head">
      <div>
        <div class="premonition-title" id="prem-title">PREMONIÇÃO</div>
        <div class="premonition-sub" id="prem-sub">Breakout Window (heurístico)</div>
        <div class="prem-kpi-right-current prem-head-current">
  <span class="prem-kpi-right-time">Current Price:</span>
  <span class="prem-kpi-right-time prem-kpi-right-current-price" id="prem-head-current-price">—</span>
</div>

      </div>
      <div class="inst-window" id="inst-window">
  <span class="inst-tag" id="inst-tag">—</span>
  <span class="inst-range" id="inst-range">—</span>
  <span class="inst-msg" id="inst-msg">—</span>
</div>
      <div class="premonition-badge" id="prem-badge">—</div>
    </div>

    <div class="premonition-grid">
      <div class="premonition-chart">
       

                                <!-- ===== MICRO TIMELINE + MICRO MAP (NOW) ===== -->
                <div class="microtime-split">

                  <div class="microtime-panel" id="microtime-panel">
                    <div class="microtime-row">
                      <div class="microtime-title">FUTURE (NEXT)</div>
                      <div class="microtime-value" id="mt-future-next">—</div>
                    </div>
                    <div class="microtime-row">
                      <div class="microtime-title">MICRO LIVE — MAX</div>
                      <div class="microtime-value" id="mt-micro-max">—</div>
                    </div>
                    <div class="microtime-row">
                      <div class="microtime-title">MICRO LIVE — NOW</div>
                      <div class="microtime-value" id="mt-micro-now">—</div>
                    </div>
                    <div class="microtime-row">
                      <div class="microtime-title">CURRENT</div>
                      <div class="microtime-value" id="mt-current">—</div>
                    </div>
                    <div class="microtime-row">
                      <div class="microtime-title">PAST</div>
                      <div class="microtime-value" id="mt-past">—</div>
                    </div>
                  </div>
    <div id="rrv-respiro-meta" style="margin-top:4px; text-align:right; font-size:11px; font-weight:900; color:#facc15; opacity:.95;">—</div>

                                    <div class="micro-right-split" id="micro-right-split">

                    <div class="micro-map-card" id="micro-map-card">
                      <div class="micro-map-title">MICRO MAP (NOW)</div>
                      <div class="micro-map-line" id="mm-micro-line">MICRO LIVE — NOW: —</div>
                      <div class="micro-map-line" id="mm-respiro-line">RESPIRO (max / p75): —</div>
                      <div class="micro-map-line" id="mm-reversao-line">REVERSÃO (gatilho): —</div>
                      <div class="micro-map-foot">Base: Micro Live + Respiro (p75 ATR) + Gatilho (SL 1x1 auto)</div>
                    </div>

                    <div class="windows-card" id="windows-card">
                      <div class="windows-title">WINDOWS</div>

                      <div class="windows-line">
                        Status:
                        <span id="win-status" class="win-badge win-wait">WAIT</span>
                      </div>

                      <div class="windows-line" id="win-predicted">
                        Window prevista: —
                      </div>

                      <div class="windows-line" id="win-confidence">
                        Confiança: —
                      </div>

                      <div class="windows-line" id="win-rule">
                        Regra: close abaixo do candle anterior + confirmação no próximo
                      </div>

                      <div class="windows-foot">
                        Fonte: candles Alpaca + heurística de estrutura/wicks.
                      </div>
                    </div>

                  </div>


                </div>
                <!-- ===== /MICRO TIMELINE + MICRO MAP (NOW) ===== -->

        <!-- ===== /MICRO TIMELINE ===== -->

                <div class="prem-signal-wrap" id="prem-signal-wrap">
          <button class="prem-signal-btn prem-signal-off" id="prem-signal-btn" type="button" disabled>
            NÃO FAÇA NADA
          </button>
          <div class="prem-signal-hint" id="prem-signal-hint">
            Filtro: AÇÃO=— • Micro=— (≥75%)
          </div>
        </div>
        <!-- ===== ENTRY ENGINE (AARON) — acima do EE BRAIN ===== -->
<div class="prem-breakout-wrap" id="ee-engine-card" style="margin-top:10px;">
  <div class="prem-breakout-title">ENTRY ENGINE · (Touch → Confirm → Cancel)</div>

  <div class="ee-engine-top">
    <div class="ee-engine-left">
      <div class="ee-engine-pill loading" id="ee-engine-pill">LOADING</div>

      <div class="ee-engine-meta">
        <span class="ee-engine-dir" id="ee-engine-dir">—</span>
        <span class="ee-engine-prob" id="ee-engine-prob">—</span>
      </div>

      <div class="ee-engine-mode" id="ee-engine-mode">—</div>
      <div class="ee-engine-rule" id="ee-engine-rule">—</div>
    </div>

    <div class="ee-engine-right">
      <div class="ee-engine-box big">
        <div class="k">TOUCH</div>
        <div class="v" id="ee-engine-touch">—</div>
      </div>

      <div class="ee-engine-stack">
        <div class="ee-engine-box stack">
          <div class="k">CONFIRM CLOSE</div>
          <div class="v" id="ee-engine-confirm">—</div>
        </div>

        <div class="ee-engine-box stack">
          <div class="k">CANCEL CLOSE</div>
          <div class="v" id="ee-engine-cancel">—</div>
        </div>
      </div>
    </div>
  </div>

  <div class="ee-engine-note" id="ee-engine-note">—</div>
</div>
<!-- ===== /ENTRY ENGINE ===== -->
                <!-- ===== EE BRAIN (Entry Brain) — abaixo do botão "NÃO FAÇA NADA" ===== -->
  <div class="prem-breakout-wrap" id="ee-brain-card" style="margin-top:12px;">
    <div class="prem-breakout-title">EE BRAIN · ENTRY (Micro Live)</div>

    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <div class="ee-badge wait" id="ee-status-badge">WAIT</div>

      <div class="ee-hdr">
        Target:
        <span id="ee-target" style="color:var(--success); font-weight:950;">—</span>
        <span style="opacity:.55;">·</span>
        <span id="ee-target-pct" style="color:var(--success); font-weight:950;">—</span>
        <span style="opacity:.55;">·</span>
        <span id="ee-target-eta" style="color:#facc15; font-weight:950;">—</span>
      </div>
    </div>

    <div style="display:flex; flex-direction:column; gap:10px; margin-top:4px;">
      <div>
        <div class="ee-k">Plano primário</div>
        <div class="ee-line">
          <span id="ee-plan" class="ee-strong">—</span>
          <span style="opacity:.55;"> @ </span>
          <span id="ee-entry" style="color:#60a5fa; font-weight:950;">—</span>
          <span style="opacity:.55;"> · Conf </span>
          <span id="ee-conf" style="color:#facc15; font-weight:950;">—</span>
        </div>
      </div>

      <div>
        <div class="ee-k">Zonas Pullback (ATR)</div>
        <div class="ee-line">
          P25 <span id="ee-pb25" class="ee-strong">—</span>
          <span style="opacity:.55;"> · </span>
          P50 <span id="ee-pb50" class="ee-strong">—</span>
          <span style="opacity:.55;"> · </span>
          P75 <span id="ee-pb75" class="ee-strong">—</span>
        </div>
      </div>

      <div>
        <div class="ee-k">Gatilho / Confirmação</div>
        <div class="ee-line" id="ee-trigger">—</div>
      </div>

      <div>
        <div class="ee-k">Cancelamento</div>
        <div class="ee-line" id="ee-cancel">—</div>
      </div>
    </div>

    <div class="prem-breakout-note" id="ee-foot">—</div>
  </div>
  <!-- ===== /EE BRAIN ===== -->
                <<!-- ===== STOP RISK (1x1) — substitui EXEC GATE / MINI / BREAKOUT ===== -->
<div class="prem-breakout-wrap" id="stop-risk-card" style="margin-top:10px;">
  <!-- ===== SL FLEX DOCK (mover card pra área grande de baixo) ===== -->
<div id="slflex-dock" style="margin-top:12px;"></div>
<!-- ===== /SL FLEX DOCK ===== -->

  <div class="prem-breakout-title">STOP RISK (1x1)</div>

  <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <div style="flex:1 1 auto;">
      <div style="font-size:12px; opacity:.75; letter-spacing:.08em; text-transform:uppercase;">
        Chance de bater SL antes do micro
      </div>

      <div style="display:flex; align-items:baseline; gap:10px; margin-top:4px;">
        <div id="sr-stop-first-pct" style="font-size:26px; font-weight:950; color:#facc15;">—</div>
        <div id="sr-risk-badge" style="font-size:12px; font-weight:900; opacity:.85;">Stop Risk: —</div>
      </div>

      <div style="height:10px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden; margin-top:8px;">
        <div id="sr-meter-fill" style="height:100%; width:0%; background:rgba(250,204,21,.85);"></div>
      </div>
    </div>
  </div>

  <div style="margin-top:10px; font-size:12px; line-height:1.5; color:rgba(255,255,255,.92);">
    <div style="margin-bottom:6px;"><span style="opacity:.85;">🧠</span> <span id="sr-market-msg">—</span></div>
    <div style="margin-bottom:6px;"><span style="opacity:.85;">✅</span> Melhor: esperar <span style="font-weight:900;">Optimal Entry</span></div>
    <div style="margin-bottom:6px;"><span style="opacity:.85;">🟡</span> Se entrar mesmo assim: <span style="font-weight:900;">Respiro ON</span> (+<span id="sr-respiro-atr" style="font-weight:900;">—</span> ATR)</div>
    <div style="margin-bottom:6px;"><span style="opacity:.85;">🔁</span> Se tomar SL: reentrada típica em <span id="sr-stop-reentry-eta" style="font-weight:900; color:#facc15;">—</span>, chance stop→target <span id="sr-stop-target-pct" style="font-weight:900; color:#facc15;">—</span></div>
    <div style="margin-bottom:6px;"><span style="opacity:.85;">🎯</span> Se bater SL, chance de depois ir pro micro: <span id="sr-after-stop-micro-pct" style="font-weight:900; color:#facc15;">—</span></div>
    <div><span style="opacity:.85;">⏱️</span> Tempo típico depois do SL até micro: <span id="sr-stop-to-micro-eta" style="font-weight:900; color:#facc15;">—</span></div>
  </div>
</div>
<!-- ===== /STOP RISK ===== -->
<!-- ===== RESPIRO x REVERSÃO (MICRO) — bloco do retângulo amarelo ===== -->
<div class="prem-breakout-wrap" id="rrv-card" style="margin-top:12px;">
  <div class="prem-breakout-title">RESPIRO × REVERSÃO (MICRO)</div>

  <div style="display:flex; flex-direction:column; gap:10px;">
    <!-- RESPIRO -->
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <div style="font-size:12px; font-weight:900; letter-spacing:.08em; text-transform:uppercase; color:#34d399;">RESPIRO</div>
      <div id="rrv-respiro-pct" style="font-size:18px; font-weight:950; color:#34d399;">—</div>
    </div>
    <div style="height:10px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden;">
      <div id="rrv-respiro-fill" style="height:100%; width:0%; background:rgba(52,211,153,.85);"></div>
    </div>

    <!-- REVERSÃO -->
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-top:6px;">
      <div style="display:flex; align-items:center; gap:8px;">
  <div style="font-size:12px; font-weight:900; letter-spacing:.08em; text-transform:uppercase; color:#fb7185;">REVERSÃO</div>
  <span id="rrv-reversao-dir" style="font-size:11px; font-weight:950; letter-spacing:.06em; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:rgba(255,255,255,.75);">—</span>
</div>

      <div id="rrv-reversao-pct" style="font-size:18px; font-weight:950; color:#fb7185;">—</div>
    </div>
    <div style="height:10px; border-radius:999px; background:rgba(255,255,255,.08); overflow:hidden;">
      <div id="rrv-reversao-fill" style="height:100%; width:0%; background:rgba(251,113,133,.85);"></div>
    </div>
    <div id="rrv-reversao-meta" style="margin-top:4px; text-align:right; font-size:11px; font-weight:900; color:rgba(255,255,255,.72);">—</div>

    <!-- leitura -->
    <div style="margin-top:8px; font-size:12px; line-height:1.5; color:rgba(255,255,255,.92);">
      <div><span style="opacity:.85;">📌</span> Dominante: <span id="rrv-dominant" style="font-weight:950;">—</span></div>
      <div style="margin-top:4px;"><span style="opacity:.85;">🧠</span> Leitura: <span id="rrv-reading">—</span></div>
    </div>
  </div>
</div>
<!-- ===== /RESPIRO x REVERSÃO (MICRO) ===== -->


      </div>

      <div class="premonition-panel">
        <!-- KPI grande (estilo mockup) -->
<div class="prem-kpi-right">
  <div class="prem-kpi-right-title" id="prem-right-title">Prob.</div>
                <div class="prem-topcards">
          <div class="rr-readout" id="prem-readout">
            <div class="rr-row"><div class="rr-k">REGIME</div><div class="rr-v" id="prem-regime">—</div></div>
            <div class="rr-row rr-primary"><div class="rr-k">REVERSÃO</div><div class="rr-v" id="prem-reversao-full">—</div></div>
            <div class="rr-row rr-primary"><div class="rr-k">RESPIRO</div><div class="rr-v" id="prem-respiro-full">—</div></div>
            <div class="rr-row"><div class="rr-k">CONSOLIDAÇÃO</div><div class="rr-v" id="prem-consolidacao">—</div></div>
            <div class="rr-row rr-primary"><div class="rr-k">CONTINUAÇÃO</div><div class="rr-v" id="prem-continuacao">—</div></div>
            <div class="rr-row rr-primary"><div class="rr-k">AÇÃO</div><div class="rr-v rr-strong" id="prem-acao-full">—</div></div>
          </div>

                    <!-- ===== NOVO QUADRO AO LADO (MICRO PATH LIVE) ===== -->
          <div class="execm-side-card" id="execm-side-card">
            <div class="execm-side-title">MICRO PATH (LIVE)</div>
            <div class="execm-side-body">

              <div class="execm-line">
                <span class="ek">Current:</span>
                <span id="mpl-current" class="ev">—</span>
                <span class="pipe">|</span>
                <span class="ek">ATR14:</span>
                <span id="mpl-atr14" class="ev">—</span>
              </div>

              <div class="execm-line">
                <span class="ek">Path A:</span>
                <span id="mpl-a1-pct" class="ev" style="color:var(--success); font-weight:900;">—</span>
                <span class="ek"> tocar</span>
                <span id="mpl-a1-price" class="ev" style="color:var(--success); font-weight:900;">—</span>
                <span class="muted"> (<span id="mpl-a1-eta" class="ev">—</span>)</span>
              </div>

              <div class="execm-line" style="padding-left:14px;">
                <span class="pipe">→</span>
                <span class="ek">depois:</span>
                <span id="mpl-a2-pct" class="ev" style="color:#facc15; font-weight:900;">—</span>
                <span class="ek"> estender</span>
                <span id="mpl-a2-price" class="ev" style="color:#facc15; font-weight:900;">—</span>
                <span class="muted"> (<span id="mpl-a2-eta" class="ev">—</span>)</span>
              </div>

              <div class="execm-line">
                <span class="ek">Path B:</span>
                <span id="mpl-b-pct" class="ev" style="color:var(--danger); font-weight:900;">—</span>
                <span class="ek"> falhar antes</span>
                <span class="pipe">→</span>
                <span id="mpl-b-price" class="ev" style="color:var(--danger); font-weight:900;">—</span>
                <span class="muted"> (<span id="mpl-b-eta" class="ev">—</span>)</span>
                <span class="muted"> (rejeição/flush)</span>
              </div>

            </div>
          </div>

        </div>




  <div class="prem-kpi-right-main">
        <div class="prem-kpi-right-current">
    <span class="prem-kpi-right-time prem-kpi-right-current-label">Current Price:</span>
    <span class="prem-kpi-right-time prem-kpi-right-current-price" id="prem-right-current-price">—</span>
  </div>

    <span class="prem-kpi-right-time" id="prem-right-time">--:--</span>
    <span class="prem-kpi-right-ampm" id="prem-right-ampm"></span>
    <span class="prem-kpi-right-prob" id="prem-right-prob">--%</span>
  </div>

  <div class="prem-kpi-right-sub" id="prem-right-eta">—</div>
</div>
  <!-- ===== QUICK P&L (simulação) — NÃO mexe no Premonition Micro Live ===== -->
  <div class="prem-pnlcalc" id="prem-pnlcalc">
    <div class="pnl-h">QUICK P&L (simulação)</div>

    <div class="pnl-controls">
      <div class="pnl-field">
        <span class="pnl-l">Montante</span>
        <input id="pnl-capital" class="pnl-in" type="number" inputmode="decimal" step="1000" value="100000" />
      </div>

      <div class="pnl-field">
        <span class="pnl-l">Entrada</span>
        <select id="pnl-entrymode" class="pnl-sel">
          <option value="now">NOW (Current)</option>
          <option value="opt">Most optimal entry</option>
        </select>
      </div>
    </div>

    <div class="pnl-grid">
      <div class="pnl-k">ΔTP/share</div>
      <div class="pnl-v">
        <span id="pnl-delta">—</span>
        <span class="pnl-muted" id="pnl-delta-cents"></span>
      </div>

      <div class="pnl-k">Qtd</div>
      <div class="pnl-v">
        <span id="pnl-shares">—</span> <span class="pnl-muted">shares</span>
      </div>

      <div class="pnl-k">P/L no TP</div>
      <div class="pnl-v" id="pnl-profit">—</div>

      <div class="pnl-k">P/L no SL</div>
      <div class="pnl-v pnl-loss" id="pnl-loss">—</div>
    </div>

    <div class="pnl-foot pnl-muted" id="pnl-foot">—</div>
  </div>
  <!-- ===== /QUICK P&L ===== -->

        <div class="row">
          <div class="label">Janela estimada</div>
          <div class="value" id="prem-window">—</div>
        </div>

        <div class="row">
          <div class="label">Tempo típico</div>
          <div class="value" id="prem-median">—</div>
        </div>

        <div class="row">
          <div class="label">Se não romper...</div>
          <div class="value muted" id="prem-miss">—</div>
        </div>

        <div class="row">
          <div class="label">Premonição Macro</div>
          <div class="value" id="prem-macro">—</div>
        </div>

        <div class="row">
          <div class="label">Premonição Micro</div>
          <div class="value" id="prem-micro">—</div>
        </div>

        <div class="row">
          <div class="label">Base</div>
          <div class="value muted" id="prem-base">—</div>
        </div>
                <!-- ===== EXEC (MICRO) - bloco do retângulo amarelo ===== -->
                 <div class="prem-exec-grid" id="prem-exec-grid"></div>
        <div id="prem-exec-micro" style="padding-top:12px; margin-top:12px; border-top:1px solid rgba(255,255,255,.06);">
                              <div style="font-size:11px; letter-spacing:.14em; text-transform:uppercase; opacity:.80; margin-bottom:10px;">
            PLANO “SE BATER STOP” (REENTRADA)
          </div>

                    <div style="display:flex; flex-direction:column; gap:10px; font-size:44px; line-height:1.25;">
            <div>
  <span style="font-weight:950;">Most optimal entry:</span>
  <span id="slr-optentry" style="color:#60a5fa; font-weight:900;">—</span>

  <span style="opacity:.65; font-size:22px; margin-left:10px;">
    @ <span id="slr-entrytime" style="color:#facc15; font-weight:900;">—</span>
    <span style="opacity:.55;">(MT)</span>
  </span>
</div>


            <div>
              <span style="font-weight:950;">SL 1x1:</span>
              <span id="slr-sl" class="pulse-sl" style="color:var(--danger); font-weight:900;">—</span>
              <span style="opacity:.55;"> | </span>
              <span style="font-weight:950;">Status:</span>
              <span id="slr-status" style="font-weight:950;">—</span>
            </div>


            <div id="slr-rule" style="font-size:20px; line-height:1.45; opacity:.78;">—</div>

            <div style="font-size:24px; line-height:1.5;">
              <div><span style="font-weight:950;">Quando SL atingir:</span></div>

              <div>
                <span style="font-weight:950;">Esperar:</span>
                <span id="slr-wait" style="color:#facc15; font-weight:900;">—</span>
                <span style="opacity:.55;"> (t_stop_to_reentry_med)</span>
                      <!-- ===== SL FLEX (Respiro Profundo) — bloco do retângulo amarelo inferior ===== -->
      <div class="prem-breakout-wrap" id="slflex-card" style="margin-top:12px; grid-column: 1 / -1;">
        <div class="prem-breakout-title">SL FLEX · Respiro Profundo (ATR)</div>
<!-- PB Candle (do Digest) – mini status visível -->
<div class="slflex-pbmini">
  <span class="slflex-pb-label">PB Candle</span>
  <span id="slflex-pb-candle" class="pullback-tag side-neutral">—</span>
  <span id="slflex-pb-ago"></span>
</div>

        <div class="slflex-grid">
          <div>
            <div class="pb-k">Prob Respiro</div>
            <div class="pb-v" id="slflex-prob-respiro">—</div>
          </div>

          <div>
            <div class="pb-k">Prob Reversão</div>
            <div class="pb-v" id="slflex-prob-reversao">—</div>
          </div>

          <div>
            <div class="pb-k">Depth P25 (ATR)</div>
            <div class="pb-v" id="slflex-depth-p25">—</div>
          </div>

          <div>
            <div class="pb-k">Depth P50 (ATR)</div>
            <div class="pb-v" id="slflex-depth-p50">—</div>
          </div>

          <div>
            <div class="pb-k">Depth P75 (ATR)</div>
            <div class="pb-v" id="slflex-depth-p75">—</div>
          </div>
        </div>

        <div class="slflex-bar-wrap">
          <div class="slflex-bar">
            <div class="slflex-fill" id="slflex-fill"></div>
            <div class="slflex-marker stop" id="slflex-mark-stop" title="SL atual"></div>
            <div class="slflex-marker p50" id="slflex-mark-p50" title="P50 respiro"></div>
            <div class="slflex-marker p75" id="slflex-mark-p75" title="P75 respiro"></div>
          </div>

          <div class="slflex-labels">
            <span>0 ATR</span><span>1.0</span><span>2.0</span><span>2.5</span>
          </div>
        </div>

        <div class="slflex-advice" id="slflex-advice">Leitura: —</div>

        <div class="prem-breakout-note" style="margin-top:2px;">
          SL atual (ATR): <b id="slflex-stop-atr">—</b> · SL sugerido: <b id="slflex-suggest-mult">—</b> (<span id="slflex-suggest-atr">—</span> ATR)
        </div>
      </div>
      <!-- ===== /SL FLEX ===== -->

              </div>

              <div>
                <span style="font-weight:950;">Reentrada:</span>
                <span id="slr-reentry" style="color:#facc15; font-weight:900;">—</span>
                <span id="slr-reentry-note" style="opacity:.55;"></span>
              </div>

              <div>
                <span style="font-weight:950;">TP travado:</span>
                <span id="slr-tp" style="color:#facc15; font-weight:900;">—</span>
              </div>

              <div>
                <span style="font-weight:950;">SL 1x1 reentrada:</span>
                <span id="slr-resl" style="color:#facc15; font-weight:900;">—</span>
              </div>

              <div>
                <span style="font-weight:950;">Chance stop→target:</span>
                <span id="slr-chance" style="color:#facc15; font-weight:900;">—</span>
              </div>
            </div>

          </div>

        </div>

        <!-- ===== /EXEC (MICRO) ===== -->

      </div>
        

</div> <!-- fecha prem-exec-grid -->
    </div>
  </div>
</section>

  <!-- ================== RESPIRO & REVERSÃO (abaixo da Premonição) ================== -->
<section class="premonition-banner" id="rr-section">
  <div class="premonition-container" id="rr-container">
    <div class="premonition-head">
      <div class="premonition-title">RESPIRO &amp; REVERSÃO</div>
      <div class="premonition-sub">Leitura de microestrutura (respiro → reversão)</div>
    </div>

    <div class="rr-grid">
      <div class="rr-left">
        <div class="rr-label">Respiro</div>
        <div class="rr-value" id="rr-respiro">—</div>
      </div>

      <div class="rr-right">
        <div class="rr-label">Reversão</div>
        <div class="rr-value" id="rr-reversao">—</div>
        <div class="rr-sub" id="rr-reversao-sub">—</div>
      </div>
    </div>

    <div class="rr-badge" id="rr-badge">AÇÃO: —</div>

    <div class="rr-readout" id="rr-readout">
      <div class="rr-line">
        <span class="rr-k">REGIME:</span> <span class="rr-v" id="rr-regime">—</span>
        <span class="rr-pipe">|</span>
        <span class="rr-k">REVERSÃO:</span> <span class="rr-v" id="rr-reversao-full">—</span>
        <span class="rr-pipe">|</span>
        <span class="rr-k">RESPIRO:</span> <span class="rr-v" id="rr-respiro-full">—</span>
      </div>

      <div class="rr-line">
        <span class="rr-k">CONSOLIDAÇÃO:</span> <span class="rr-v" id="rr-consolidacao">—</span>
        <span class="rr-pipe">|</span>
        <span class="rr-k">CONTINUAÇÃO:</span> <span class="rr-v" id="rr-continuacao">—</span>
        <span class="rr-pipe">|</span>
        <span class="rr-k">AÇÃO:</span> <span class="rr-v" id="rr-acao">—</span>
      </div>
    </div>
  </div>
</section>

<!-- ================== FIM RESPIRO & REVERSÃO ================== -->



    <div id="error-banner" class="error-banner">
      <strong>Erro ao carregar painel.</strong> Verifique o n8n / webhook e tente novamente.
    </div>

    <!-- ====== LAYOUT PRINCIPAL ====== -->
    <main class="layout">
      <!-- ====== COLUNA ESQUERDA: TV + PADRÕES ====== -->
      <section class="column">
           <!-- ====== GERENCIADOR DE RISCO · ATR ====== -->
<section class="risk-card" id="atr-risk-panel">
  <div class="risk-header">
    <div>
      <div class="risk-title" data-i18n="risk.title">
        Gerenciador de risco · ATR
      </div>
      <div class="risk-subtitle" data-i18n="risk.subtitle">
        Ajuste os parâmetros do ATR e calcule risco / reward da operação.
      </div>
    </div>

    <button
      type="button"
      class="risk-toggle"
      id="atr-risk-toggle"
      data-i18n="risk.toggle_open"
    >
      Abrir
    </button>
  </div>



  <div class="risk-body" id="atr-risk-body" style="display:none;">
    <div class="risk-group">
      <div class="risk-label">Length</div>
      <input id="atr-length-input" type="number" value="14" min="1" />
    </div>

    <div class="risk-group">
      <div class="risk-label">Smoothing</div>
      <select id="atr-smoothing-input">
        <option value="RMA" selected>RMA</option>
        <option value="SMA">SMA</option>
        <option value="EMA">EMA</option>
        <option value="WMA">WMA</option>
      </select>
    </div>

    <div class="risk-group">
      <div class="risk-label">Multiplier</div>
      <input id="atr-multiplier-input" type="number" step="0.1" value="2.3" />
    </div>

    <div class="risk-group">
      <div class="risk-label">ATR atual</div>
      <input id="atr-value-input" type="number" step="0.01" placeholder="ex: 1.25" />
    </div>

    <div class="risk-group">
      <div class="risk-label">Capital da posição ($)</div>
      <input id="atr-capital-input" type="number" step="100" placeholder="ex: 100000" />
    </div>

    <div class="risk-group">
      <div class="risk-label">Preço de entrada</div>
      <input id="atr-entry-input" type="number" step="0.01" placeholder="ex: 177" />
    </div>

    <div class="risk-group">
      <div class="risk-label">Risco por trade (%)</div>
      <input id="atr-riskpct-input" type="number" step="0.1" value="1" />
    </div>

    <div class="risk-group">
      <div class="risk-label">Lado</div>
      <select id="atr-side-input">
        <option value="buy">Compra</option>
        <option value="sell">Venda</option>
      </select>
    </div>

    <div class="risk-actions">
      <button id="atr-calc-btn" type="button">Calcular risco</button>
    </div>

    <div class="risk-results">
      <div>
        <div class="risk-result-label">Distância do stop (ATR × mult)</div>
        <div class="risk-result-value" id="atr-stop-distance">—</div>
      </div>
      <div>
        <div class="risk-result-label">Qtd. sugerida de ações</div>
        <div class="risk-result-value" id="atr-shares">—</div>
      </div>
      <div>
        <div class="risk-result-label">Risco aproximado</div>
        <div class="risk-result-value" id="atr-risk-money">—</div>
      </div>
      <div>
        <div class="risk-result-label">Alvo 2R · 3R (aprox.)</div>
        <div class="risk-result-value" id="atr-reward-2r">—</div>
        <div class="risk-result-value small" id="atr-reward-3r">—</div>
      </div>
    </div>
  </div>
</section>

      <!-- SIZING BRAIN – GERENCIADOR DE RISCO -->


      
        <div class="card">
          <div class="card-header">
            <div>
              <div class="card-title" data-i18n="card.tv_title">Painel de Preço em Tempo Real</div>
<div class="card-subtitle" data-i18n="card.tv_sub">Alpaca PRO + Estrutura do Dia</div>


            </div>
            <div class="badge-outline green">
              <span class="dot"></span>
              Fluxo
              <span id="flow-label">Neutro</span>
            </div>
          </div>

         




          <!-- AARON CHART (ALPACA) -->
<div class="panel-section">
  <div class="panel-section-header">
    <div class="panel-section-title">Gráfico em Tempo Real</div>
    <div class="pill-soft pill-soft-accent">Fonte: Alpaca PRO</div>
  </div>

  <!-- AARON Studies (módulos) -->
  <div class="aaron-studies">
    <div class="aaron-studies-title">AARON Studies</div>

    <div class="aaron-studies-pills">
      <label class="pill-toggle">
        <input id="st-session-hl" type="checkbox" checked />
        <span>Session H/L</span>
      </label>

      <label class="pill-toggle">
        <input id="st-prevday" type="checkbox" checked />
        <span>Prev Day</span>
      </label>

      <label class="pill-toggle">
        <input id="st-orb" type="checkbox" />
        <span>ORB 5m</span>
      </label>

      <label class="pill-toggle">
        <input id="st-vwap" type="checkbox" checked />
        <span>VWAP</span>
      </label>

      <label class="pill-toggle">
        <input id="st-ema21" type="checkbox" checked />
        <span>EMA 21</span>
      </label>
    </div>
  </div>

  <div class="aaron10-chart-shell">
    <div id="aaron10-chart" class="aaron10-chart"></div>

    <!-- overlay discreto (meta do chart) -->
    <div class="aaron10-chart-overlay">
      <div class="pill-small" id="chart-meta">—</div>
    </div>
  </div>
</div>

        </div>
                  <div class="resp-snap" id="resp-snap">
  <div class="resp-snap-title">RESPONDER OUTPUT</div>

  <div class="resp-kpis">
    <div class="resp-kpi">
      <div class="resp-kpi-label">PATTERN</div>
      <div class="resp-kpi-value" id="resp-kpi-pattern">—</div>
    </div>
    <div class="resp-kpi">
      <div class="resp-kpi-label">CONFIDENCE</div>
      <div class="resp-kpi-value" id="resp-kpi-confidence">—</div>
    </div>
    <div class="resp-kpi">
      <div class="resp-kpi-label">BIAS</div>
      <div class="resp-kpi-value" id="resp-kpi-bias">—</div>
    </div>
    <div class="resp-kpi">
      <div class="resp-kpi-label">DIRECTION</div>
      <div class="resp-kpi-value" id="resp-kpi-direction">—</div>
    </div>
    <div class="resp-kpi">
      <div class="resp-kpi-label">SR (L—H)</div>
      <div class="resp-kpi-value" id="resp-kpi-sr">—</div>
    </div>
    <div class="resp-kpi">
      <div class="resp-kpi-label">BARS</div>
      <div class="resp-kpi-value" id="resp-kpi-bars">—</div>
    </div>
  </div>

  <div class="resp-snap-grid">
    <div class="resp-snap-col">
      <div class="resp-snap-head">panel</div>
      <div class="resp-snap-body" id="resp-snap-panel">—</div>
    </div>

    <div class="resp-snap-col">
      <div class="resp-snap-head">ui</div>
      <div class="resp-snap-body" id="resp-snap-ui">—</div>
    </div>

    <div class="resp-snap-col">
      <div class="resp-snap-head">digest</div>
      <div class="resp-snap-body" id="resp-snap-digest">—</div>
    </div>
  </div>
</div>

                  <!-- ===== NOVO: Estrutura recente + Market Structure ===== -->
          <div class="panel-section">
            <div class="panel-section-header">
              <div class="panel-section-title">Estrutura recente</div>
            </div>

            <div class="structure-wrapper">
              <!-- Chips HH / HL / LH / LL -->
              <div class="structure-grid">
                <div class="structure-chip" id="structure-hh">
                  <span class="structure-label">HH</span>
                  <span>
                    <span class="structure-status" id="structure-hh-status">off</span>
                    <span class="structure-dot" id="structure-hh-dot"></span>
                  </span>
                </div>

                <div class="structure-chip" id="structure-hl">
                  <span class="structure-label">HL</span>
                  <span>
                    <span class="structure-status" id="structure-hl-status">off</span>
                    <span class="structure-dot" id="structure-hl-dot"></span>
                  </span>
                </div>

                <div class="structure-chip" id="structure-lh">
                  <span class="structure-label">LH</span>
                  <span>
                    <span class="structure-status" id="structure-lh-status">ativo</span>
                    <span class="structure-dot on" id="structure-lh-dot"></span>
                  </span>
                </div>

                <div class="structure-chip" id="structure-ll">
                  <span class="structure-label">LL</span>
                  <span>
                    <span class="structure-status" id="structure-ll-status">ativo</span>
                    <span class="structure-dot on" id="structure-ll-dot"></span>
                  </span>
                </div>
              </div>

              <!-- ZigZag / Market Structure -->
              <div class="structure-zigzag">
                <div class="structure-zigzag-title">
                  Market structure · últimos candles
                </div>
                <div class="structure-zigzag-box">
                  <svg
                    id="structure-zigzag-svg"
                    class="structure-zigzag-svg"
                    viewBox="0 0 100 40"
                    preserveAspectRatio="none"
                  >
                    <polyline
                      id="structure-zigzag-poly"
                      points="0,30 15,12 30,26 45,10 60,24 75,8 90,22 100,14"
                      fill="none"
                      stroke="rgba(248,113,113,0.9)"
                      stroke-width="2.2"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    />
                  </svg>
                </div>
              </div>
            </div>
          </div>
          <!-- ===== /Estrutura recente ===== -->


       <!-- ===== SIZING BRAIN – ABAIXO DO TRADEVIEW ===== -->

<!-- ===== SIZING BRAIN – GERENCIADOR + CAPITAL DO DIA (ABAIXO DO TRADEVIEW) ===== -->
<section class="card sizing-brain-card" id="sizing-brain-card">
  <div class="card-header">
    <h2>Sizing Brain – Gerenciador de Risco & Gestão de capital do dia</h2>
    <p class="card-subtitle">
      ATR • Capital em uso • Stop • Take Profit • Qtd sugerida · Gestão de capital do dia
    </p>
  </div>

  <div class="card-body">
    <!-- BLOCO 1 · GERENCIADOR DE RISCO (MESMO DE CIMA) -->
    <div class="sb-grid">
      <div class="sb-field">
        <label for="sb-account-balance">Capital real da conta (USD)</label>
        <input id="sb-account-balance" type="number" step="0.01" value="25000" />
      </div>

      <div class="sb-field">
        <label for="sb-leverage">Alavancagem (buying power x)</label>
        <input id="sb-leverage" type="number" step="0.1" value="4" />
        <small id="sb-buying-power-info" class="sb-hint">Buying power ≈ $100.000</small>
      </div>

      <div class="sb-field">
        <label for="sb-trade-capital">Capital em uso neste trade (USD)</label>
        <input id="sb-trade-capital" type="number" step="0.01" value="50000" />
        <small class="sb-hint">Pode ser menor que o buying power se quiser ser conservador.</small>
      </div>

      <div class="sb-field">
        <label for="sb-risk-percent">Risco máx. por trade (% da conta)</label>
        <input id="sb-risk-percent" type="number" step="0.1" value="1" />
        <small class="sb-hint">Ex: 1% em uma conta de 25k = $250 de risco.</small>
      </div>
    </div>

    <hr class="sb-divider" />

    <div class="sb-grid">
      <div class="sb-field">
        <label for="sb-entry-price">Preço de entrada</label>
        <input id="sb-entry-price" type="number" step="0.01" value="100" />
      </div>

      <div class="sb-field">
        <label for="sb-atr-value">ATR atual ($)</label>
        <input id="sb-atr-value" type="number" step="0.01" value="1.2" />
      </div>

      <div class="sb-field">
        <label for="sb-atr-mult-stop">Multiplicador ATR STOP</label>
        <input id="sb-atr-mult-stop" type="number" step="0.1" value="1.5" />
        <small class="sb-hint">Stop em ATR (ex: 1.5x ATR).</small>
      </div>

      <div class="sb-field">
        <label for="sb-atr-mult-take">Multiplicador ATR TAKE</label>
        <input id="sb-atr-mult-take" type="number" step="0.1" value="3" />
        <small class="sb-hint">Take profit em ATR (ex: 3x ATR).</small>
      </div>

      <div class="sb-field">
        <label>Direção</label>
        <div class="sb-side-toggle">
          <label>
            <input type="radio" name="sb-side" value="long" checked />
            <span>Compra / CALL</span>
          </label>
          <label>
            <input type="radio" name="sb-side" value="short" />
            <span>Venda / PUT</span>
          </label>
        </div>
      </div>
    </div>

    <hr class="sb-divider" />

    <div class="sb-results-grid">
  <div class="sb-result-block">
    <h3>Stop &amp; Alvo (ATR)</h3>
    <p id="sb-stop-distance" class="sb-result-main">Distância do STOP: –</p>
    <p id="sb-stop-price" class="sb-result-sub">Stop Loss sugerido: –</p>
    <p id="sb-take-price" class="sb-result-sub">Take Profit sugerido: –</p>
  </div>

  <div class="sb-result-block">
    <h3>Qtd &amp; Risco</h3>
    <p id="sb-position-size" class="sb-result-main">Qtd sugerida: –</p>
    <p id="sb-risk-dollar" class="sb-result-sub">Risco aprox.: –</p>
    <p id="sb-risk-percent" class="sb-result-sub">Risco % trade / conta: –</p>
  </div>
</div>

<!-- NOVO · TERMÔMETRO DO GERENCIADOR DE RISCO (OFFLINE) -->
<div class="sb-meter">
  <div class="sb-meter-label">
    <span>Conservador</span>
    <span id="sb-meter-label">Uso de risco 0%</span>
    <span>Agressivo</span>
  </div>
  <div class="sb-meter-bar">
    <div id="sb-meter-fill" class="sb-meter-fill safe"></div>
  </div>
</div>

<div class="sb-actions">
  <button id="sb-calcular" class="primary-btn">Recalcular Sizing</button>
  <span id="sb-status" class="sb-status">
    Ajuste os valores e clique em “Recalcular Sizing”.
  </span>
</div>


    <!-- DIVISOR ENTRE GERENCIADOR E CAPITAL DO DIA -->
    <hr class="sb-divider" />

    <!-- BLOCO 2 · GESTÃO DE CAPITAL DO DIA (O MESMO QUE FICAVA ABAIXO DO TRADEVIEW) -->

    <div class="decision-title" data-i18n="sizing.title">
      Sizing Brain · Gestão de capital do dia
    </div>

    <!-- HEADER: números principais -->
    <div class="sizing-header-row">
      <div class="sizing-main-numbers">
        <div class="sizing-label">
          <span data-i18n="sizing.target_label">Alvo razoável hoje</span>
        </div>
        <div class="sizing-target-value" id="sizing-target">
          0.8–1.4%
        </div>
      </div>

      <div class="sizing-secondary-numbers">
        <div>
          <span data-i18n="sizing.max_dd">Máx. perda</span>:
          <strong id="sizing-max-dd">0.8%</strong>
        </div>
        <div>
          <span data-i18n="sizing.risk_trade">Risco / trade</span>:
          <strong id="sizing-risk-trade">0.25%</strong>
        </div>
        <div>
          <span data-i18n="sizing.trades">Trades A+</span>:
          <strong id="sizing-trades-count">3</strong>
        </div>
      </div>
    </div>

    <!-- TAGS: perfil + estilo -->
    <div class="sizing-tag-row">
      <span id="sizing-profile-tag" class="sizing-tag profile-normal">
        Normal
      </span>
      <span id="sizing-style-tag" class="sizing-tag style-daytrade">
        Day trade tendencial
      </span>
    </div>

    <!-- TERMÔMETRO -->
    <div class="sizing-meter">
      <div class="sizing-meter-label">
        <span data-i18n="sizing.conservative">Conservador</span>
        <span id="sizing-meter-label">Uso de risco 40%</span>
        <span data-i18n="sizing.aggressive">Agressivo</span>
      </div>
      <div class="sizing-meter-bar">
        <div
          id="sizing-meter-fill"
          class="sizing-meter-fill"
          style="width:40%;"
        ></div>
      </div>
    </div>

    <!-- Inputs tipo Aaron Pine -->
    <div class="sizing-inputs">
      <div class="sizing-input">
        <label for="sizing-account-real-input">
          Capital REAL da conta (USD)
        </label>
        <input
          id="sizing-account-real-input"
          type="number"
          inputmode="decimal"
          placeholder="ex: 10000"
        />
      </div>

      <div class="sizing-input">
        <label for="sizing-use-input">
          Capital EM USO neste trade (USD)
        </label>
        <input
          id="sizing-use-input"
          type="number"
          inputmode="decimal"
          placeholder="ex: 10000"
        />
      </div>

      <div class="sizing-input">
        <label for="sizing-leverage-input">
          Alavancagem (×)
        </label>
        <input
          id="sizing-leverage-input"
          type="number"
          inputmode="decimal"
          step="0.1"
          placeholder="ex: 4"
        />
      </div>

      <div class="sizing-input">
        <label for="sizing-risk-input">
          Risco por trade (%)
        </label>
        <input
          id="sizing-risk-input"
          type="number"
          inputmode="decimal"
          step="0.1"
          placeholder="ex: 0.5"
        />
      </div>

      <div class="sizing-input">
        <label for="sizing-stop-input">
          Distância do stop (USD por share)
        </label>
        <input
          id="sizing-stop-input"
          type="number"
          inputmode="decimal"
          step="0.01"
          placeholder="ex: 1.20"
        />
      </div>

      <div class="sizing-input">
        <label for="sizing-fixedqty-input">
          Qtd fixa (ações) – opcional
        </label>
        <input
          id="sizing-fixedqty-input"
          type="number"
          inputmode="decimal"
          placeholder="ex: 100"
        />
      </div>
    </div>

    <!-- Frases + comentário -->
    <div class="sizing-phrase">
      <div id="sizing-phrase-main" class="sizing-phrase-main">
        Digite Capital REAL, EM USO, risco % e stop para ver o tamanho sugerido
        da posição.
      </div>
      <div id="sizing-phrase-detail" class="sizing-phrase-detail"></div>
    </div>

    <div class="sizing-comment" id="sizing-comment">
      Hoje o fluxo permite buscar algo em torno de 0.8–1.2% se você focar em 2–3
      trades A+. Acima disso já entra zona de ganância; abaixo disso ainda é um
      dia ok se você seguiu o plano.
    </div>
  </div>
</section>

<!-- ====== ABA DE REFERÊNCIA (ABAIXO DO SIZING BRAIN) ====== -->
<section class="card ref-card" id="pattern-reference-card">
  <div class="card-header">
    <div>
      <div class="card-title">Referência de Padrão</div>
      <div class="card-subtitle">Abra para ver a imagem que o THE EYE está usando.</div>
    </div>
    <span class="pill neutral">REF</span>
  </div>

  <details class="ref-details" id="refDetails">
    <summary class="ref-summary">
      <span class="ref-summary-left">
        <span class="ref-summary-title" id="refSummaryTitle">Abrir referência</span>
        <span class="ref-summary-mini" id="refPatternMini">—</span>
      </span>
      <span class="ref-summary-right" id="refSummaryRight">Abrir</span>
    </summary>

    <div class="ref-body">
      <div class="ref-grid">
        <div class="ref-img-wrap">
          <img
            id="refPatternImg"
            src="assets/patterns/F%20(1).jpg"
            alt="Referência do padrão"
            loading="lazy"
          />
        </div>

        <div class="ref-text">
          <div class="ref-line">
            <span class="muted">Padrão:</span>
            <strong id="refPatternLabel">—</strong>
          </div>

          <div class="ref-line">
            <span class="muted">Setup:</span>
            <span id="refPatternSetup">—</span>
          </div>

          <div class="ref-line">
            <span class="muted">Notas:</span>
            <span id="refPatternNotes">—</span>
          </div>

          <a
            id="refPatternLink"
            class="ref-link"
            href="assets/patterns/F%20(1).jpg"
            target="_blank"
            rel="noopener"
          >
            Ver imagem em tamanho real
          </a>
        </div>
      </div>
    </div>
  </details>
</section>
<!-- ====== /ABA DE REFERÊNCIA ====== -->





      </section>

      <!-- ====== COLUNA DIREITA: RESUMO + RISCO ====== -->
      <section class="column">
        <div class="card">
  <div class="card-header">
    <div>
      <div class="card-title" data-i18n="summary.title">Resumo institucional</div>
      <div class="card-subtitle" data-i18n="summary.subtitle">Leitura consolidada do AARON 9</div>
    </div>
    <div class="badge-outline">
      <span class="dot"></span>
      <span data-i18n="summary.risk_mgmt">Gestão de risco</span>
    </div>
  </div>

<!-- ====== AARON 9 – COLUNA DIREITA (DECISION PANEL) ====== -->
<div class="decision-column">

    <!-- AUTO PILOT (fora do Citadel, dentro do Resumo Institucional) -->
<section class="decision-card autopilot-v2" id="autopilot-panel">
  <div class="ap2-top">
    <div>
      <div class="decision-title">AUTO PILOT</div>
      <div class="ap2-sub">Execução rápida (simulador)</div>
    </div>

    <div class="ap2-controls">
      <span id="ap-state" class="badge-outline ap-off">OFF</span>

      <label class="ap-switch ap2-switch" title="Liga/desliga o Autopilot (simulador)">
        <input type="checkbox" id="ap-toggle" />
        <span class="ap-slider"></span>
      </label>
    </div>
  </div>

  <!-- ====== MODO 2.0: capital -> units (shares) ====== -->
  <div class="ap2-sizing">
    <div class="ap2-price-row">
      <div class="ap2-quote ap2-quote-sell">
        <div class="ap2-quote-label">Sell</div>
        <div id="ap-price-sell" class="ap2-quote-price">—</div>
      </div>

      <div class="ap2-quote-mid">
        <div class="ap2-quote-mid-label">Price</div>
        <div id="ap-price-mid" class="ap2-quote-mid-price">—</div>
      </div>

      <div class="ap2-quote ap2-quote-buy">
        <div class="ap2-quote-label">Buy</div>
        <div id="ap-price-buy" class="ap2-quote-price">—</div>
      </div>
    </div>

    <div class="ap2-input-row">
      <div class="ap2-field">
        <label class="ap2-label">Units (shares)</label>
        <input id="ap-units" class="ap2-input" type="text" value="—" readonly />
      </div>

      <div class="ap2-field">
        <label class="ap2-label">Capital USD</label>
        <input id="ap-capital" class="ap2-input" type="number" step="100" value="25000" />
      </div>
    </div>
  </div>

  <div class="ap2-bottom">
    <button id="ap-buy" class="ap-btn ap-buy"><span class="ap2-ico">▲</span>BUY</button>
    <button id="ap-sell" class="ap-btn ap-sell"><span class="ap2-ico">▼</span>SELL</button>
    <button id="ap-close" class="ap-btn ap-close"><span class="ap2-ico">✕</span>CLOSE</button>

    <span id="ap-meta" class="ap-meta">—</span>
  </div>
</section>




  <!-- CARTÃO CITADEL · CARTÃO DE TRADE ATUAL -->
  <section id="trade-card" class="status-hero status-sell blink-hero">
    <div>
      <!-- TÍTULO -->
      <div class="status-hero-label" data-i18n="trade_card.title">
        AARON – Cartão de Trade Atual
      </div>

      <!-- BLOCO PRINCIPAL DO CARTÃO -->
      <div class="status-hero-main">
        <div class="trade-line">
          <strong data-i18n="trade_card.status_label">Status:</strong>
          <span id="trade-status-text">✅ Setup válido | ❌ Sem trade</span>
        </div>

<div class="trade-line">
  <strong>Pulse:</strong>
  <span id="pulseLine">—</span>
</div>


        <div class="trade-line" id="trade-stats-top-line" style="display:none;">
  <strong data-i18n="trade_card.stats_label">Estatística:</strong>
  <span id="trade-stats-top">—</span>
</div>




        <!-- NOVO: Estatística (7y) no topo -->
      
        <div class="trade-line">
          <strong data-i18n="trade_card.asset_label">Ativo:</strong>
          <span id="trade-symbol">NVDA</span>
          <span class="trade-sep">|</span>
          <strong data-i18n="trade_card.timeframe_label">Timeframe:</strong>
          <span id="trade-timeframe">1m</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.stats_label">Estatística:</strong>
          <span id="trade-stats">—</span>
        </div>


        <div class="trade-line">
          <strong data-i18n="trade_card.mode_label">Modo:</strong>
          <span id="trade-mode">Reversão em Resistência</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.against_label">Contra:</strong>
          <span id="trade-against">57% (base 7 anos)</span>
        </div>

        <hr class="trade-divider" />

        <div class="trade-line">
          <strong data-i18n="trade_card.dir_label">Direção sugerida:</strong>
          <span id="trade-direction">VENDA</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.entry_label">Entrada:</strong>
          <span id="trade-entry">492.80 – 493.10</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.stop_label">Stop:</strong>
          <span id="trade-stop">494.20</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.tp_label">TP1:</strong>
          <span id="trade-tp1">490.00</span>
          <span class="trade-sep">|</span>
          <strong>TP2:</strong>
          <span id="trade-tp2">487.50</span>
        </div>

        <hr class="trade-divider" />

        <div class="trade-line">
          <strong data-i18n="trade_card.size_label">Tamanho:</strong>
          <span id="trade-size">227 shares</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.risk_label">Risco:</strong>
          <span id="trade-risk">US$ 250 (1% do risk budget)</span>
        </div>

        <div class="trade-line">
          <strong data-i18n="trade_card.thermo_label">Termômetro:</strong>
          <span id="trade-thermo">Agressivo moderado</span>
        </div>

        <hr class="trade-divider" />

        <div class="trade-line trade-comment">
          <strong data-i18n="trade_card.comment_label">Comentário do AARON:</strong>
          <span id="trade-comment">
            “Reversão estatisticamente forte após falso rompimento.
            Se executar, não mova stop contra a posição.”
          </span>
        </div>
               


      </div>
    </div>

    <!-- BADGE LATERAL IGUAL AO COMPRA EM CONTINUAÇÃO -->
    <div id="trade-badge" class="status-hero-badge sell">
      GO FULL
    </div>
  </section>



  <!-- RESUMO INSTITUCIONAL / VEREDITO -->
<section class="right-col">

  <div class="decision-card hero-mode-card" id="hero-block">
    <div class="decision-row">
      <div>
        <div class="decision-title">RESUMO INSTITUCIONAL</div>
        <button class="decision-pill go-full" id="hero-mode-pill">GO FULL</button>
      </div>
      <div class="decision-verdict" id="hero-side-label">—</div>
    </div>

    <div class="decision-text" id="hero-summary-text">
      Carregando leitura institucional do mercado...
    </div>

    <div class="decision-title" style="margin-bottom:2px;">A favor</div>
    <div class="decision-subtitle" id="hero-favor-label">A favor: —%</div>
    <div class="decision-bar">
      <div class="decision-bar-fill" id="hero-favor-bar" style="width:0%"></div>
    </div>
    <div class="prob-phrase" id="hero-favor-phrase">—</div>

    <div style="height:10px"></div>

    <div class="decision-title" style="margin-bottom:2px;">Contra</div>
    <div class="decision-subtitle" id="hero-contra-label">Contra: —%</div>
    <div class="decision-bar">
      <div class="decision-bar-fill-danger" id="hero-contra-bar" style="width:0%"></div>
    </div>
    <div class="prob-phrase prob-phrase-danger" id="hero-contra-phrase">—</div>

    <div class="decision-grid3">
      <div>
        <div class="decision-mini-title">RISCO</div>
        <div class="decision-mini-text" id="hero-mini-risk">—</div>
      </div>
      <div>
        <div class="decision-mini-title">CONTEXTO</div>
        <div class="decision-mini-text" id="hero-mini-context">—</div>
      </div>
      <div>
        <div class="decision-mini-title">EXECUÇÃO</div>
        <div class="decision-mini-text" id="hero-mini-execution">—</div>
      </div>
    </div>
  </div>

</section>

    <!-- PULLBACK BRAIN · CÉREBRO ESPECIAL DE PULLBACK -->
  <section class="decision-card" id="pullback-brain-card">
    <div class="decision-title" data-i18n="pullback.title">
      Pullback Brain · Zona de respiro
    </div>

    <!-- HEADER: status + tags -->
    <div class="pullback-header-row">
      <div class="pullback-status-block">
        <div class="pullback-status-label">Status</div>
        <div id="pullback-status" class="pullback-status-main">
          Aguardando pullback...
        </div>
      </div>

      <div class="pullback-meta-block">
        <div>
          <span data-i18n="pullback.depth">Profundidade</span>:
          <strong id="pullback-depth">—</strong>
        </div>
        <div>
          <span data-i18n="pullback.quality">Qualidade</span>:
          <strong id="pullback-quality">—</strong>
        </div>

        <div class="pullback-tag-row">
          <span id="pullback-side-tag" class="pullback-tag side-neutral">
            NEUTRO
          </span>
          <span id="pullback-stage-tag" class="pullback-tag stage">
            Aguardando
          </span>
        </div>
      </div>
    </div>
    <div>
  <span>PB Candle</span>:
  <strong id="pullback-candle" class="pb-candle">—</strong>
</div>


    <!-- TERMÔMETRO / CONFIANÇA DO PULLBACK -->
    <div class="pullback-meter">
      <div class="pullback-meter-label">
        <span>Somente respiro</span>
        <span id="pullback-meter-label">Confiança 40%</span>
        <span>Reversão forte</span>
      </div>
      <div class="pullback-meter-bar">
        <div
          id="pullback-meter-fill"
          class="pullback-meter-fill neutral"
          style="width:40%;"
        ></div>
      </div>
    </div>

    <!-- TEXTO "HUMANO" DO CÉREBRO DE PULLBACK -->
    <div class="pullback-highlight" id="pullback-highlight-box">
      <div id="pullback-headline" style="font-weight:600; margin-bottom:4px;">
        Pullback ainda saudável dentro da tendência.
      </div>
      <div id="pullback-text" style="font-size:0.8rem;">
        Ainda não há um pullback claro.  
        O mercado ainda não ofereceu um pullback limpo na direção principal.
        Deixe o preço respirar e espere estrutura.
      </div>
    </div>
  </section>

   


  <!-- CHECKLIST DE PADRÕES -->
  <section class="decision-card">
    <div class="decision-title">Checklist de padrões</div>
    <div class="checklist-grid">
      <div class="check-pill on">Rompimento</div>
      <div class="check-pill">Continuação</div>
      <div class="check-pill">Reversão (ausente)</div>
      <div class="check-pill on">Divergência</div>
      <div class="check-pill">Exaustão</div>
      <div class="check-pill">Volume normal</div>
    </div>
  </section>

  <!-- PATTERN RADAR + CHECK PULLBACK -->
  <section class="decision-card">
  <div class="decision-title">Pattern radar · estrutura</div>

  <div class="pattern-layout" style="margin-top:6px;">

    <!-- PADRÃO DO DIA -->
    <div class="pattern-box">
      <div class="decision-title" style="margin-bottom:4px;">Padrão do dia</div>

      <div class="pattern-canvas">
        <!-- Desenho simbólico do padrão do dia (ex.: canal de baixa) -->
        <svg class="pattern-svg" viewBox="0 0 100 36">
          <polyline
            points="0,10 20,16 40,20 60,24 80,28 100,32"
            fill="none"
            stroke="rgba(248,113,113,0.9)"
            stroke-width="2.2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </div>

           <div id="pattern-day-label" class="pattern-name">Canal de baixa moderada</div>
      <div id="pattern-day-detail">
        Preço respeitando topos e fundos descendentes durante o dia. Favorece operações a favor da tendência de baixa.
      </div>


    <!-- PADRÃO DO MOMENTO (últimos 50 candles) -->
    <div class="pattern-box">
      <div class="decision-title" style="margin-bottom:4px;">Padrão do momento · últimos 50 candles</div>

      <div class="pattern-canvas">
        <!-- Desenho simbólico do padrão do momento (ex.: range / zigue-zague) -->
        <svg class="pattern-svg" viewBox="0 0 100 36">
          <polyline
            points="0,26 15,10 30,24 45,12 60,22 75,8 90,20 100,14"
            fill="none"
            stroke="rgba(56,189,248,0.9)"
            stroke-width="2.2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </div>

           <div id="pattern-now-label" class="pattern-name">Range / consolidação ativa</div>
      <div id="pattern-now-detail">
        Mercado alternando entre suporte e resistência nos últimos candles. Melhor aguardar rompimento ou pullback bem claro.
      </div>

    </div>

  </div>


    <!-- Check de pullback / respiro -->
    <div class="pullback-highlight">
      <div style="font-weight:600; margin-bottom:4px;">Check de pullback</div>
      <div style="font-size:0.78rem;">
        ATR do candle atual: <strong>0.85</strong> · Profundidade: <strong>0.96 ATR</strong><br />
        Tendência: <strong>Baixa forte</strong> · Estrutura: <strong>LH</strong><br />
        Pullback dentro da faixa ideal. Continuação provável se o contexto se mantiver.
      </div>
    </div>
  </section>

</div>

          <!-- Comentário principal -->
          <div class="panel-section">
            <div class="panel-section-header">
              <div class="panel-section-title">Comentário do Painel</div>
            </div>
            <div class="row" style="flex-direction: column; align-items: flex-start; gap: 4px;">
              <div id="summary-text" style="font-size: 12px; line-height: 1.5; color: var(--text-main);">
                Aguardando primeiro alerta do TradingView para montar o painel...
              </div>
            </div>
          </div>

          <!-- Risco + Contexto -->
          <div class="grid-2">
            <div class="panel-section">
              <div class="panel-section-header">
                <div class="panel-section-title">Risco</div>
              </div>
              <div class="row" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                <div class="pill" id="risk-pill">Neutro</div>
                <div id="risk-text" style="font-size: 12px; color: var(--text-soft);">
                  —
                </div>
              </div>
            </div>

            <div class="panel-section">
              <div class="panel-section-header">
                <div class="panel-section-title">Contexto</div>
              </div>
              <div class="row" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                <div id="context-text" style="font-size: 12px; color: var(--text-soft);">
                  —
                </div>
              </div>
            </div>
          </div>

          <!-- Execução -->
          <div class="panel-section">
            <div class="panel-section-header">
              <div class="panel-section-title">Execução</div>
            </div>
            <div id="execution-text" style="font-size: 12px; color: var(--text-soft);">
              —
            </div>
          </div>
        </div>
      </section>
    </main>
      </div> <!-- /.page -->
    </div>   <!-- /.app-inner -->
  </div>     <!-- /.app-shell -->

  <script>
// ======= CONFIG PAINEL (JSON) =======
const PANEL_URL = 'https://jjjnogueira.app.n8n.cloud/webhook/aaron10_panel_json';
const REFRESH_MS = 60000; // 1 minuto

// ======= AARON10 (FASE 1) — Dropdown -> n8n WEBHOOK (symbol) =======
// COLE ESTE BLOCO LOGO ABAIXO DO: const REFRESH_MS = 60000;

// OPÇÃO 2 (direto)
const MATCHER_WEBHOOK_URL_PROD = "https://jjjnogueira.app.n8n.cloud/webhook/aaron10_matcher_request";
const MATCHER_WEBHOOK_URL_TEST = "https://jjjnogueira.app.n8n.cloud/webhook-test/aaron10_matcher_request";
const MATCHER_WEBHOOK_URL = MATCHER_WEBHOOK_URL_PROD; // default
// (pra testar no editor do n8n, use webhook-test):
// const MATCHER_WEBHOOK_URL = "https://jjjnogueira.app.n8n.cloud/webhook-test/aaron10_matcher_request"; 
// Exemplo (prod): https://SEU_WORKSPACE.app.n8n.cloud/webhook/aaron10_matcher_request
// (não use a test url depois de publicar; use a url de produção)


// ======= AARON10 LIVE CANDLES (Alpaca PRO → Cloud Run → UI) =======
const A10_USE_LIVE_CANDLES = true;

// Cloud Run (SEU serviço atual)
const A10_LIVE_WS_URL_PROD = "wss://aaron10-panel-api-888402066046.us-central1.run.app/ws";

// (opcional) preview/local (se quiser depois trocar pra ws://localhost:8080/ws)
const A10_LIVE_WS_URL_TEST = "wss://aaron10-panel-api-888402066046.us-central1.run.app/ws";

// auto-select: local (file://, localhost, 127.0.0.1) -> TEST, senão -> PROD
const __A10_IS_LOCAL =
  (location.protocol === "file:" ||
   location.hostname === "" ||
   location.hostname === "localhost" ||
   location.hostname === "127.0.0.1");

const A10_LIVE_WS_URL = __A10_IS_LOCAL ? A10_LIVE_WS_URL_TEST : A10_LIVE_WS_URL_PROD;

let a10LiveWanted = { symbol: null, timeframe: null };

// timers/estado (pra não dar ReferenceError)
let a10LiveWS = null;
let a10LiveReconnectTimer = null;
let a10LiveHeartbeatTimer = null;
let a10LastMsgAt = 0;
window.a10LastMsgAt = 0;
// backoff de reconexão (evita spam/429 no Cloud Run)
const A10_LIVE_RETRY_MIN_MS = 5000;   // 5s
const A10_LIVE_RETRY_MAX_MS = 60000;  // 60s
let a10LiveRetryMs = A10_LIVE_RETRY_MIN_MS;


function a10LiveSetStatus(text){
  const msg = text || "—";

  // 1) label do topo (Sessão)
  const el = document.getElementById("session-label");
  if (el) el.textContent = msg;

  // 2) Mostra também no “LIVE FEED”
  const liveEl = document.querySelector(".status-dot-live");
  if (liveEl) liveEl.textContent = msg;

  window.__A10_LIVE_STATUS__ = msg;
}

function a10LiveClose(){
  try { if (a10LiveWS) a10LiveWS.close(); } catch(e){}
  a10LiveWS = null;

  // (1B) zera também no window pra console refletir na hora
  window.a10LiveWS = null;

  window.a10LastMsgAt = 0;

  if (a10LiveReconnectTimer) clearTimeout(a10LiveReconnectTimer);
  a10LiveReconnectTimer = null;

  if (a10LiveHeartbeatTimer) clearInterval(a10LiveHeartbeatTimer);
  a10LiveHeartbeatTimer = null;

  window.__A10_LIVE_FALLBACK_TRIED__ = false;
}



function a10LiveSubscribe(symbol, timeframe){
  const sym = String(symbol || "").trim().toUpperCase();
  const tfRaw = String(timeframe || "1m").trim();

  if (!sym) return;
  if (!a10LiveWS || a10LiveWS.readyState !== 1) return;

  // normaliza timeframe “desejado” (UI)
  const desiredTf =
    (/^\d+m(in)?$/i.test(tfRaw) || /^\d+m$/i.test(tfRaw)) ? tfRaw.replace(/in$/i, '') :
    (/^\d+min$/i.test(tfRaw)) ? tfRaw :
    tfRaw;

  // 🔥 IMPORTANTE:
  // A maioria dos relays/streams só entrega BAR em 1m (ou trades).
  // Então a gente SEMPRE pede 1m no wire e agrega localmente pro timeframe desejado.
  const wireTf = "1m";

  // payload compatível (type + action) pra não depender do nome do campo no server
  const payload = {
    type: "subscribe",
    action: "subscribe",
    symbol: sym,
    timeframe: wireTf,           // ✅ sempre 1m
    target_timeframe: desiredTf  // (debug) timeframe real da UI
  };

  // debug global
  window.__A10_LIVE_LAST_SUB__ = payload;

  try { a10LiveWS.send(JSON.stringify(payload)); } catch(e){}

  a10LiveSetStatus(`LIVE: subscribed ${sym} ${desiredTf} (wire ${wireTf})`);
}


function a10LiveHandleMessage(payloadOrEvent) {
  // aceita tanto o Event do WS quanto o "data" puro (string/obj)
  const data = (payloadOrEvent && typeof payloadOrEvent === "object" && "data" in payloadOrEvent)
    ? payloadOrEvent.data
    : payloadOrEvent;

  if (!data) return;

  // debug raw
  window.__A10_LIVE_LAST_RAW__ = data;

  // garante chart
  a10InitChart();

  // parse
  let obj = data;
  if (typeof data === "string") {
    try { obj = JSON.parse(data); } catch (e) {}
  }
    // Se o relay mandar status (ex.: "ALPACA: disconnected"), mostra e tenta resetar
  if (obj && typeof obj === "object" && String(obj.type || "").toLowerCase() === "status" && obj.status) {
    window.__A10_LIVE_LAST_OBJ__ = obj;

    const s = String(obj.status);
    a10LiveSetStatus(s);

    // Se o bridge Alpaca caiu mas o WS UI ainda está aberto, força reset (throttle 5s)
    if (/alpaca/i.test(s) && /disconnected|down|error/i.test(s)) {
      const now = Date.now();
      if (!window.__A10_RELAY_RESET_AT__ || (now - window.__A10_RELAY_RESET_AT__) > 5000) {
        window.__A10_RELAY_RESET_AT__ = now;
        try { a10LiveClose(); } catch(e) {}
        const w = a10LiveWanted || {};
        if (w.symbol) setTimeout(() => a10LiveConnect(w.symbol, w.timeframe), 250);
      }
    }
    return;
  }


  const wanted = a10LiveWanted || {};
  const symWanted = String(wanted.symbol || "").trim().toUpperCase();
  const tfWanted = String(wanted.timeframe || "1m").trim();

  function tfToSec(tf){
    const s = String(tf || "1m").trim().toLowerCase();
    if (/^\d+m$/.test(s)) return Math.max(1, parseInt(s, 10)) * 60;
    if (/^\d+h$/.test(s)) return Math.max(1, parseInt(s, 10)) * 3600;
    if (s === "1d" || s === "d") return 86400;
    return 60;
  }

  const bucketSec = tfToSec(tfWanted);

  function normOHLC(x){
    if (!x || typeof x !== "object") return null;

    const tSec = a10UnixSec(x?.t ?? x?.time ?? x?.timestamp ?? x?.datetime);
    const o = Number(x?.o ?? x?.open);
    const h = Number(x?.h ?? x?.high);
    const l = Number(x?.l ?? x?.low);
    const c = Number(x?.c ?? x?.close);
    const v = Number(x?.v ?? x?.volume ?? 0);

    if (!tSec) return null;
    if (!Number.isFinite(o) || !Number.isFinite(h) || !Number.isFinite(l) || !Number.isFinite(c)) return null;

    return { tSec, open:o, high:h, low:l, close:c, volume: Number.isFinite(v) ? v : 0 };
  }

  function normTrade(x){
    if (!x || typeof x !== "object") return null;

    const tSec = a10UnixSec(x?.t ?? x?.time ?? x?.timestamp ?? x?.datetime);
    const p = Number(x?.p ?? x?.price);
    const s = Number(x?.s ?? x?.size ?? x?.q ?? x?.qty ?? x?.volume ?? 0);

    if (!tSec) return null;
    if (!Number.isFinite(p)) return null;

    return { tSec, open:p, high:p, low:p, close:p, volume: Number.isFinite(s) ? s : 0 };
  }

  function buildAggBar(norm){
    if (!norm) return null;

    const bucketTime = Math.floor(norm.tSec / bucketSec) * bucketSec;

    // usa o candle que já está na tela como “estado” (open fixa, high/low expandem)
    const hasBase = Array.isArray(a10ChartCandles) && a10ChartCandles.length > 0;
    const last = hasBase ? a10ChartCandles[a10ChartCandles.length - 1] : null;

    let o, h, l, c, v;

    if (last && last.time === bucketTime) {
      o = last.open;
      h = Math.max(last.high, norm.high);
      l = Math.min(last.low,  norm.low);
      c = norm.close;
      v = (Number(last.volume) || 0) + (Number(norm.volume) || 0);
    } else if (last && bucketTime > last.time) {
      o = norm.open;
      h = norm.high;
      l = norm.low;
      c = norm.close;
      v = Number(norm.volume) || 0;
    } else if (!last) {
      o = norm.open;
      h = norm.high;
      l = norm.low;
      c = norm.close;
      v = Number(norm.volume) || 0;
    } else {
      // out-of-order/antigo: manda o “norm” bucketizado mesmo
      o = norm.open;
      h = norm.high;
      l = norm.low;
      c = norm.close;
      v = Number(norm.volume) || 0;
    }

    return { t: bucketTime, o, h, l, c, v };
  }

      function pushAggBar(bar){
    if (!bar) return;

    window.__A10_LIVE_HAS_BARS__ = true;
    window.__A10_LIVE_LAST_BAR_AT__ = Date.now(); // ✅ só quando chega BAR/TRADE
    window.__A10_LIVE_LAST_BAR_T__  = bar.t;

    a10UpdateChartFromPayload({
      bars: [bar],
      symbol: symWanted,
      timeframe: tfWanted,
      __live: true
    });
  }



    function handleOne(msg) {
    if (!msg) return;

    // lista
    if (Array.isArray(msg)) { msg.forEach(handleOne); return; }

    // envelope com bar / bars / candles / data
    if (msg && typeof msg === "object") {
      if (msg.bar && typeof msg.bar === "object") { handleOne(msg.bar); return; }

      // ✅ PATCH: suporta { type:"candle_update", candle:{...} }
      if (msg.candle && typeof msg.candle === "object") { handleOne(msg.candle); return; }

      if (Array.isArray(msg.bars) || Array.isArray(msg.candles)) { handleOne(msg.bars || msg.candles); return; }
      if (msg.data) { handleOne(msg.data); return; }
    }


    // 1) BAR OHLC
    const ohlc = normOHLC(msg);
    if (ohlc) {
      window.__A10_LIVE_LAST_45__ = ohlc;
      const bar = buildAggBar(ohlc);
      pushAggBar(bar);
      return;
    }

    // 2) TRADE tick (p/t)
    const tr = normTrade(msg);
    if (tr) {
      window.__A10_LIVE_LAST_45__ = tr;
      const bar = buildAggBar(tr);
      pushAggBar(bar);
      return;
    }

    // fallback debug
    window.__A10_LIVE_LAST_OBJ__ = msg;
  }

  handleOne(obj);
}



function a10LiveConnect(symbol, timeframe) {
  if (!A10_USE_LIVE_CANDLES) return;

  // guarda o "desejado" (pra reconectar certo)
  a10LiveWanted = { symbol, timeframe };
    window.__A10_LIVE_HAS_BARS__ = false;
  window.__A10_LIVE_LAST_BAR_AT__ = 0;
  window.__A10_LIVE_LAST_BAR_T__ = 0;
  window.__A10_LIVE_LAST_45__ = null;


  // fecha WS anterior (se existir)
  try { a10LiveClose(); } catch (e) {}

  // garante /ws
  const base = String(A10_LIVE_WS_URL || "").trim();
  const url = base.endsWith("/ws") ? base : (base.replace(/\/+$/, "") + "/ws");

  a10LiveSetStatus("ALPACA: CONNECTING");

  try {
    const ws = new WebSocket(url);
a10LiveWS = ws;
window.a10LiveWS = ws; // (1B) aparece no console


    ws.addEventListener("open", () => {
  if (ws !== a10LiveWS) return; // ignora socket velho
  a10LastMsgAt = Date.now();
  window.a10LastMsgAt = a10LastMsgAt; // debug no console
  a10LiveRetryMs = A10_LIVE_RETRY_MIN_MS; // resetou porque conectou

  a10LiveSetStatus("ALPACA: CONNECTED");

  // heartbeat (UI): NÃO envia ping pro relay
  // (se o relay repassar pro WS da Alpaca, isso pode derrubar a Alpaca)
        // heartbeat (UI): NÃO envia ping pro relay
      if (a10LiveHeartbeatTimer) clearInterval(a10LiveHeartbeatTimer);
      a10LiveHeartbeatTimer = setInterval(() => {
        window.__A10_UI_HEARTBEAT__ = Date.now();
      }, 15000);

  // subscribe assim que conectar
  a10LiveSubscribe(symbol, timeframe);
});


    // ✅ CRÍTICO: passar o Event (o handler aceita Event ou data)
ws.addEventListener("message", (ev) => {
  if (ws !== a10LiveWS) return;
  a10LastMsgAt = Date.now();
  window.a10LastMsgAt = a10LastMsgAt; // debug no console
  a10LiveHandleMessage(ev);
});



    ws.addEventListener("close", (e) => {
  if (ws !== a10LiveWS) return; // close de socket velho: ignora

  const code = (e && typeof e.code === "number") ? e.code : 0;
  const waitMs = Math.max(A10_LIVE_RETRY_MIN_MS, a10LiveRetryMs || A10_LIVE_RETRY_MIN_MS);

  a10LiveSetStatus(`ALPACA: DISCONNECTED (${code || "close"}) — retry em ${Math.round(waitMs/1000)}s`);

  if (a10LiveHeartbeatTimer) clearInterval(a10LiveHeartbeatTimer);
  a10LiveHeartbeatTimer = null;

  if (a10LiveReconnectTimer) clearTimeout(a10LiveReconnectTimer);

  // aumenta backoff (cap)
  a10LiveRetryMs = Math.min(A10_LIVE_RETRY_MAX_MS, Math.round(waitMs * 1.8));

  a10LiveReconnectTimer = setTimeout(() => {
    const w = a10LiveWanted || {};
    if (w.symbol) a10LiveConnect(w.symbol, w.timeframe);
  }, waitMs);
});


    ws.addEventListener("error", () => {
  if (ws !== a10LiveWS) return;
  a10LiveSetStatus("ALPACA: WS ERROR");
  try { ws.close(); } catch(e) {}
});

  } catch (err) {
    console.error(err);
    a10LiveSetStatus("ALPACA: CONNECT FAIL");
  }
}







// ======= AARON10 (FASE 2) — Timeframe picker (UI) + query param =======
const AARON_TF_KEY = "aaron_selected_timeframe";


function getSelectedTimeframe(){
  const tf = (window.AARON_SELECTED_TIMEFRAME || localStorage.getItem(AARON_TF_KEY) || "1m").toString().trim();
  return tf || "1m";
}

function setSelectedTimeframe(tf, opts = {}){
  const { dispatch = true } = opts;
  tf = String(tf || "").trim();
  if (!tf) return;

  window.AARON_SELECTED_TIMEFRAME = tf;
  try { localStorage.setItem(AARON_TF_KEY, tf); } catch(e){}

  // UI active state
  const picker = document.getElementById("tf-picker");
  if (picker) {
    picker.querySelectorAll(".tf-btn").forEach(btn => {
      const isOn = String(btn.dataset.tf || "") === tf;
      btn.classList.toggle("active", isOn);
    });
  }

  // labels
  const tfLabel = document.getElementById("timeframe-label");
  if (tfLabel) tfLabel.textContent = tf.toUpperCase();

  const tradeTf = document.getElementById("trade-timeframe");
  if (tradeTf) tradeTf.textContent = tf.toUpperCase();

  if (dispatch) {
    window.dispatchEvent(new CustomEvent("aaron:timeframeSelected", { detail: { timeframe: tf } }));
  }
}

function installTimeframePicker(){
  const picker = document.getElementById("tf-picker");
  if (!picker) return;

  if (picker.__installed) return;
  picker.__installed = true;

  picker.addEventListener("click", (e) => {
    const btn = e.target.closest(".tf-btn");
    if (!btn) return;
    const tf = String(btn.dataset.tf || "").trim();
    if (!tf) return;
    setSelectedTimeframe(tf, { dispatch: true });
  });

  // init from storage
  const initTf = getSelectedTimeframe();
  setSelectedTimeframe(initTf, { dispatch: false });
}

// instala agora (script está no fim do body)
installTimeframePicker();

window.addEventListener("aaron:timeframeSelected", () => {
  const symbol =
    window.AARON_SELECTED_SYMBOL ||
    localStorage.getItem("aaron_selected_symbol") ||
    "NVDA";

  const tf =
    (typeof getSelectedTimeframe === "function")
      ? getSelectedTimeframe()
      : (localStorage.getItem("aaron_selected_timeframe") || "1m");

  // ✅ re-assina live candles no novo TF
  if (typeof a10LiveConnect === "function") a10LiveConnect(symbol, tf);

  requestMatcher(symbol);
  loadPanel(true);
});


// chama o n8n e atualiza o painel com o retorno
// ==========================
// TRADE CARD • RESPONDER OUTPUT renderer
// ==========================
// chama o n8n e atualiza o painel com o retorno
// ==========================
// RESPONDER OUTPUT helpers
// ==========================
function setRespSnapMessage(msg){
  const html = `<div class="resp-snap-null">${String(msg || "—")}</div>`;
  ["resp-snap-panel","resp-snap-ui","resp-snap-digest"].forEach((id)=>{
    const el = document.getElementById(id);
    if (el) el.innerHTML = html;
  });
  // KPIs (se existirem)
  ["resp-kpi-pattern","resp-kpi-conf","resp-kpi-bias","resp-kpi-dir","resp-kpi-sr","resp-kpi-bars","resp-kpi-price"]
    .forEach((id)=>{
      const el = document.getElementById(id);
      if (el) el.textContent = "—";
    });
}

// ==========================
// TRADE CARD • RESPONDER OUTPUT renderer
// ==========================
function renderTradeResponderOutput(data){
  data = Array.isArray(data) ? (data[0] ?? {}) : (data ?? {});
  const elPanel  = document.getElementById("resp-snap-panel");
  const elUI     = document.getElementById("resp-snap-ui");
  const elDigest = document.getElementById("resp-snap-digest");
  if (!elPanel || !elUI || !elDigest) return;

  const panel  = data?.panel  || {};
  const ui     = data?.ui     || {};
  const digest = data?.digest || {};

  // ====== KPI row (WOW "na cara") ======
  const sf = digest?.shape_focus || {};
  const sr = digest?.sr_proxy || {};

  const setK = (id, v) => {
    const el = document.getElementById(id);
    if (!el) return;
    const out = (v === undefined || v === null || v === "") ? "—" : String(v);
    el.textContent = out;
  };

  setK("resp-kpi-pattern", sf.label || ui.structure_line || "—");
  setK("resp-kpi-conf", ui.confidence_label || (sf.confidence_pct != null ? `${sf.confidence_pct}%` : "—"));
  setK("resp-kpi-bias", sf.bias || "—");
  setK("resp-kpi-dir",  sf.direction || sr.direction || "—");
  setK("resp-kpi-sr",   (sr.recent_low != null || sr.recent_high != null) ? `${sr.recent_low ?? "—"} — ${sr.recent_high ?? "—"}` : "—");
  setK("resp-kpi-bars", digest.intraday_bars ?? "—");
  setK("resp-kpi-price", (panel.price_now ?? ui.price_now ?? digest.price_now) ?? "—");

  const esc = (s) => String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");

  const fmt = (v) => {
    if (v === null || v === undefined) return { html:`<span class="resp-snap-null">null</span>`, plain:"null" };
    if (typeof v === "boolean") {
      return {
        html: `<span class="resp-bool ${v ? "resp-bool-true" : "resp-bool-false"}">${v}</span>`,
        plain: String(v)
      };
    }
    if (Array.isArray(v)) {
      const p = v.map(x => (x === null || x === undefined) ? "null" : String(x));
      const plain = p.join(", ");
      return { html: esc(plain), plain };
    }
    if (typeof v === "object") {
      const plain = JSON.stringify(v);
      return { html: `<span class="resp-snap-null">${esc(plain)}</span>`, plain };
    }
    const plain = String(v);
    return { html: esc(plain), plain };
  };

  const flatten = (obj, prefix = "", out = [], depth = 0) => {
    if (!obj || typeof obj !== "object") return out;
    for (const [k,v] of Object.entries(obj)){
      const key = prefix ? `${prefix}.${k}` : k;
      const isObj = v && typeof v === "object" && !Array.isArray(v);
      if (isObj && depth < 2) flatten(v, key, out, depth+1);
      else out.push([key, v]);
    }
    return out;
  };

  // prioridades p/ ficar "na cara" primeiro
  const P_PANEL  = ["symbol","timeframe","session","flow_label","status.label","updated_at","price_now","last_price","reference_price"];
  const P_UI     = ["confidence_pct","confidence_label","headline","structure_line","tactical_line","market_structure_line","pullback_line","detector_key","price_now"];
  const P_DIGEST = [
    "shape_focus.pattern_id","shape_focus.label","shape_focus.name_pt","shape_focus.family_en",
    "shape_focus.bias","shape_focus.direction","shape_focus.confidence_pct",
    "sr_proxy.recent_high","sr_proxy.recent_low","intraday_bars","features_true","price_now"
  ];

  const renderCol = (title, obj, priorities, el) => {
    const rows = flatten(obj);

    // mapa p/ ordenar prioridades
    const idx = new Map();
    priorities.forEach((k,i)=> idx.set(k, i));

    rows.sort((a,b)=>{
      const ak = a[0], bk = b[0];
      const ai = idx.has(ak) ? idx.get(ak) : 9999;
      const bi = idx.has(bk) ? idx.get(bk) : 9999;
      if (ai !== bi) return ai - bi;
      return ak.localeCompare(bk);
    });

    const prev = window.__RESP_SNAP_PREV__ || {};
    const next = {};

    let html = "";
    for (const [k,v] of rows){
      const { html:vh, plain:vp } = fmt(v);
      const keyFull = `${title}.${k}`;
      const was = prev[keyFull];
      const changed = (was !== undefined && was !== vp);
      next[keyFull] = vp;

      const strong = idx.has(k) ? "resp-snap-strong" : "";
      const flash  = changed ? "resp-snap-flash" : "";

      html += `
        <div class="resp-snap-row ${strong} ${flash}">
          <div class="resp-snap-key">${esc(k)}</div>
          <div class="resp-snap-val">${vh}</div>
        </div>
      `;
    }

    window.__RESP_SNAP_PREV__ = { ...prev, ...next };
    el.innerHTML = html || "—";
  };

  renderCol("panel",  panel,  P_PANEL,  elPanel);
  renderCol("ui",     ui,     P_UI,     elUI);
  renderCol("digest", digest, P_DIGEST, elDigest);
}

function escapeHtml(v){
  const s = (v===null || v===undefined) ? "" : String(v);
  return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function safe(v, fallback="—"){
  return (v===null || v===undefined || v==="") ? fallback : String(v);
}
function mapDir(dir){
  const d = String(dir||"").toLowerCase();
  if (d==="up" || d==="bull" || d==="long") return "COMPRA";
  if (d==="down" || d==="bear" || d==="short") return "VENDA";
  if (!d) return "—";
  return d.toUpperCase();
}

// <<< isso cria um “resumo” DENTRO do trade card (sem aquele grid de cards)
function ensureRespInlineSlot(){
  const anchor = document.getElementById("resp-snap-msg") || document.getElementById("resp-out-panel");
  if (!anchor || !anchor.parentElement) return null;

  let box = document.getElementById("resp-inline");
  if (box) return box;

  box = document.createElement("div");
  box.id = "resp-inline";
  box.style.margin = "10px 0 6px 0";
  box.style.padding = "10px 12px";
  box.style.border = "1px solid rgba(255,255,255,.08)";
  box.style.borderRadius = "12px";
  box.style.background = "rgba(10,14,22,.35)";

  anchor.parentElement.insertBefore(box, anchor);
  return box;
}

function renderResponderInline(data){
  const box = ensureRespInlineSlot();
  if (!box) return;

  const ui = data?.ui || {};
  const digest = data?.digest || {};
  const sf = digest?.shape_focus || {};
  const sr = digest?.sr_proxy || {};

  const conf = safe(ui.confidence_label || (sf.confidence_pct!=null ? `${sf.confidence_pct}%` : ""), "—");

  box.innerHTML = `
    <div style="font-weight:700; letter-spacing:.14em; font-size:10px; opacity:.85; margin-bottom:6px;">
      RESPONDER
    </div>
    <div style="font-size:12px; line-height:1.35;">
      <div><span style="opacity:.7;">Pattern:</span> ${escapeHtml(safe(ui.headline || sf.label))}</div>
      <div><span style="opacity:.7;">Bias:</span> ${escapeHtml(safe(sf.bias))} · <span style="opacity:.7;">Dir:</span> ${escapeHtml(mapDir(sf.direction))} · <span style="opacity:.7;">Conf:</span> ${escapeHtml(conf)}</div>
      <div><span style="opacity:.7;">Estrutura:</span> ${escapeHtml(safe(ui.market_structure_line))}</div>
      <div><span style="opacity:.7;">Pullback:</span> ${escapeHtml(safe(ui.pullback_line))}</div>
      <div><span style="opacity:.7;">SR:</span> H ${escapeHtml(safe(sr.recent_high))} · L ${escapeHtml(safe(sr.recent_low))} · <span style="opacity:.7;">Bars:</span> ${escapeHtml(safe(digest.intraday_bars || ""))}</div>
    </div>
  `;
}
// ===== PREMONIÇÃO: CTA filtrado (AÇÃO + Micro >= 70%) =====
let __A10_PREM_MICRO_PCT = null;
let __A10_PREM_ACAO = null;
let __A10_PREM_CONTINUACAO = null; // NEW: p/ "continuação comprado/vendido"
const A10_PREM_MICRO_GATE_PCT = 70;


function a10UpdatePremSignalCTA(){
  const btn  = document.getElementById("prem-signal-btn");
  const hint = document.getElementById("prem-signal-hint");
  if (!btn) return;

  const micro = (__A10_PREM_MICRO_PCT != null && isFinite(Number(__A10_PREM_MICRO_PCT)))
    ? Number(__A10_PREM_MICRO_PCT)
    : null;

    const acao = (__A10_PREM_ACAO != null) ? String(__A10_PREM_ACAO).trim() : "";
  const up   = acao.toUpperCase();

  const cont = (__A10_PREM_CONTINUACAO != null) ? String(__A10_PREM_CONTINUACAO).trim() : "";
  const cup  = cont.toUpperCase();

  const isSell = /(VEND|SELL)/.test(up);
  const isBuy  = /(COMPR|BUY)/.test(up);

  // Se a própria AÇÃO vier como "continuação de compra/venda"
  const acaoIsCont = /(CONTINU|CONTINUA)/.test(up);

  // Continuação pode vir do campo CONTINUAÇÃO (ou da própria AÇÃO)
  const contIsBuy  = (acaoIsCont && isBuy)  || /(COMPRA|COMPRAR|BUY)/.test(cup);
  const contIsSell = (acaoIsCont && isSell) || /(VENDA|VENDER|SELL)/.test(cup);

  const passMicro = (micro != null && micro >= A10_PREM_MICRO_GATE_PCT);

  let side = "";
  let label = "NÃO FAÇA NADA";

  // 1) BUY/SELL "puro" só se Micro >= gate
  const pureSell = isSell && !acaoIsCont;
  const pureBuy  = isBuy  && !acaoIsCont;

  if (passMicro && pureSell){ side = "sell"; label = "VENDER"; }
  else if (passMicro && pureBuy){ side = "buy"; label = "COMPRAR"; }

  // 2) Continuação: mostra sempre o texto; habilita só se Micro >= gate
  else if (contIsSell){
    label = "CONTINUAÇÃO VENDIDO";
    if (passMicro) side = "sell";
  } else if (contIsBuy){
    label = "CONTINUAÇÃO COMPRADO";
    if (passMicro) side = "buy";
  }



  btn.textContent = label;
  btn.disabled = !side;
  btn.dataset.side = side;

  btn.classList.remove("prem-signal-buy","prem-signal-sell","prem-signal-off");
  btn.classList.add(side === "sell" ? "prem-signal-sell" : side === "buy" ? "prem-signal-buy" : "prem-signal-off");

    if (hint){
    const microTxt = (micro != null) ? `${Math.round(micro)}%` : "—";
    const contTxt  = cont ? ` • CONT=${cont}` : "";
    hint.textContent = `Filtro: AÇÃO=${acao || "—"}${contTxt} • Micro=${microTxt} (≥${A10_PREM_MICRO_GATE_PCT}%)`;
  }


  // click -> arma autopilot (se existir)
  if (!btn.__a10Bound){
    btn.__a10Bound = true;
    btn.addEventListener("click", () => {
      const s = String(btn.dataset.side || "");
      if (!s) return;
      try{
        if (typeof arm === "function") arm(s);
        else if (typeof apArmFromButton === "function") apArmFromButton(s);
        else if (typeof apActivate === "function") apActivate(s);
      }catch(_){}
    });
  }
}
/* ================== EXEC GATE (Micro) · Sizing 3 contas ================== */
function a10UpdateExecGateMicroSizing(payload, opts){
  try{
    a10InitExecGateMicroSizing();

    const panel  = payload?.panel  || payload || {};
    const ui     = payload?.ui     || {};
    const digest = payload?.digest || {};

    const num = (...vals) => {
      for (const v of vals){
        if (v === null || v === undefined) continue;
        const n = Number(v);
        if (Number.isFinite(n)) return n;
      }
      return null;
    };

    const setTxt = (id, v) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = (v === null || v === undefined || v === "") ? "—" : String(v);
    };

    const fmt2 = (n) => (Number.isFinite(Number(n)) ? Number(n).toFixed(2) : "—");
    const fmtInt = (n) => (Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString("en-US") : "—");

    // Current Price (mesma lógica do premonition)
    const currentPx = num(
      panel.price_now, panel.last_price,
      ui.price_now, ui.last_price,
      digest.price_now, digest.last_price, digest.price
    );

    // Micro Take (target) vem do updatePremonitionPanel (kpiPriceNum)
    const microTake = num(
      opts?.microTake,
      digest.micro_target, digest.micro_take,
      digest.micro?.target, digest.micro?.take
    );

        // ATR14 (tenta pegar do digest; fallback: inputs existentes)
    const atr14 = num(
      panel.atr14, panel.atr_14,
      panel.indicators?.atr14, panel.indicators?.ATR14,
      panel.metrics?.atr14,

      ui.atr14, ui.atr_14,
      ui.indicators?.atr14, ui.indicators?.ATR14,
      ui.metrics?.atr14,

      digest.atr14, digest.atr_14,
      digest.indicators?.atr14, digest.indicators?.ATR14,
      digest.metrics?.atr14,

      document.getElementById("sb-atr-value")?.value,
      document.getElementById("atr-value-input")?.value
    );


    // Custos (defaults que batem com seu exemplo: 0.01 + 0.01 + 0.06 = 0.08)
    const spread  = num(digest.spread,  digest.costs?.spread,  panel.spread,  ui.spread)  ?? 0.01;
    const slip    = num(digest.slippage,digest.costs?.slippage,panel.slippage,ui.slippage)?? 0.01;
    const margin  = num(digest.margin_min, digest.margem_min, digest.costs?.margin_min, digest.costs?.margem_min) ?? 0.06;

    const minMove = Number(spread) + Number(slip) + Number(margin);
    const dist    = (currentPx != null && microTake != null) ? Math.abs(Number(microTake) - Number(currentPx)) : null;
    const edgeOk  = (dist != null && Number.isFinite(Number(minMove))) ? (Number(dist) >= Number(minMove)) : false;

    // Prob / ETA
    const prob = (window.__A10_PREM_MICRO_PCT != null && Number.isFinite(Number(window.__A10_PREM_MICRO_PCT)))
      ? Number(window.__A10_PREM_MICRO_PCT)
      : num(opts?.microProb, digest.micro_prob, digest.prob_micro);

    const etaMin = num(opts?.etaMin, digest.micro_eta_min, digest.eta_micro_min);

    // Top KPIs
    setTxt("eg-atr14",   (atr14 != null) ? fmt2(atr14) : "—");
    setTxt("eg-minmove", (Number.isFinite(Number(minMove))) ? fmt2(minMove) : "—");
    setTxt("eg-dist",    (dist != null) ? fmt2(dist) : "—");

    const edgeWrap = document.querySelector("#exec-gate .eg-edge");
    const edgeVal  = document.getElementById("eg-edge");
    if (edgeWrap) {
      edgeWrap.classList.toggle("is-ok", !!edgeOk);
      edgeWrap.classList.toggle("is-no", !edgeOk);
    }
    if (edgeVal) edgeVal.textContent = edgeOk ? "OK ✅" : "NO ⚠️";

    setTxt("eg-micro-take", (microTake != null) ? fmt2(microTake) : "—");
    setTxt("eg-micro-prob", (prob != null && Number.isFinite(Number(prob))) ? `${Math.round(Number(prob))}%` : "—");
    setTxt("eg-micro-eta",  (etaMin != null && Number.isFinite(Number(etaMin))) ? `~${Math.round(Number(etaMin))}m` : "—");

    // guarda contexto e calcula tabela
    window.__A10_EG_CTX = {
      currentPx,
      microTake,
      atr14,
      minMove,
      dist,
      edgeOk
    };

    a10CalcExecGateSizing();
  }catch(_e){
    // não quebra UI
  }
}

function a10InitExecGateMicroSizing(){
  if (window.__A10_EG_INIT) return;
  window.__A10_EG_INIT = true;

  const gate   = document.getElementById("exec-gate");
  const btn1   = document.getElementById("eg-mode-1");
  const btn3   = document.getElementById("eg-mode-3");

  const setMode = (mode) => {
    if (!gate) return;
    const one = (mode === "1");
    gate.classList.toggle("eg-1line", one);
    if (btn1) btn1.classList.toggle("is-on", one);
    if (btn3) btn3.classList.toggle("is-on", !one);
    a10CalcExecGateSizing();
  };

  if (btn1) btn1.addEventListener("click", () => setMode("1"));
  if (btn3) btn3.addEventListener("click", () => setMode("3"));
  setMode("1");

  const stopMode  = document.getElementById("eg-stop-mode");
  const stopAtr   = document.getElementById("eg-stop-atr-mult");
  const stopCents = document.getElementById("eg-stop-cents");

  const syncStopUI = () => {
    const m = stopMode ? stopMode.value : "atr";
    if (stopAtr)   stopAtr.style.display   = (m === "atr") ? "" : "none";
    if (stopCents) stopCents.style.display = (m === "cents") ? "" : "none";
    a10CalcExecGateSizing();
  };

  if (stopMode)  stopMode.addEventListener("change", syncStopUI);
  if (stopAtr)   stopAtr.addEventListener("input", a10CalcExecGateSizing);
  if (stopCents) stopCents.addEventListener("input", a10CalcExecGateSizing);

  ["eg-riskpct","eg-acct-1","eg-acct-2","eg-acct-3"].forEach((id) => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("input", a10CalcExecGateSizing);
  });

  syncStopUI();
}

function a10CalcExecGateSizing(){
  try{
    const ctx = window.__A10_EG_CTX || {};
    const dist   = (ctx.dist != null) ? Number(ctx.dist) : null;
    const atr14  = (ctx.atr14 != null) ? Number(ctx.atr14) : null;
    const edgeOk = !!ctx.edgeOk;

    const num = (v) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    const fmt2 = (n) => (Number.isFinite(Number(n)) ? Number(n).toFixed(2) : "—");
    const fmtInt = (n) => (Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString("en-US") : "—");

    const riskPct = num(document.getElementById("eg-riskpct")?.value); // ex: 0.50 = 0.50%
    const stopMode = document.getElementById("eg-stop-mode")?.value || "atr";
    const stopMult = num(document.getElementById("eg-stop-atr-mult")?.value); // ex: 0.80
    const stopCents = num(document.getElementById("eg-stop-cents")?.value);   // ex: 0.31

    let stopDist = null;
    if (stopMode === "atr"){
      if (atr14 != null && stopMult != null) stopDist = atr14 * stopMult;
    } else {
      stopDist = stopCents;
    }

    const foot = document.getElementById("eg-foot");
    if (foot){
      if (dist == null || stopDist == null || stopDist <= 0){
        foot.textContent = "—";
      } else if (!edgeOk){
        foot.textContent = "NÃO COMPENSA — Dist→Micro < MinMove (evita trade curto demais).";
      } else {
        foot.textContent = "OK — Micro como TAKE (padronizado) + risco ATR (padronizado).";
      }
    }

    for (let i=1; i<=3; i++){
      const acct = num(document.getElementById(`eg-acct-${i}`)?.value);

      const riskMoney = (acct != null && riskPct != null) ? (acct * (riskPct/100)) : null;
      const shares = (riskMoney != null && stopDist != null && stopDist > 0) ? Math.floor(riskMoney / stopDist) : null;

      const rewardPerShare = (dist != null) ? dist : null; // Take = Micro ($) = distância
      const rewardMoney = (shares != null && rewardPerShare != null) ? (shares * rewardPerShare) : null;

      const rr = (rewardPerShare != null && stopDist != null && stopDist > 0) ? (rewardPerShare / stopDist) : null;
      const stopATR = (stopDist != null && atr14 != null && atr14 > 0) ? (stopDist / atr14) : null;

      const row = document.getElementById(`eg-row-${i}`);
      if (row) row.classList.toggle("eg-row-off", !edgeOk);

      const acctTxt = document.getElementById(`eg-acct-txt-${i}`);
      if (acctTxt) acctTxt.textContent = (acct != null) ? acct.toLocaleString("en-US") : "—";

      const rpTxt = document.getElementById(`eg-riskpct-txt-${i}`);
      if (rpTxt) rpTxt.textContent = (riskPct != null) ? `${riskPct.toFixed(2)}%` : "—";

      const set = (id, v) => {
        const el = document.getElementById(id);
        if (!el) return;
        el.textContent = (v === null || v === undefined) ? "—" : String(v);
      };

      set(`eg-shares-${i}`,    (shares != null) ? shares.toLocaleString("en-US") : "—");
      set(`eg-stopusd-${i}`,   (stopDist != null) ? fmt2(stopDist) : "—");
      set(`eg-stopatr-${i}`,   (stopATR != null) ? `${stopATR.toFixed(2)} ATR` : "—");
      set(`eg-riskusd-${i}`,   (riskMoney != null) ? fmtInt(riskMoney) : "—");
      set(`eg-takeusd-${i}`,   (rewardPerShare != null) ? fmt2(rewardPerShare) : "—");
      set(`eg-rewardusd-${i}`, (rewardMoney != null) ? fmtInt(rewardMoney) : "—");
      set(`eg-rr-${i}`,        (rr != null) ? rr.toFixed(2) : "—");
    }
  }catch(_e){
    // não quebra UI
  }
}
/* ================== FIM EXEC GATE (Micro) ================== */

function a10UpdatePremBreakoutBox(digest){
  const wrap = document.getElementById("prem-breakout-wrap");
  if (!wrap) return;

  const f  = (digest && typeof digest === "object") ? (digest.features || {}) : {};
  const sr = (digest && typeof digest === "object") ? (digest.sr_proxy  || {}) : {};

  const bUp = !!f.breakout_up;
  const bDn = !!f.breakout_down;

  const rUp = !!f.breakout_up_with_retest;
  const rDn = !!f.breakout_down_with_retest;

  const cUp = !!f.breakout_up_with_retest_confirmed;
  const cDn = !!f.breakout_down_with_retest_confirmed;

  const set = (id, val) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = (val === null || val === undefined || val === "") ? "—" : String(val);
  };

  const fmt2 = (n) => (typeof n === "number" && isFinite(n)) ? n.toFixed(2) : (n ?? "—");

  let dir = "";
  if (bUp && bDn) dir = "MIX";
  else if (bUp) dir = "UP";
  else if (bDn) dir = "DOWN";

  let retDir = "";
  if (rUp && rDn) retDir = "MIX";
  else if (rUp) retDir = "UP";
  else if (rDn) retDir = "DOWN";

  let confDir = "";
  if (cUp && cDn) confDir = "MIX";
  else if (cUp) confDir = "UP";
  else if (cDn) confDir = "DOWN";

  set("prem-breakout-status", dir ? `YES (${dir})` : "NO");
  set("prem-retest-status",   retDir ? `YES (${retDir})` : "NO");
  set("prem-retest-confirm",  confDir ? `YES (${confDir})` : "NO");

  const lvl = (sr.breakout_level != null && isFinite(Number(sr.breakout_level))) ? Number(sr.breakout_level) : null;
  set("prem-breakout-level", (lvl != null) ? fmt2(lvl) : "—");

  const note =
    confDir ? `Retest confirmado • dir=${sr.direction || confDir}${(lvl!=null)?` • nível=${fmt2(lvl)}`:""}` :
    retDir  ? `Retest detectado • dir=${sr.direction || retDir}${(lvl!=null)?` • nível=${fmt2(lvl)}`:""}` :
    dir     ? `Breakout detectado • dir=${sr.direction || dir}${(lvl!=null)?` • nível=${fmt2(lvl)}`:""}` :
    (lvl!=null) ? `Nível SR proxy: ${fmt2(lvl)} • dir=${sr.direction || "—"}` :
    "Sem setup de breakout agora";

  set("prem-breakout-note", note);
}
function a10UpdateMicroTimeline(payload, opts = {}){
  try{
    const panel  = payload?.panel || payload || {};
    const digest = payload?.digest || {};
    const ui     = payload?.ui || {};

    const bw =
      opts.bw ||
      digest.breakout_window_card || panel.breakout_window_card ||
      digest.breakout_window || panel.breakout_window ||
      null;

    const setHTML = (id, html) => {
      const el = document.getElementById(id);
      if (el) el.innerHTML = (html === null || html === undefined || html === "") ? "—" : String(html);
    };

    const esc = (s) => String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");

    const num = (v) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    const fmt2 = (n) => (n == null ? "—" : Number(n).toFixed(2));
    const fmtPct = (n) => (n == null ? "—" : `${Math.round(Number(n))}%`);
    const fmtMin = (n) => (n == null ? "—" : `~${Math.round(Number(n))}m`);

    // CURRENT PRICE (prioridade: opts -> payload -> UI)
    const currentPx =
      num(opts.currentPx) ??
      num(panel.price_now) ?? num(ui.price_now) ?? num(digest.price_now) ??
      num(document.getElementById("prem-head-current-price")?.textContent) ??
      null;

    const currentPxTxt = (currentPx != null) ? fmt2(currentPx) : "—";

    // ===== FUTURE (NEXT) =====
    const futureTarget = num(bw?.trigger_price);
    const futureProb   = num(bw?.prob_until_end_pct);
    const futureEta    = num(bw?.median_minutes);
    const futureArrow  = (bw?.dir === "DOWN") ? "↓" : (bw?.dir === "UP") ? "↑" : "→";
    const futureArrowCls = (futureArrow === "↑") ? "mt-up" : (futureArrow === "↓") ? "mt-down" : "mt-muted";

    const futureHtml = (futureTarget != null || futureProb != null || futureEta != null)
      ? `<span class="mt-muted">${esc(fmtMin(futureEta))}</span> • <span class="mt-muted">${esc(fmtPct(futureProb))}</span> • Target <span class="mt-target">${esc(fmt2(futureTarget))}</span> <span class="${futureArrowCls}">${futureArrow}</span>`
      : "—";

    setHTML("mt-future", futureHtml);

    // ===== MICRO LIVE — NOW =====
    const microTarget =
      num(opts.microTarget) ??
      num(digest.micro_target) ?? num(digest.micro_take) ??
      num(panel.micro_target) ?? num(panel.micro_take) ??
      null;

    const microProb =
      num(opts.microProb) ??
      num(digest.micro_prob_pct) ?? num(panel.micro_prob_pct) ??
      (window.__A10_PREM_MICRO_PCT != null ? num(window.__A10_PREM_MICRO_PCT) : null);

    const microEta =
      num(opts.microEtaMin) ??
      num(digest.micro_eta_min) ?? num(digest.eta_micro_min) ??
      num(panel.micro_eta_min) ?? num(panel.eta_micro_min) ??
      num(opts.etaMin) ??
      null;

    const microArrow = (microTarget != null && currentPx != null)
      ? (microTarget > currentPx ? "↑" : (microTarget < currentPx ? "↓" : "→"))
      : "→";
    const microArrowCls = (microArrow === "↑") ? "mt-up" : (microArrow === "↓") ? "mt-down" : "mt-muted";

    const microNowHtml = (microTarget != null || microProb != null || microEta != null)
      ? `<span class="mt-muted">${esc(fmtMin(microEta))}</span> • <span class="mt-muted">${esc(fmtPct(microProb))}</span> • Target <span class="mt-target">${esc(fmt2(microTarget))}</span> <span class="${microArrowCls}">${microArrow}</span>`
      : "—";

    setHTML("mt-micro-now", microNowHtml);

    // ===== MICRO LIVE — MAX (tracking) =====
    const nowMs = Date.now();

    if (microTarget != null && currentPx != null){
      const dirKey = (microArrow === "↓") ? "down" : (microArrow === "↑") ? "up" : "flat";
      const max = window.__A10_MICRO_LIVE_MAX__ || null;

      const better =
        !max ||
        max.dir !== dirKey ||
        (dirKey === "up"   && microTarget > max.target) ||
        (dirKey === "down" && microTarget < max.target) ||
        (dirKey === "flat" && microProb != null && microProb > (max.prob ?? -1));

      if (better){
        window.__A10_MICRO_LIVE_MAX__ = {
          dir: dirKey,
          target: microTarget,
          prob: microProb,
          eta: microEta,
          seenAt: nowMs
        };
      }
    }

    const fmtAgo = (ms) => {
      const s = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(s / 60);
      const r = s % 60;
      if (m <= 0) return `${r}s`;
      return `${m}m${String(r).padStart(2,"0")}s`;
    };

    const max = window.__A10_MICRO_LIVE_MAX__ || null;
    if (max && max.target != null){
      const age = fmtAgo(nowMs - (max.seenAt ?? nowMs));
      const arrow = (max.dir === "down") ? "↓" : (max.dir === "up") ? "↑" : "→";
      const arrowCls = (arrow === "↑") ? "mt-up" : (arrow === "↓") ? "mt-down" : "mt-muted";

      const maxHtml =
        `<span class="mt-target">${esc(fmt2(num(max.target)))}</span> <span class="${arrowCls}">${arrow}</span>` +
        ` • <span class="mt-muted">${esc(fmtPct(num(max.prob)))}</span>` +
        ` • <span class="mt-muted">${esc(fmtMin(num(max.eta)))}</span>` +
        ` • <span class="mt-muted">há ${esc(age)}</span>`;

      setHTML("mt-micro-max", maxHtml);
    } else {
      setHTML("mt-micro-max", "—");
    }

    // ===== CURRENT =====
    const timeStr = (() => {
      try{
        return new Date().toLocaleTimeString("en-US", {
          hour:"numeric", minute:"2-digit", hour12:true, timeZone:"America/Denver"
        });
      }catch(_e){
        return new Date().toLocaleTimeString("en-US", { hour:"numeric", minute:"2-digit", hour12:true });
      }
    })();

    setHTML("mt-current", `<span class="mt-target">${esc(currentPxTxt)}</span> • <span class="mt-muted">${esc(timeStr)}</span>`);

    // ===== PAST (retest / SR proxy) =====
    const sf = digest.shape_focus || {};
    const sr = digest.sr_proxy || {};
    const f  = digest.features || {};

    const conf = num(sf.confidence_pct) ?? num(ui.confidence_pct);
    const lvl  = num(sr.breakout_level);
    const low  = num(sr.recent_low);
    const high = num(sr.recent_high);

    const retUp  = !!f.breakout_up_with_retest;
    const retDn  = !!f.breakout_down_with_retest;
    const confUp = !!f.breakout_up_with_retest_confirmed;
    const confDn = !!f.breakout_down_with_retest_confirmed;

    let pastLabel = "SR";
    if (confUp || confDn) pastLabel = "Retest confirmado";
    else if (retUp || retDn) pastLabel = "Retest";

    const pastLevelTxt =
      (lvl != null) ? fmt2(lvl) :
      ((low != null || high != null) ? `${fmt2(low)} — ${fmt2(high)}` : "—");

    const pastHtml =
      `${esc(pastLabel)} <span class="mt-target">${esc(pastLevelTxt)}</span>` +
      (conf != null ? ` • <span class="mt-muted">${esc(fmtPct(conf))}</span>` : "");

    setHTML("mt-past", pastHtml);

  }catch(_e){
    // não quebra UI
  }
}

function updatePremonitionPanel(payload){
  try{
    const panel  = payload?.panel  || payload || {};
    const ui     = payload?.ui     || {};
    const digest = payload?.digest || {};

    const lang = (typeof currentLang !== "undefined" && currentLang === "en") ? "en" : "pt";

    const pickFirst = (...vals) => {
      for (const v of vals){
        if (v === null || v === undefined) continue;
        const s = String(v).trim();
        if (s) return v;
      }
      return null;
    };
const fmtMT = (d) => {
  try {
    return d.toLocaleTimeString('en-US', {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZone: 'America/Denver'
    });
  } catch (_) {
    return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
  }
};

const extractPct = (txt) => {
  const m = String(txt || "").match(/(\d{1,3})\s*%/);
  if (!m) return null;
  const n = Number(m[1]);
  return (Number.isFinite(n) && n >= 0 && n <= 100) ? n : null;
};

    const splitTimeLabel = (label) => {
      const s = String(label || "").trim();
      // aceita "11:56 AM" ou "11:56"
      const m = s.match(/^(\d{1,2}:\d{2})\s*(AM|PM)?$/i);
      if (!m) return { hhmm: s || "—", ampm: "" };
      return { hhmm: m[1], ampm: (m[2] || "").toUpperCase() };
    };

    const extractMinutes = (txt) => {
      const s = String(txt || "");
      const m = s.match(/~\s*(\d+(?:\.\d+)?)\s*(min|mins|minutes|minutos)/i);
      if (!m) return null;
      const n = Number(m[1]);
      return isFinite(n) ? n : null;
    };

    const setText = (id, v) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = (v === null || v === undefined || v === "") ? "—" : String(v);
    };

    // pega macro/micro (PT/EN)
    const macro = pickFirst(
      (lang === "en") ? ui.premonicao_macro_en : ui.premonicao_macro_pt,
      (lang === "en") ? panel.premonicao_macro_en : panel.premonicao_macro_pt,
      (lang === "en") ? digest.premonicao_macro_en : digest.premonicao_macro_pt,
      ui.premonicao_macro_pt, panel.premonicao_macro_pt, digest.premonicao_macro_pt,
      ui.premonicao_macro_en, panel.premonicao_macro_en, digest.premonicao_macro_en
    );

    const micro = pickFirst(
      (lang === "en") ? ui.premonicao_micro_en : ui.premonicao_micro_pt,
      (lang === "en") ? panel.premonicao_micro_en : panel.premonicao_micro_pt,
      (lang === "en") ? digest.premonicao_micro_en : digest.premonicao_micro_pt,
      ui.premonicao_micro_pt, panel.premonicao_micro_pt, digest.premonicao_micro_pt,
      ui.premonicao_micro_en, panel.premonicao_micro_en, digest.premonicao_micro_en
    );

        let macroTxt = macro;
    let microTxt = micro;

    // breakout window card (estruturado)
        let bw = pickFirst(ui.breakout_window_card, panel.breakout_window_card, digest.breakout_window_card);


            // ✅ DEMO quando não houver dados (sistema OFF / vazio)
    const A10_PREM_DEMO_WHEN_EMPTY = true;

    if (A10_PREM_DEMO_WHEN_EMPTY) {
      const hasBW = bw && (
        bw.prob_until_end_pct != null ||
        bw.window_end_label ||
        bw.trigger_price != null
      );

      if (!hasBW) {
        const now = new Date();

        const fmtMT = (d) => {
          try {
            return d.toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
              timeZone: 'America/Denver'
            });
          } catch (_) {
            return d.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
          }
        };

        const end   = new Date(now.getTime() + 2 * 60 * 1000);
        const start = new Date(now.getTime() - 26 * 60 * 1000);

        bw = {
          dir: "DOWN",
          prob_until_end_pct: 81,
          window_start_label: fmtMT(start),
          window_end_label: fmtMT(end),
          median_minutes: 2,
          miss_line: "Se tentar cair perto das 12:00: Prob. cai para 47%",
          n_total: 444,
          confidence: "LOW confidence",
          source: "DEMO",
          score: 0.88,
          trigger_price: 100 // depois o canvas ajusta para o preço atual se precisar
        };


        if (!macroTxt) macroTxt = "PREMONIÇÃO MACRO (DEMO): tendência de baixa — ETA ~17 min.";
        if (!microTxt) microTxt = "PREMONIÇÃO MICRO (DEMO): queda rápida — ETA ~2 min.";
      }
    }

// ETA (min) — precisa existir ANTES do painel direito usar
let etaMin = extractMinutes(microTxt);   // MICRO primeiro
if (etaMin == null && bw?.median_minutes != null && isFinite(Number(bw.median_minutes))) {
  etaMin = Number(bw.median_minutes);   // fallback
}
if (etaMin == null) etaMin = extractMinutes(macroTxt); // último fallback (se quiser)


    const dir = String(bw?.dir || "").toUpperCase();
    const verbPT = (dir === "DOWN") ? "cair" : (dir === "UP") ? "subir" : "romper";
    const verbEN = (dir === "DOWN") ? "drop" : (dir === "UP") ? "rise" : "break";

    const microPct = extractPct(microTxt);
    // alimenta CTA (micro %)
const microGatePct = (microPct != null)
  ? microPct
  : ((bw?.prob_until_end_pct != null) ? Number(bw.prob_until_end_pct) : null);

__A10_PREM_MICRO_PCT = (microGatePct != null && isFinite(Number(microGatePct)))
  ? Number(microGatePct)
  : null;

a10UpdatePremSignalCTA();
try{
  if (typeof a10UpdatePremBreakoutBox === "function"){
    a10UpdatePremBreakoutBox(digest);
  }
}catch(_e){}

const prob = (microPct != null)

  ? `${microPct}%`
  : (bw?.prob_until_end_pct != null ? `${bw.prob_until_end_pct}%` : "—");

// **HORÁRIO DO KPI = AGORA + ETA DO MICRO**
const tLab = (etaMin != null)
  ? fmtMT(new Date(Date.now() + Number(etaMin) * 60 * 1000))
  : "—";

const t = splitTimeLabel(tLab);

// ✅ KPI: depois da % mostrar preço + minutos (mesma linha)
const kpiPriceNum = (() => {
  const s = String(microTxt || "");
  // tenta pegar preço depois de "tocar/touch/High/Low"
  let m = s.match(/(?:tocar|touch|High|Low)\s*\$?\s*(\d{1,6}(?:[.,]\d{1,6})?)/i);
  if (!m) m = s.match(/(\d{1,6}[.,]\d{1,6})/); // pega o 1º com decimal (evita 88%)
  if (!m) return null;
  const n = Number(String(m[1]).replace(",", "."));
  return isFinite(n) ? n : null;
})() ?? ((bw?.trigger_price != null && isFinite(Number(bw.trigger_price))) ? Number(bw.trigger_price) : null);


const kpiPriceTxt = (kpiPriceNum != null) ? kpiPriceNum.toFixed(2) : null;
const kpiMinTxt   = (etaMin != null && isFinite(Number(etaMin))) ? `(~${Math.round(Number(etaMin))}m)` : null;

// Ex: "88% 186.03 (~1m)"
const probLine = `${prob}${kpiPriceTxt ? ` ${kpiPriceTxt}` : ""}${kpiMinTxt ? ` ${kpiMinTxt}` : ""}`;



    setText("prem-kpi-label", (lang === "en") ? `Prob. ${verbEN} by` : `Prob. ${verbPT} até`);
    setText("prem-kpi-time", t.hhmm || "—");
    setText("prem-kpi-ampm", t.ampm || "");
    (document.getElementById("prem-kpi-prob") || {}).innerHTML = prob + (kpiPriceTxt ? ' <span class="pulse-micro" style="color:var(--success)">' + kpiPriceTxt + '</span>' : '') + (kpiMinTxt ? ' ' + kpiMinTxt : '');

    // espelha KPI grande no painel direito (mockup)
    setText("prem-right-title", (lang === "en") ? `Prob. ${verbEN} by` : `Prob. ${verbPT} até`);
        // ✅ Current Price (preço atual do ativo)
    const currentPxRaw = pickFirst(
      panel.price_now, panel.last_price,
      ui.price_now, ui.last_price,
      digest.price_now, digest.last_price, digest.price
    );
    const currentPxTxt = (currentPxRaw != null && isFinite(Number(currentPxRaw)))
      ? Number(currentPxRaw).toFixed(2)
      : "—";
    setText("prem-right-current-price", currentPxTxt);
    setText("prem-head-current-price", currentPxTxt);
    setText("prem-chart-current-price", currentPxTxt);

    setText("prem-right-time", t.hhmm || "—");
    setText("prem-right-ampm", t.ampm || "");
    (document.getElementById("prem-right-prob") || {}).innerHTML = prob + (kpiPriceTxt ? ' <span class="pulse-micro" style="color:var(--success)">' + kpiPriceTxt + '</span>' : '') + (kpiMinTxt ? ' ' + kpiMinTxt : '');
    setText("prem-right-eta", (etaMin != null) ? ((lang==="en") ? `In ~${Math.round(etaMin)} min` : `Em ~${Math.round(etaMin)} min`) : "—");


    const wLine = (bw?.window_start_label || bw?.window_end_label)
      ? `${bw.window_start_label || "—"} – ${bw.window_end_label || "—"} (MT)`
      : "—";
    setText("prem-window", wLine);

    const mLine = (bw?.median_minutes != null && isFinite(Number(bw.median_minutes)))
      ? `${Math.round(Number(bw.median_minutes))} min (mediana)`
      : "—";
    setText("prem-median", mLine);

    setText("prem-miss", bw?.miss_line || "—");
        setText("prem-macro", macroTxt || "—");
    setText("prem-micro", microTxt || "—");
    try{ a10UpdateExecGateMicroSizing(payload, { microTake: kpiPriceNum, etaMin }); }catch(_e){}

    const score = (payload?.digest?.shape_focus?.score ?? bw?.score);
    const nTxt = (bw?.n_total != null) ? `N=${bw.n_total}` : "N=—";
    const scTxt = (score != null && isFinite(Number(score))) ? ` (Score ${Number(score).toFixed(2)})` : "";
    const confTxt = bw?.confidence ? ` · ${bw.confidence}` : "";
    setText("prem-base", `${nTxt} casos similares${scTxt}${confTxt}`);

    const badge = bw?.source ? `${bw.source} · ${dir || "—"}` : (dir || "—");
    setText("prem-badge", badge);
    try{ a10UpdateMicroTimeline(payload, { bw, etaMin, currentPx: currentPxRaw }); }catch(_e){}

    // --------- MINI CHART (candles) + cruz X/Y ----------
    const canvas = document.getElementById("prem-canvas");
    if (canvas){
      const parent = canvas.parentElement;
      const cssW = parent ? Math.max(320, parent.clientWidth - 20) : 720;
      // deixa o quadro maior (e evita ficar esmagado)
      const cssH = 380;              // <-- aumenta aqui
// opcional: se quiser limite
// const cssH = Math.max(300, Math.min(520, 380));


      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = "100%";
      canvas.style.height = cssH + "px";
      canvas.width  = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);

            const W = cssW, H = cssH;

            // FIX: dá contraste no canvas (antes estava transparente e “sumia” no fundo)
ctx.clearRect(0, 0, W, H);
ctx.fillStyle = "rgba(0,0,0,0.55)";
ctx.fillRect(0, 0, W, H);


      // ===== TradingView-style bottom time axis + forecast candles (cirúrgico) =====
      const pad = 12;
      const axisH = 28;            // espaço reservado para horários
      const plotH = H - axisH;     // área do gráfico
      const tz = "America/Denver"; // MT

      const msOf = (v) => {
        if (v == null) return NaN;
        if (v instanceof Date) return v.getTime();
        if (typeof v === "number") {
          if (!isFinite(v)) return NaN;
          return (v > 1e12) ? v : (v > 1e9) ? v * 1000 : v;
        }
        const s = String(v).trim();
        if (!s) return NaN;
        const n = Number(s);
        if (isFinite(n)) return (n > 1e12) ? n : (n > 1e9) ? n * 1000 : n;
        const d = new Date(s);
        const ms = d.getTime();
        return isFinite(ms) ? ms : NaN;
      };

      const fmtTimeMT = (ms) => {
        try {
          return new Intl.DateTimeFormat("en-US", {
            timeZone: tz,
            hour: "numeric",
            minute: "2-digit"
          }).format(new Date(ms));
        } catch (e) {
          const d = new Date(ms);
          let hh = d.getHours();
          const mm = String(d.getMinutes()).padStart(2, "0");
          const ampm = (hh >= 12) ? "PM" : "AM";
          hh = hh % 12; if (hh === 0) hh = 12;
          return `${hh}:${mm} ${ampm}`;
        }
      };

      const roundRectPath = (x, y, w, h, r) => {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      };

      // pega candles LIVE do seu chart (se existir)
      const src = (Array.isArray(window.a10ChartCandles) && window.a10ChartCandles.length)
        ? window.a10ChartCandles
        : [];

      const N = 60;
      let candles = src.slice(-N).map(c => ({
        open:  Number(c.open ?? c.o),
        high:  Number(c.high ?? c.h),
        low:   Number(c.low  ?? c.l),
        close: Number(c.close ?? c.c),
        t:     msOf(c.t ?? c.time ?? c.timestamp ?? c.ts ?? c.datetime ?? c.date)
      })).filter(c => [c.open, c.high, c.low, c.close].every(x => isFinite(x)));

      // SEM fallback fake: só desenha quando tiver candles reais
if (!candles.length) {
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = "rgba(255,255,255,.65)";
  ctx.font = "14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Aguardando candles LIVE…", 18, 28);
  return;
}


      // garante timestamps (se vier sem tempo)
      if (!isFinite(candles[0]?.t)) {
        const now = Date.now();
        for (let i = 0; i < candles.length; i++) {
          candles[i].t = now - (candles.length - 1 - i) * 60000;
        }
      }

      // infer bar size (ms) via mediana dos deltas
      const inferBarMs = () => {
        const ts = candles.map(c => c.t).filter(x => isFinite(x));
        if (ts.length < 6) return 60000;
        const diffs = [];
        for (let i = ts.length - 1; i > 0 && diffs.length < 12; i--) {
          const d = ts[i] - ts[i - 1];
          if (d > 0 && d < 60 * 60 * 1000) diffs.push(d);
        }
        if (!diffs.length) return 60000;
        diffs.sort((a, b) => a - b);
        return diffs[Math.floor(diffs.length / 2)] || 60000;
      };
      const barMs = inferBarMs();

      const targetPrice = (bw?.trigger_price != null && isFinite(Number(bw.trigger_price)))
        ? Number(bw.trigger_price)
        : null;

      if (etaMin == null || !isFinite(Number(etaMin))) {
  etaMin = extractMinutes(microTxt) ?? null;
}
if (etaMin == null || !isFinite(Number(etaMin))) {
  etaMin = (bw?.median_minutes != null && isFinite(Number(bw.median_minutes)))
    ? Number(bw.median_minutes)
    : null;
}
if (etaMin == null || !isFinite(Number(etaMin))) {
  etaMin = extractMinutes(macroTxt) ?? 0;
}



      const lows = candles.map(c => c.low);
      const highs = candles.map(c => c.high);
      let yMin = Math.min(...lows);
      let yMax = Math.max(...highs);
      if (targetPrice != null) {
        yMin = Math.min(yMin, targetPrice);
        yMax = Math.max(yMax, targetPrice);
      }
      const span = (yMax - yMin) || 1;
      yMin -= span * 0.08;
      yMax += span * 0.08;

      const yMap = (p) => pad + (yMax - p) * (plotH - pad * 2) / (yMax - yMin);

      // grid leve (só na área do gráfico)
ctx.strokeStyle = "rgba(255,255,255,.06)";
ctx.lineWidth = 1;
for (let i = 1; i <= 4; i++) {
  const y = pad + (plotH - pad * 2) * (i / 5);
  ctx.beginPath();
  ctx.moveTo(pad, y);
  ctx.lineTo(W - pad, y);
  ctx.stroke();
}


      const futureSlots = Math.max(10, Math.round(Number(etaMin) || 0) + 6);
      const stepX = (W - pad * 2) / ((candles.length - 1) + futureSlots);
      const bodyW = Math.max(3, Math.min(10, stepX * 0.65));

      const lastMs = isFinite(candles[candles.length - 1]?.t) ? candles[candles.length - 1].t : Date.now();

      // faixa azul suave (janela futura) até o ETA
      let xT = null;
      const barsAhead = Math.max(0, Math.round(((Number(etaMin) || 0) * 60 * 1000) / barMs));
const idxEta = (candles.length - 1) + barsAhead;
xT = Math.min(W, pad + stepX * idxEta);

      const xNow = pad + stepX * (candles.length - 1);
      if (xT > xNow) {
        ctx.fillStyle = "rgba(120,170,255,.08)";
        ctx.fillRect(xNow, 0, xT - xNow, plotH);
      }

      // candles reais
      for (let i = 0; i < candles.length; i++) {
        const c = candles[i];
        const x = pad + stepX * i;

        const yO = yMap(c.open);
        const yC = yMap(c.close);
        const yH = yMap(c.high);
        const yL = yMap(c.low);

        const up = c.close >= c.open;
        const col = up ? "rgba(70,220,160,.95)" : "rgba(255,100,90,.95)";

        // wick
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, yH);
        ctx.lineTo(x, yL);
        ctx.stroke();

        // body
        ctx.fillStyle = col;
        const top = Math.min(yO, yC);
        const h = Math.max(1, Math.abs(yC - yO));
        ctx.fillRect(x - bodyW / 2, top, bodyW, h);
      }

      // ===== candles previsão (azuis) =====
const eta = Number(etaMin);
const canForecast = (targetPrice != null) && isFinite(eta) && (eta > 0);

if (canForecast) {
  const lastClose = candles[candles.length - 1].close;
  let prevClose = lastClose;

  const nF = (eta <= 6) ? Math.min(3, Math.max(1, Math.round(eta / 2))) : 1; // longo: 1 candle só

  for (let k = 1; k <= nF; k++) {
    const frac = k / nF;

    // off em BARRAS (não em minutos)
    const offBars = Math.max(1, Math.round(((k * eta * 60 * 1000) / nF) / barMs));

    const close = lastClose + (targetPrice - lastClose) * frac;
    const open  = prevClose;

    const wig = Math.max(span * 0.005, Math.abs(close - open) * 0.35);
    const high = Math.max(open, close) + wig;
    const low  = Math.min(open, close) - wig;

    const x  = pad + stepX * ((candles.length - 1) + offBars);
    const yO = yMap(open), yC = yMap(close), yH = yMap(high), yL = yMap(low);

    const col = "rgba(120,170,255,.95)";
    ctx.strokeStyle = col;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();

    ctx.fillStyle = col;
    const top = Math.min(yO, yC);
    const h = Math.max(1, Math.abs(yC - yO));
    ctx.fillRect(x - bodyW / 2, top, bodyW, h);

    prevClose = close;
  }
}


      // ✅ Premonição: BOOT DEMO (quando sistema OFF / ninguém chama updatePremonitionPanel)
// Cole ESTE BLOCO logo após o "}" de updatePremonitionPanel (linha 5111),
// e ANTES de: let __AARON_MATCHER_REQ_ID = 0; (linha 5113)
(function(){
  if (window.__A10_PREM_BOOT_DEMO__) return;
  window.__A10_PREM_BOOT_DEMO__ = true;

  const boot = () => {
    try {
      const canvas = document.getElementById("prem-canvas");
      if (!canvas) return;

      // se já chegou dado real do matcher, não sobrescreve
      const last = window.__AARON_MATCHER_LAST__;
      const hasReal =
        !!last && (
          (last.panel && Object.keys(last.panel).length) ||
          (last.ui && Object.keys(last.ui).length) ||
          (last.digest && Object.keys(last.digest).length)
        );

      if (!hasReal && typeof updatePremonitionPanel === "function") {
        updatePremonitionPanel(null); // cai no seu DEMO/fallback
      }
    } catch (e) {}
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => setTimeout(boot, 250));
  } else {
    setTimeout(boot, 250);
  }

  // tenta de novo depois (caso o canvas ainda não exista no primeiro tick)
  setTimeout(boot, 2000);
})();


      // cruz (X/Y) em amarelo
      if (targetPrice != null) {
        const yT = yMap(targetPrice);

        // linha Y (preço)
        ctx.strokeStyle = "rgba(255,204,102,.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pad, yT);
        ctx.lineTo(W - pad, yT);
        ctx.stroke();


        // linha X (tempo/ETA)
        ctx.beginPath();
        ctx.moveTo(xT, pad);
        ctx.lineTo(xT, plotH - pad);
        ctx.stroke();


        // ponto
        ctx.fillStyle = "rgba(255,204,102,.95)";
        ctx.beginPath();
        ctx.arc(xT, yT, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // ===== eixo de horário embaixo (TradingView-ish) =====
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, plotH + 0.5); ctx.lineTo(W, plotH + 0.5); ctx.stroke();

      const startMs = isFinite(candles[0]?.t) ? candles[0].t : (lastMs - (candles.length - 1) * barMs);
      const endMs = lastMs + futureSlots * barMs;
      const interval = 15 * 60 * 1000;

      ctx.font = "11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      let tick = Math.ceil(startMs / interval) * interval;
      const yLbl = H - 8;

      while (tick <= endMs) {
        const barsFromStart = (tick - startMs) / barMs;
        const x = pad + stepX * barsFromStart;
        if (x >= 0 && x <= W) {
          ctx.fillText(fmtTimeMT(tick), x, yLbl);
        }
        tick += interval;
      }

      // “pílula” do horário do ETA (ex: 11:56 AM MT)
      if (targetPrice != null && isFinite(xT)) {
        const pillMs = lastMs + Math.max(0, Number(etaMin) || 0) * barMs;
        const pillBase =
          (t && t.hhmm && t.hhmm !== "—")
            ? `${t.hhmm}${t.ampm ? ` ${t.ampm}` : ""}`
            : fmtTimeMT(pillMs);

        const pillText = `${pillBase} MT`;

        // helper: pega o primeiro valor não-vazio
function pick(obj, paths, fallback = "—") {
  for (const p of paths) {
    const v = p.split(".").reduce((a, k) => (a && a[k] !== undefined ? a[k] : undefined), obj);
    if (v !== undefined && v !== null && String(v).trim() !== "") return v;
  }
  return fallback;
}

function setText(sel, val) {
  const el = document.querySelector(sel);
  if (el) el.textContent = val ?? "—";
}

// dentro do render principal:
function renderAll(data) {
  // ✅ NÃO sobrescreve ui com matcher_ui_raw
  const ui = data.ui || data.digest || data.panel?.digest || {};
  const matcherUI = data.__matcher_ui_raw__ || data.__matcher_ui__ || {};

  // ===== TOP (respiro/reversao/acao) =====
  const topRespiro = pick(data, [
    "ui.top_respiro_ui",
    "digest.top_respiro_ui",
    "panel.digest.top_respiro_ui",
  ]);

  const topRespiroDe = pick(data, [
    "ui.top_respiro_de_ui",
    "digest.top_respiro_de_ui",
    "panel.digest.top_respiro_de_ui",
  ], "NONE");

    const respiroLine = (topRespiro === "YES")
    ? `YES (de ${topRespiroDe})`
    : ((topRespiroDe && String(topRespiroDe).trim() !== "" && String(topRespiroDe).toUpperCase() !== "NONE" && String(topRespiroDe) !== "—")
        ? `NO (de ${topRespiroDe})`
        : `NO (NONE)`);


  const topActionPT = pick(data, [
    "ui.top_action_pt",
    "digest.top_action_pt",
    "panel.digest.top_action_pt",
  ]);

  const topActionUI = pick(data, [
    "ui.top_action_ui",
    "digest.top_action_ui",
    "panel.digest.top_action_ui",
  ], "");

  const actionLine = topActionUI && topActionUI !== "—"
    ? `${topActionPT} (${topActionUI})`
    : topActionPT;

  setText("#top_respiro_value", respiroLine);
  setText("#top_action_value", actionLine);

  // ===== mantém o resto do TOP do jeito que já está =====
  // reversão (exemplo, se você já faz)
  // setText("#top_reversao_value", ...)

  // ===== TACTICAL/STRUCTURE (separado) =====
  setText("#tactical_line", matcherUI.tactical_line || ui.tactical_line || "—");
  setText("#structure_line", matcherUI.structure_line || ui.structure_line || "—");

  // ⚠️ Premonição: NÃO TOCA (não mexe)
}


        ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        const tw = ctx.measureText(pillText).width;

        const pxPad = 10;
        const ph = 20;
        const pw = tw + pxPad * 2;

        let px = xT - pw / 2;
        px = Math.max(10, Math.min(W - pw - 10, px));

        const py = plotH + 6;

        // fundo
        ctx.fillStyle = "rgba(0,0,0,.55)";
        roundRectPath(px, py, pw, ph, 10);
        ctx.fill();

        // borda
        ctx.strokeStyle = "rgba(255,255,255,.14)";
        ctx.lineWidth = 1;
        roundRectPath(px, py, pw, ph, 10);
        ctx.stroke();

        // texto
        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(pillText, px + pw / 2, py + ph / 2);
      }

    }
  }catch(e){
    // não quebra o painel por causa disso
  }
}
function updateRespiroReversaoPanel(payload){
  try{
    const lang = (typeof currentLang !== "undefined" && currentLang === "en") ? "en" : "pt";

    const panel  = payload?.panel || payload || {};
    const ui     = payload?.ui || panel?.ui || {};
    const digest = payload?.digest || panel?.digest || {};

    const pb = panel.pullback_brain || panel.pullbackBrain || panel.pullback || {};
    const rev = payload?.reversal_classifier || payload?.reversalClassifier || payload?.reversal ||
                panel?.reversal_classifier || panel?.reversalClassifier || panel?.reversal || {};

    // Fonte #1 (linha única com REGIME/RESPIRO/REVERSAO/...)
    const summary =
      ui.top_summary_pt_inline ||
      ui.top_summary_pt ||
      ui.top_summary_en ||
      ui.top_summary ||
      digest.top_summary_pt_inline ||
      digest.top_summary_pt ||
      digest.top_summary_en ||
      digest.top_summary ||
      panel.top_summary_pt_inline ||
      panel.top_summary_pt ||
      panel.top_summary_en ||
      panel.top_summary ||
      "";

    // Fonte #2 (linhas antigas)
    const line = String(
      ui.pullback_line || ui.market_structure_line || ui.tactical_line ||
      panel.pullback_line || panel.market_structure_line || panel.tactical_line ||
      ""
    );

    const src = String((summary || line || "")).trim();

    const grab = (re) => {
      if (!src) return null;
      const m = src.match(re);
      return m ? String(m[1]).trim() : null;
    };

    // Pega tudo do topo (quando existir)
    let acao = grab(/A(?:Ç|C)(?:A|Ã)O\s*:\s*([^|]+)/i);
    let respiro = grab(/RESPIR[O0]\s*:\s*([^|]+)/i);
    let reversao = grab(/REVERS(?:A|Ã)O\s*:\s*([^|]+)/i);
    let regime = grab(/REGIME\s*:\s*([^|]+)/i);
    let consolidacao = grab(/(?:CONSOLIDA(?:C|Ç)(?:A|Ã)O|RANGE)\s*:\s*([^|]+)/i);
    let continuacao = grab(/CONTINUAC(?:A|Ã)O\s*:\s*([^|]+)/i);

    // Normaliza (se alguém mandar "AÇÃO: VENDER" dentro do valor)
    if (acao) acao = String(acao).replace(/^A(?:Ç|C)(?:A|Ã)O\s*:\s*/i, "").trim();

    // >>> FIX: se o JSON já manda a ação pronta (top_action_*), ela é a fonte da verdade
const topAcao = (lang === "en")
  ? (ui.top_action_ui || ui.top_action_en || digest.top_action_ui || digest.top_action_en || panel.top_action_ui || panel.top_action_en)
  : (ui.top_action_pt || digest.top_action_pt || panel.top_action_pt);

if (topAcao && String(topAcao).trim()) acao = String(topAcao).trim();


    const stage =
      (lang === "en")
        ? (pb.stage_title_en || pb.stage_title || pb.state_title_en || pb.status_en || pb.state_title || pb.status)
        : (pb.stage_title_pt || pb.stage_title || pb.state_title_pt || pb.status_pt || pb.state_title || pb.status);

    // Fallbacks
    if (!regime) regime = pb.regime || pb.mode || pb.context || stage || "—";
    if (!respiro) respiro = pb.respiro || stage || "—";

    const revTxt =
      (lang === "en")
        ? (rev.verdict_en || rev.summary_en || rev.verdict || "")
        : (rev.verdict_pt || rev.summary_pt || rev.verdict || "");

    if (!reversao) reversao = revTxt || "—";

    // subtexto (ex: "Sem setup de breakout")
    let reversaoSub = rev.sub || rev.note || pb.breakout_note || pb.note || "";
    if (!reversaoSub) reversaoSub = (revTxt && reversao !== revTxt) ? String(revTxt).trim() : "";
    if (!reversaoSub) reversaoSub = "—";

    if (!consolidacao) consolidacao = pb.consolidacao || pb.range || "—";
    if (!continuacao) continuacao = pb.continuacao || "—";
    if (!acao) acao = pb.acao || pb.action || ui.acao || ui.action || digest.acao || digest.action || "—";

    // versões “full”
    const verdictPt = rev?.verdict_pt || rev?.verdictPt;
    let reversaoFull = reversao;
    if (verdictPt && !String(reversaoFull).toLowerCase().includes(String(verdictPt).toLowerCase())){
      reversaoFull = (reversaoFull === "—") ? String(verdictPt) : `${reversaoFull} • ${verdictPt}`;
    }
    const respiroFull = respiro;

    const setText = (id, v) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.textContent = (v === null || v === undefined || v === "") ? "—" : String(v);
    };

    // topo (grande)
    setText("rr-respiro", respiro);
    setText("rr-reversao", reversao);
    setText("rr-reversao-sub", reversaoSub);

    // badge
    setText("rr-badge", `AÇÃO: ${acao || "—"}`);

    // readout completo (igual sua 2ª imagem)
    setText("rr-regime", regime);
    setText("rr-reversao-full", reversaoFull);
    setText("rr-respiro-full", respiroFull);
    setText("rr-consolidacao", consolidacao);
    setText("rr-continuacao", continuacao);
    setText("rr-acao", acao);
    // ===== espelho no bloco de PREMONIÇÃO (SEM RESPIRO) =====
    setText("prem-regime", regime);
    setText("prem-reversao-full", reversaoFull);
    setText("prem-respiro-full", respiroFull);
    setText("prem-consolidacao", consolidacao);
    setText("prem-continuacao", continuacao);
    setText("prem-acao-full", acao);
        __A10_PREM_CONTINUACAO = continuacao;
    __A10_PREM_ACAO = acao;
a10UpdatePremSignalCTA();


    const pro = document.getElementById("prem-readout");
    if (pro) pro.style.display = "block";

    const ro = document.getElementById("rr-readout");
    if (ro) ro.style.display = "block";
  }catch(e){
    // não quebra o painel por causa disso
  }
}


let __AARON_MATCHER_REQ_ID = 0;

function applyResponderIntoTradeCard(data){
  data = Array.isArray(data) ? (data[0] ?? {}) : (data ?? {});
  const panel  = data?.panel  || {};
  const ui     = data?.ui     || {};
  const digest = data?.digest || {};
  const sf = digest?.shape_focus || {};
  const sr = digest?.sr_proxy || {};

  const set = (id, val) => {
    const el = document.getElementById(id);
    if (!el) return;
    const v = (val === null || val === undefined || val === "") ? "—" : String(val);
    el.textContent = v;
  };

  const fmt2 = (n) => (typeof n === "number" && isFinite(n)) ? n.toFixed(2) : (n ?? "—");

  // Estatística “na cara”
  const stats = ui.headline || ui.structure_line || sf.label || "—";
  set("trade-stats", stats);
  set("trade-stats-top", stats);

  // Direção (só pra exibir o output do responder)
  const dirRaw = String(sf.direction || "").toLowerCase();
  const dirPT  = (dirRaw === "up") ? "COMPRA" : (dirRaw === "down") ? "VENDA" : "NEUTRO";
  set("trade-direction", dirPT);

  // Modo / contexto (pra aparecer dentro do Trade Card)
  const mode = ui.pullback_line || ui.market_structure_line || ui.tactical_line || "—";
  set("trade-mode", mode);

  // Contra (resumo do digest)
  const against = [
    sf.family_en || sf.family || "",
    sf.bias ? `bias:${sf.bias}` : "",
    (Array.isArray(digest.features_true) && digest.features_true.length)
      ? `feat:${digest.features_true.join(", ")}`
      : ""
  ].filter(Boolean).join(" • ") || "—";
  set("trade-against", against);

  // Entrada: usa o range SR proxy (se existir)
  if (sr.recent_low != null || sr.recent_high != null) {
    set("trade-entry", `${fmt2(sr.recent_low)} – ${fmt2(sr.recent_high)}`);
  }

  // Comentário do AARON (mostra as linhas do ui)
  const comment = [
    ui.structure_line ? `Estrutura: ${ui.structure_line}` : "",
    ui.tactical_line ? `Tático: ${ui.tactical_line}` : "",
    ui.market_structure_line ? `MS: ${ui.market_structure_line}` : "",
    ui.pullback_line ? `Pullback: ${ui.pullback_line}` : "",
  ].filter(Boolean).join(" | ");

  if (comment) set("trade-comment", comment);
}
function updateAaronCommentaryBlock(data){
  try{
    data = Array.isArray(data) ? (data[0] ?? {}) : (data ?? {});
    const ui     = data?.ui     || {};
    const digest = data?.digest || {};
    const panel  = data?.panel  || {};
    const sf = digest?.shape_focus || {};

    const pickFirst = (...vals) => {
      for (const v of vals){
        if (v == null) continue;
        const s = String(v).trim();
        if (s) return v;
      }
      return null;
    };

    // direção “macro do dia” (tenta várias fontes e cai pro shape_focus.direction)
    const dayDirRaw = String(pickFirst(
      ui.day_direction, ui.day_dir, ui.macro_direction, ui.macro_dir,
      digest.day_direction, digest.day_dir, digest.macro_direction, digest.macro_dir,
      digest?.breakout_window_hours?.dir, digest?.breakout_window_eod?.dir,
      digest?.breakout_window_v2?.dir, digest?.breakout_window?.dir,
      panel.day_direction, panel.day_dir, panel.dir,
      sf.direction
    ) || "").toUpperCase();

    const dayDir = (dayDirRaw === "UP") ? "UP" : (dayDirRaw === "DOWN") ? "DOWN" : "NEUTRO";

    // padrão dominante (ex: 2x Top, 3º toque, etc.)
    const pattern = String(pickFirst(
      sf.name_pt, sf.label, sf.name_en,
      ui.pattern_name, ui.shape_name, ui.shape_label
    ) || "—");

    // comentário estilo “pipe” igual ao da imagem
    const comment = [
      ui.structure_line ? `Estrutura: ${ui.structure_line}` : "",
      ui.tactical_line ? `Tático: ${ui.tactical_line}` : "",
      ui.market_structure_line ? `MS: ${ui.market_structure_line}` : "",
      ui.pullback_line ? `Pullback: ${ui.pullback_line}` : "",
    ].filter(Boolean).join(" | ");

    const finalText = [
      `Direção do dia: ${dayDir}`,
      (pattern && pattern !== "—") ? `Padrão: ${pattern}` : "",
      comment
    ].filter(Boolean).join(" | ") || "—";

    const bodyEl = document.getElementById("aaron-commentary-body");
    if (bodyEl) bodyEl.textContent = finalText;

    const dayBadge = document.getElementById("aaron-day-badge");
    if (dayBadge){
      dayBadge.textContent = `DIA: ${dayDir}`;
      dayBadge.classList.remove("is-up","is-down","is-neutral");
      dayBadge.classList.add(dayDir === "UP" ? "is-up" : dayDir === "DOWN" ? "is-down" : "is-neutral");
    }

    const patBadge = document.getElementById("aaron-pattern-badge");
    if (patBadge){
      const short = pattern.length > 44 ? pattern.slice(0, 41) + "…" : pattern;
      patBadge.textContent = `PADRÃO: ${short || "—"}`;
      patBadge.title = pattern || "";
    }
  }catch(_){}
}

async function requestMatcher(symbol) {
  symbol = String(symbol || "").trim().toUpperCase();
  if (!symbol) return;

  const tf =
    (typeof getSelectedTimeframe === "function")
      ? getSelectedTimeframe()
      : (localStorage.getItem("aaron_selected_timeframe") || "1m");

    // ✅ LIVE candles (Cloud Run WS): NÃO reconecta aqui (evita "WS closed before established")
  // Quem abre a conexão é o handler do dropdown/timeframe; aqui só re-assina se já estiver conectado
  if (typeof a10LiveSubscribe === "function") a10LiveSubscribe(symbol, tf);

  const reqId = ++__AARON_MATCHER_REQ_ID;

  const ctxEl = document.getElementById("context-text");
  const exeEl = document.getElementById("execution-text");
  if (ctxEl) ctxEl.textContent = `Carregando matcher para ${symbol} (${tf})...`;
  if (exeEl) exeEl.textContent = "—";
  if (typeof setRespSnapMessage === "function") setRespSnapMessage(`Carregando ${symbol} (${tf})...`);

  async function fetchOne(baseUrl){
    const url = `${baseUrl}?symbol=${encodeURIComponent(symbol)}&timeframe=${encodeURIComponent(tf)}&_=${Date.now()}`;
    const res = await fetch(url, { method: "GET", cache: "no-store" }); // ✅ GET
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`HTTP ${res.status}${t ? ` • ${t.slice(0,160)}` : ""}`);
    }
    return await res.json();
  }

  let raw = null;

    try {
    raw = await fetchOne(MATCHER_WEBHOOK_URL);
  } catch (errProd) {

    // ✅ Só tenta webhook-test quando estiver rodando LOCAL (localhost/127.0.0.1)
    if (__A10_IS_LOCAL) {
      try {
        raw = await fetchOne(MATCHER_WEBHOOK_URL_TEST);
      } catch (errTest) {
        if (reqId !== __AARON_MATCHER_REQ_ID) return;
        const msg = `Matcher fetch falhou: ${errTest?.message || errTest || "Failed to fetch"}`;
        if (ctxEl) ctxEl.textContent = msg;
        if (exeEl) exeEl.textContent = "—";
        if (typeof setRespSnapMessage === "function") setRespSnapMessage(msg);
        return;
      }
    } else {
      // ✅ Em produção: NÃO tenta webhook-test (ele sempre quebra)
      if (reqId !== __AARON_MATCHER_REQ_ID) return;
      const msg = `Matcher (PROD) falhou: ${errProd?.message || errProd || "Failed to fetch"}`;
      if (ctxEl) ctxEl.textContent = msg;
      if (exeEl) exeEl.textContent = "—";
      if (typeof setRespSnapMessage === "function") setRespSnapMessage(msg);
      return;
    }
  }


  if (reqId !== __AARON_MATCHER_REQ_ID) return;

  const data = Array.isArray(raw) ? (raw[0] ?? {}) : (raw ?? {});
  window.__AARON_MATCHER_LAST__ = data; // debug

  // ✅ bloco “RESPONDER OUTPUT”
  if (typeof renderTradeResponderOutput === "function") {
    renderTradeResponderOutput(data);
  }
if (typeof updatePremonitionPanel === "function") {
  updatePremonitionPanel(data);
}
if (typeof updateRespiroReversaoPanel === "function") {
  updateRespiroReversaoPanel(data);
}
if (typeof updateAaronCommentaryBlock === "function") {
  updateAaronCommentaryBlock(data);
}

  // ✅ injeta dentro do Trade Card
  applyResponderIntoTradeCard(data);

  if (ctxEl) ctxEl.textContent = `Matcher OK: ${symbol} (${tf})`;
  if (exeEl) exeEl.textContent = data?.panel?.updated_at || "—";
  if (typeof setRespSnapMessage === "function") setRespSnapMessage("");
}









// ✅ Isso aqui é a “conversa”: o seu dropdown já dispara esse evento.
// Quando trocar o ativo, ele chama o n8n automaticamente.
window.addEventListener("aaron:symbolSelected", (ev) => {
  const symbol = String(ev?.detail?.symbol || '').toUpperCase().trim();
  if (!symbol) return;

  // 0) AutoPilot amarrado ao símbolo atual (evita “vazar” trade entre ativos)
  if (typeof apOnSymbolChange === 'function') apOnSymbolChange(symbol);

  // 1) chama o matcher
  requestMatcher(symbol);

  // 2) atualiza o painel JSON imediatamente
  loadPanel(true);

  // 3) (opcional) Live Candles via Cloud Run (NÃO muda nada enquanto A10_USE_LIVE_CANDLES=false)
  if (typeof a10LiveConnect === "function") {
    const tf = (typeof getSelectedTimeframe === "function")
      ? getSelectedTimeframe()
      : (window.AARON_SELECTED_TIMEFRAME || "1m");
    a10LiveConnect(symbol, tf);
  }
});




// ✅ Ao abrir a página, dispara 1x com o último símbolo salvo (pra já mostrar algo)
setTimeout(() => {
  const symbol =
    window.AARON_SELECTED_SYMBOL ||
    localStorage.getItem("aaron_selected_symbol") ||
    "NVDA";

  // garante timeframe aplicado antes do primeiro load
  if (typeof setSelectedTimeframe === "function") {
    setSelectedTimeframe(getSelectedTimeframe(), { dispatch: false });
  }

  window.dispatchEvent(new CustomEvent("aaron:symbolSelected", { detail: { symbol } }));
}, 200);



// ======= LANG GLOBAL (precisa vir ANTES do AutoPilot / loadPanel) =======
var currentLang = (function(){
  try { return localStorage.getItem('AARON_LANG') || 'pt'; } catch(e) { return 'pt'; }
})();
window.currentLang = currentLang;


const els = {
  errorBanner: document.getElementById('error-banner'),
  btnRefresh: document.getElementById('btn-refresh'),
  state: document.getElementById('state-pill'),
  symbol: document.getElementById('symbol-label'),
  timeframe: document.getElementById('timeframe-label'),
  pulseLine: document.getElementById('pulseLine'),
    // AUTOPILOT
  apToggle: document.getElementById('ap-toggle'),
  apState: document.getElementById('ap-state'),
  apBuy: document.getElementById('ap-buy'),
  apSell: document.getElementById('ap-sell'),
  apClose: document.getElementById('ap-close'),
  apMeta: document.getElementById('ap-meta'),
    // AUTOPILOT 2.0 (sizing / quotes)
  apCapital: document.getElementById('ap-capital'),
  apUnits: document.getElementById('ap-units'),
  apPriceSell: document.getElementById('ap-price-sell'),
  apPriceMid: document.getElementById('ap-price-mid'),
  apPriceBuy: document.getElementById('ap-price-buy'),


  session: document.getElementById('session-label'),
  lastUpdate: document.getElementById('last-update-label'),
  flow: document.getElementById('flow-label'),
  trendDayPill: document.getElementById('trend-day-pill'),
  trendNowPill: document.getElementById('trend-now-pill'),
  dirDayArrow: document.getElementById('direction-day-arrow'),
  dirNowArrow: document.getElementById('direction-now-arrow'),
  patternDayLabel: document.getElementById('pattern-day-label'),
  patternDayDetail: document.getElementById('pattern-day-detail'),
  patternNowLabel: document.getElementById('pattern-now-label'),
  patternNowDetail: document.getElementById('pattern-now-detail'),
  summary: document.getElementById('summary-text'),
  riskPill: document.getElementById('risk-pill'),
  riskText: document.getElementById('risk-text'),
  contextText: document.getElementById('context-text'),
  executionText: document.getElementById('execution-text'),
  directionDayText: document.getElementById('direction-day-text'),
  directionNowText: document.getElementById('direction-now-text'),

    // Pattern Reference (ABA)
  refDetails: document.getElementById('refDetails'),
  refSummaryTitle: document.getElementById('refSummaryTitle'),
  refSummaryRight: document.getElementById('refSummaryRight'),
  refPatternMini: document.getElementById('refPatternMini'),
  refPatternImg: document.getElementById('refPatternImg'),
  refPatternLabel: document.getElementById('refPatternLabel'),
  refPatternSetup: document.getElementById('refPatternSetup'),
  refPatternNotes: document.getElementById('refPatternNotes'),
  refPatternLink: document.getElementById('refPatternLink'),


  // HERO / MODO CEGO
  heroBlock: document.getElementById('hero-block'),
  heroMain: document.getElementById('hero-main'),
  heroSub: document.getElementById('hero-sub'),
  heroBadge: document.getElementById('hero-badge'),
  heroModePill: document.getElementById('hero-mode-pill'),
  heroSideLabel: document.getElementById('hero-side-label'),
  heroSummary: document.getElementById('hero-summary-text'),
  heroFavorLabel: document.getElementById('hero-favor-label'),
  heroFavorBar: document.getElementById('hero-favor-bar'),
  heroFavorPhrase: document.getElementById('hero-favor-phrase'),

  heroContraLabel: document.getElementById('hero-contra-label'),
  heroContraBar: document.getElementById('hero-contra-bar'),
  heroContraPhrase: document.getElementById('hero-contra-phrase'),

  heroMiniRisk: document.getElementById('hero-mini-risk'),
  heroMiniContext: document.getElementById('hero-mini-context'),
  heroMiniExecution: document.getElementById('hero-mini-execution'),

    // RESUMO INSTITUCIONAL (barras)
  heroFavorLabel: document.getElementById('hero-favor-label'),
  heroFavorBar: document.getElementById('hero-favor-bar'),
  heroFavorPhrase: document.getElementById('hero-favor-phrase'),

  heroContraLabel: document.getElementById('hero-contra-label'),
  heroContraBar: document.getElementById('hero-contra-bar'),
  heroContraPhrase: document.getElementById('hero-contra-phrase'),

  heroMiniRisk: document.getElementById('hero-mini-risk'),
  heroMiniContext: document.getElementById('hero-mini-context'),
  heroMiniExecution: document.getElementById('hero-mini-execution'),


    // --- Cartão de Trade (Citadel) ---
  tradeCard: document.getElementById('trade-card'),
  tradeStatusText: document.getElementById('trade-status-text'),
  // NOVO (topo)
  tradeStatsTopLine: document.getElementById('trade-stats-top-line'),
  tradeStatsTop: document.getElementById('trade-stats-top'),
  tradeStatsTopLine: document.getElementById('trade-stats-top-line'),
  tradeStatsTop: document.getElementById('trade-stats-top'),
  tradeStats: document.getElementById('trade-stats'),
  tradeSymbol: document.getElementById('trade-symbol'),
  tradeTimeframe: document.getElementById('trade-timeframe'),
  tradeMode: document.getElementById('trade-mode'),
  tradeAgainst: document.getElementById('trade-against'),
  tradeDirection: document.getElementById('trade-direction'),
  tradeEntry: document.getElementById('trade-entry'),
  tradeStop: document.getElementById('trade-stop'),
  tradeTP1: document.getElementById('trade-tp1'),
  tradeTP2: document.getElementById('trade-tp2'),
  tradeSize: document.getElementById('trade-size'),
  tradeRisk: document.getElementById('trade-risk'),
  tradeThermo: document.getElementById('trade-thermo'),
  tradeComment: document.getElementById('trade-comment'),
  tradeBadge: document.getElementById('trade-badge'),


  // Estrutura recente (HH / HL / LH / LL)
  structureHHStatus: document.getElementById('structure-hh-status'),
  structureHLStatus: document.getElementById('structure-hl-status'),
  structureLHStatus: document.getElementById('structure-lh-status'),
  structureLLStatus: document.getElementById('structure-ll-status'),
  structureHHDot: document.getElementById('structure-hh-dot'),
  structureHLDot: document.getElementById('structure-hl-dot'),
  structureLHDot: document.getElementById('structure-lh-dot'),
  structureLLDot: document.getElementById('structure-ll-dot'),

  // Pullback Brain
  pullbackStatus: document.getElementById('pullback-status'),
  pullbackDepth: document.getElementById('pullback-depth'),
  pullbackQuality: document.getElementById('pullback-quality'),
  pullbackHeadline: document.getElementById('pullback-headline'),
  pullbackText: document.getElementById('pullback-text'),
  pullbackHighlightBox: document.getElementById('pullback-highlight-box'),
  pullbackSideTag: document.getElementById('pullback-side-tag'),
  pullbackStageTag: document.getElementById('pullback-stage-tag'),
  pullbackMeterFill: document.getElementById('pullback-meter-fill'),
  pullbackMeterLabel: document.getElementById('pullback-meter-label'),

       // Sizing Brain
  sizingTarget: document.getElementById('sizing-target'),
  sizingMaxDD: document.getElementById('sizing-max-dd'),
  sizingRiskTrade: document.getElementById('sizing-risk-trade'),
  sizingTradesCount: document.getElementById('sizing-trades-count'),
  pullbackCandle: document.getElementById('pullback-candle'),
  sizingProfileTag: document.getElementById('sizing-profile-tag'),
  sizingStyleTag: document.getElementById('sizing-style-tag'),
  sizingMeterFill: document.getElementById('sizing-meter-fill'),
  sizingMeterLabel: document.getElementById('sizing-meter-label'),
  sizingComment: document.getElementById('sizing-comment'),

  // Sizing Brain – inputs e frases (lógica tipo Aaron Pine)
  sizingAccountRealInput: document.getElementById('sizing-account-real-input'),
  sizingUseInput: document.getElementById('sizing-use-input'),
  sizingLeverageInput: document.getElementById('sizing-leverage-input'),
  sizingRiskInput: document.getElementById('sizing-risk-input'),
  sizingStopInput: document.getElementById('sizing-stop-input'),
  sizingFixedQtyInput: document.getElementById('sizing-fixedqty-input'),
  sizingPhraseMain: document.getElementById('sizing-phrase-main'),
  sizingPhraseDetail: document.getElementById('sizing-phrase-detail'),

};

// ===============================
// AUTOPILOT v1 (simulação local)
// ===============================
const AP_KEY = 'AARON_AUTOPILOT_V1';
let lastTradeCard = null;

function apLoad() {
  try {
    const raw = localStorage.getItem(AP_KEY);
    const obj = raw ? JSON.parse(raw) : null;

    const capital =
      (typeof obj?.capital === 'number' && isFinite(obj.capital)) ? obj.capital : 25000;

    const base = {
      enabled: !!obj?.enabled,
      active:  !!obj?.active,
      side:    (obj?.side === 'buy' || obj?.side === 'sell') ? obj.side : null,
      entry:   (obj?.entry != null && isFinite(Number(obj.entry))) ? Number(obj.entry) : null,
      startedAt: (obj?.startedAt != null && isFinite(Number(obj.startedAt))) ? Number(obj.startedAt) : null,

      // 2.0
      capital,
      units: (obj?.units != null && isFinite(Number(obj.units))) ? Number(obj.units) : null,
      priceNow: (obj?.priceNow != null && isFinite(Number(obj.priceNow))) ? Number(obj.priceNow) : null,

      // ===== CONTRATO (state + snapshot + regra de conflito) =====
      state: (typeof obj?.state === 'string') ? obj.state : null, // FLAT | LONG_ACTIVE | SHORT_ACTIVE | EXIT_PENDING
      snapshot: (obj?.snapshot && typeof obj.snapshot === 'object') ? obj.snapshot : null,
      marketNow: (obj?.marketNow === 'buy' || obj?.marketNow === 'sell' || obj?.marketNow === 'wait')
        ? obj.marketNow
        : 'wait',
      exitPending: !!obj?.exitPending,
      current_price: (obj?.current_price != null && isFinite(Number(obj.current_price))) ? Number(obj.current_price) : null,
      pnl: (obj?.pnl != null && isFinite(Number(obj.pnl))) ? Number(obj.pnl) : null,
      rMultiple: (obj?.rMultiple != null && isFinite(Number(obj.rMultiple))) ? Number(obj.rMultiple) : null,
      lastUpdate: (obj?.lastUpdate != null && isFinite(Number(obj.lastUpdate))) ? Number(obj.lastUpdate) : null,
    };

    // Normaliza state legado
    const valid = ['FLAT', 'LONG_ACTIVE', 'SHORT_ACTIVE', 'EXIT_PENDING'];
    if (!valid.includes(base.state)) {
      if (base.active && base.side === 'buy') base.state = 'LONG_ACTIVE';
      else if (base.active && base.side === 'sell') base.state = 'SHORT_ACTIVE';
      else base.state = 'FLAT';
    }

    // Se state diz que tem posição, mas falta snapshot, cria snapshot mínimo
    if (base.state !== 'FLAT' && !base.snapshot) {
      const posSide = (base.state === 'SHORT_ACTIVE') ? 'short' : 'long';
      base.snapshot = {
        opened_at_timestamp: base.startedAt ?? null,
        side: posSide,
        entry_price: base.entry,
        stop: null,
        tp1: null,
        tp2: null,
        capital: base.capital,
        units: base.units,
      };
    }

    // Se FLAT, limpa
    if (base.state === 'FLAT') {
      base.active = false;
      base.side = null;
      base.entry = null;
      base.startedAt = null;
      base.snapshot = null;
      base.exitPending = false;
    } else {
      base.active = true;
      base.side = (base.snapshot?.side === 'short') ? 'sell' : 'buy';

      if (base.entry == null && base.snapshot?.entry_price != null) {
        const e = Number(base.snapshot.entry_price);
        if (isFinite(e)) base.entry = e;
      }
      if (base.units == null && base.snapshot?.units != null) {
        const u = Number(base.snapshot.units);
        if (isFinite(u)) base.units = u;
      }
    }

    return base;
  } catch (e) {
    return {
      enabled: false, active: false, side: null, entry: null, startedAt: null,
      capital: 25000, units: null, priceNow: null,
      state: 'FLAT', snapshot: null, marketNow: 'wait', exitPending: false,
      current_price: null, pnl: null, rMultiple: null, lastUpdate: null,
    };
  }
}



function apSave(state) {
  localStorage.setItem(AP_KEY, JSON.stringify(state));
}
let autopilot = apLoad();
let apMarketPrice = null;

function apExtractPriceFromPayload(payload){
  if (!payload) return null;

  const panel  = payload.panel  || payload || {};
  const ui     = payload.ui     || {};
  const digest = payload.digest || {};
  const raw    = payload.raw || payload.raw_eye || payload.data || {};

  const candidates = [
    // painel
    panel.price_now, panel.last_price, panel.price, panel.current_price,
    // ui
    ui.price, ui.last_price, ui.current_price,
    // raw/candle (quando existir)
    raw?.candle?.close, raw?.candle?.c, raw?.last?.close,
    // digest (se você decidir mandar preço pra cá no futuro)
    digest.price, digest.last_price
  ];

  for (const c of candidates){
    const n = apParseNumber(c);
    if (typeof n === "number") return n;
  }
  return null;
}

function apUpdateMarketPriceFromPayload(payload){
  const px = apExtractPriceFromPayload(payload);

  if (typeof px === "number") {
    apMarketPrice = px;
    autopilot.priceNow = px;
    autopilot.current_price = px;
  } else {
    apMarketPrice = null;
    autopilot.priceNow = null;
    autopilot.current_price = null;
  }

  apRenderSizing();
}


function apOnSymbolChange(symbol){
  try {
    symbol = String(symbol || '').toUpperCase().trim();
    if (!symbol) return;

    // corta “preço velho” do ativo anterior
    apMarketPrice = null;

    // remove panel antigo do contexto (pra UI não mostrar símbolo velho)
    if (window.apCtx) window.apCtx.panel = null;

    // carrega estado atual
    autopilot = apLoad();

    // ✅ fallback de símbolo (porque snapshot.symbol pode vir vazio)
    const prevSymRaw =
      (autopilot?.snapshot?.symbol) ??
      (autopilot?.lastSymbol) ??
      (localStorage.getItem("aaron_selected_symbol")) ??
      null;

    const prevSym = prevSymRaw ? String(prevSymRaw).toUpperCase().trim() : null;

    const inTrade = !!autopilot?.snapshot && autopilot?.state && autopilot.state !== 'FLAT';

    // ✅ se mudou símbolo, zera preço cacheado pra não “vazar”
    if (prevSym && prevSym !== symbol) {
      autopilot.priceNow = null;
      autopilot.current_price = null;
    }

    // ✅ se estiver em trade e mudar símbolo, reseta contrato
    if (inTrade && prevSym && prevSym !== symbol) {
      autopilot.enabled = false;
      autopilot.active = false;
      autopilot.side = null;
      autopilot.entry = null;
      autopilot.startedAt = null;

      autopilot.state = 'FLAT';
      autopilot.snapshot = null;
      autopilot.exitPending = false;

      autopilot.marketNow = 'wait';
      autopilot.priceNow = null;
      autopilot.current_price = null;
      autopilot.pnl = null;
      autopilot.rMultiple = null;
      autopilot.lastUpdate = null;

      apSave(autopilot);
      if (els?.apToggle) els.apToggle.checked = false;
    }

    // ✅ sempre salva qual é o símbolo “atual” pro próximo ciclo (fallback)
    autopilot.lastSymbol = symbol;
    apSave(autopilot);

    // atualiza UI imediatamente (mesmo antes do loadPanel terminar)
    if (typeof apSyncUI === 'function') apSyncUI();
  } catch (e) {
    console.error('[AARON][AP] apOnSymbolChange error', e);
  }
}


// ======================== AUTOPILOT CONTRACT ENGINE (state + snapshot + conflict) ========================
const AP_STATES = {
  FLAT: 'FLAT',
  LONG_ACTIVE: 'LONG_ACTIVE',
  SHORT_ACTIVE: 'SHORT_ACTIVE',
  EXIT_PENDING: 'EXIT_PENDING',
};

window.apCtx = window.apCtx || {
  panel: null,
  executionPlan: '',
  riskLevel: '',
  finalSummary: '',
  marketNow: 'wait',
};
const apCtx = window.apCtx;


function apToNum(v){
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
}

function apFmtPx(v){
  const n = apToNum(v);
  if(n == null) return '—';
  return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
}

function apFmtMoney(v){
  const n = apToNum(v);
  if(n == null) return '—';
  const sign = n >= 0 ? '+' : '-';
  const abs = Math.abs(n);
  return `${sign}$${abs.toLocaleString(undefined, { maximumFractionDigits: 2 })}`;
}

function apParseMarketNow(executionPlan){
  const s = String(executionPlan || '').toLowerCase();

  // WAIT primeiro (se aparecer explicitamente)
  if (/\bwait\b/.test(s) || /aguarde|espera|no trade|stand by/.test(s)) return 'wait';

  // GO FULL BUY / GO FULL SELL
  if (/go\s*full.*buy|full.*buy/.test(s)) return 'buy';
  if (/go\s*full.*sell|full.*sell/.test(s)) return 'sell';

  // BUY / SELL
  const hasBuy  = /\bbuy\b|compra|\blong\b/.test(s);
  const hasSell = /\bsell\b|venda|\bshort\b/.test(s);

  if (hasBuy && !hasSell) return 'buy';
  if (hasSell && !hasBuy) return 'sell';

  // ambíguo => WAIT (mais seguro)
  return 'wait';
}

function apConsensusScores(panel){
  const c = panel?.ai_consensus || panel?.consensus || panel?.consenso || {};
  const buy  = apToNum(c.buy ?? c.buy_pct ?? c.long ?? c.up ?? c.bull) ?? 0;
  const sell = apToNum(c.sell ?? c.sell_pct ?? c.short ?? c.down ?? c.bear) ?? 0;
  return { buy, sell };
}

function apConsensusDominant(scores, side){
  const buy = scores.buy ?? 0;
  const sell = scores.sell ?? 0;

  // “dominante” = diferença clara OU >60/40
  if(side === 'sell'){
    return (sell - buy) >= 15 || (sell >= 60 && buy <= 40) || (buy > 0 && (sell / buy) >= 1.25);
  }
  if(side === 'buy'){
    return (buy - sell) >= 15 || (buy >= 60 && sell <= 40) || (sell > 0 && (buy / sell) >= 1.25);
  }
  return false;
}

function apStructureConfirm(panel){
  return !!(
    panel?.estrutura_mercado?.confirma ??
    panel?.market_structure?.confirma ??
    panel?.structure_confirm ??
    false
  );
}

function apDidHitStop(px, snap){
  const p = apToNum(px);
  const stop = apToNum(snap?.stop);
  if(p == null || stop == null) return false;

  if(snap?.side === 'long') return p <= stop;
  if(snap?.side === 'short') return p >= stop;
  return false;
}

function apIsStrongContra(panel, marketNow, snap, px){
  if(!snap) return false;

  // “contra” só importa quando MarketNow aponta pro lado oposto do trade
  if(snap.side === 'long' && marketNow !== 'sell') return false;
  if(snap.side === 'short' && marketNow !== 'buy') return false;

  const hitStop = apDidHitStop(px, snap);
  const structure = apStructureConfirm(panel);
  const scores = apConsensusScores(panel);
  const dom = (snap.side === 'long')
    ? apConsensusDominant(scores, 'sell')
    : apConsensusDominant(scores, 'buy');

  return !!(hitStop || structure || dom);
}

function apBuildSnapshot(side){
  const panel = apCtx.panel;

  // tenta pegar stop/tps do último tradeCard (se existir)
  const tc = (typeof lastTradeCard !== 'undefined') ? lastTradeCard : null;

  const entry = apPickEntryFromUI() ?? apGetMarketPrice();

  return {
    opened_at_timestamp: Date.now(),
    side: (side === 'buy') ? 'long' : 'short',
    entry_price: apToNum(entry),

    stop: apToNum(tc?.stop),
    tp1: apToNum(tc?.tp1),
    tp2: apToNum(tc?.tp2),

    // extras (se tiver)
    symbol: panel?.symbol ?? panel?.ticker ?? null,
    timeframe: panel?.timeframe ?? null,
    pattern_id: panel?.pattern_id ?? panel?.pattern ?? null,
    setup_id: panel?.setup_id ?? panel?.setup ?? null,
  };
}

function apUpdatePnLAndR(autopilotObj, px){
  const snap = autopilotObj.snapshot;
  if(!snap) return;

  const entry = apToNum(snap.entry_price);
  const p = apToNum(px);
  if(entry == null || p == null) return;

  autopilotObj.current_price = p;

  // PnL (simples): usa units se existir; se não, PnL em “por unidade”
  const units = apToNum(autopilotObj.units) ?? apToNum(snap.size);
  const delta = (snap.side === 'long') ? (p - entry) : (entry - p);
  autopilotObj.pnl = (units != null && units > 0) ? (delta * units) : delta;

  // R multiple: precisa de stop
  const stop = apToNum(snap.stop);
  if(stop == null) { autopilotObj.rMultiple = null; return; }

  const risk = (snap.side === 'long') ? (entry - stop) : (stop - entry);
  if(!Number.isFinite(risk) || risk <= 0) { autopilotObj.rMultiple = null; return; }

  autopilotObj.rMultiple = delta / risk;
}

function apOnPanelUpdate(panel, meta){
  autopilot = apLoad();

  apCtx.panel = panel ?? null;
  apCtx.executionPlan = meta?.executionPlan ?? '';
  apCtx.riskLevel = meta?.riskLevel ?? '';
  apCtx.finalSummary = meta?.finalSummary ?? '';

  const marketNow = apParseMarketNow(apCtx.executionPlan);
  apCtx.marketNow = marketNow;

  autopilot.marketNow = marketNow;

  const px = apGetMarketPrice();
  if(px != null) apUpdatePnLAndR(autopilot, px);

  // regra de conflito → EXIT_PENDING (e relaxa se parar de ser forte)
  if(autopilot.state !== AP_STATES.FLAT && autopilot.snapshot){
    const strongContra = apIsStrongContra(panel, marketNow, autopilot.snapshot, autopilot.current_price ?? px);

    if(strongContra){
      autopilot.state = AP_STATES.EXIT_PENDING;
      autopilot.exitPending = true;
    }else{
      autopilot.state = (autopilot.snapshot.side === 'short') ? AP_STATES.SHORT_ACTIVE : AP_STATES.LONG_ACTIVE;
      autopilot.exitPending = false;
    }
  }

  autopilot.lastUpdate = Date.now();
  apSave(autopilot);

  if(typeof apSyncUI === 'function') apSyncUI();
}


function apMoneyEN(n){
  return (typeof n === 'number' && isFinite(n))
    ? '$' + n.toLocaleString('en-US', { maximumFractionDigits: 0 })
    : '—';
}
function apMoneyPT(n){
  return (typeof n === 'number' && isFinite(n))
    ? 'US$ ' + n.toLocaleString('pt-BR', { maximumFractionDigits: 0 })
    : '—';
}

function apGetMarketPrice(){
  if (typeof apMarketPrice === 'number' && isFinite(apMarketPrice) && apMarketPrice > 0) return apMarketPrice;
  if (typeof autopilot.priceNow === 'number' && isFinite(autopilot.priceNow) && autopilot.priceNow > 0) return autopilot.priceNow;

  const entry = apPickEntryFromUI();
  if (typeof entry === 'number' && isFinite(entry) && entry > 0) return entry;

  return null;
}

function apComputeUnits(capital, price){
  const cap = Number(capital);
  const p = Number(price);
  if (!isFinite(cap) || cap <= 0 || !isFinite(p) || p <= 0) return null;
  return Math.floor(cap / p);
}

function apRenderSizing(){
  // mantém state sempre “2.0-ready”
  // NÃO re-hidratar aqui (apLoad), senão apActivate() perde enabled/active/side recém-setados
  if (!autopilot) autopilot = apLoad();

  // capital vem do input (se existir)
  if (els.apCapital) {
    const cap = Number(String(els.apCapital.value || '').replace(',', '.'));
    if (isFinite(cap) && cap > 0) autopilot.capital = cap;
  }

  const price = apGetMarketPrice();
  autopilot.priceNow = (price != null) ? Number(price) : autopilot.priceNow;

  const inPos = (autopilot.state && autopilot.state !== AP_STATES.FLAT && autopilot.snapshot);
const frozenUnits = inPos ? (apToNum(autopilot.snapshot?.units ?? autopilot.snapshot?.size)) : null;

const units = (frozenUnits != null)
  ? frozenUnits
  : apComputeUnits(autopilot.capital, price);

autopilot.units = units;


  if (els.apUnits) {
    els.apUnits.value = (units != null) ? units.toLocaleString('en-US') : '—';
  }

  const px = (price != null) ? Number(price) : null;
  if (els.apPriceSell) els.apPriceSell.textContent = (px != null) ? px.toFixed(2) : '—';
  if (els.apPriceBuy)  els.apPriceBuy.textContent  = (px != null) ? px.toFixed(2) : '—';
  if (els.apPriceMid)  els.apPriceMid.textContent  = (px != null) ? px.toFixed(2) : '—';

  apSave(autopilot);
}



function apSideLabel(side, lang) {
  if (lang === 'en') return side === 'buy' ? 'BUY' : 'SELL';
  return side === 'buy' ? 'COMPRA' : 'VENDA';
}
function apPickEntryFromUI() {
  const txt = (els.tradeEntry?.textContent || '').replace(',', '.');
  const m = txt.match(/(\d+(\.\d+)?)/);
  return m ? Number(m[1]) : null;
}
function apSyncUI() {
  if (!els.apToggle || !els.apState || !els.apMeta) return;

  autopilot = apLoad();

  const selSym = (localStorage.getItem('aaron_selected_symbol') || '').trim().toUpperCase() || '—';
  const panelSym = apCtx?.panel?.symbol || apCtx?.panel?.ticker;
  const sym = String(autopilot?.snapshot?.symbol || panelSym || selSym || '—').toUpperCase();
  const tf = String(autopilot?.snapshot?.timeframe || apCtx?.panel?.timeframe || '—');
  const symTf = `${sym} | ${tf}`;


  els.apToggle.checked = !!autopilot.enabled;

  // garante que o 2.0 (capital/units) está sempre renderizado
  if (els.apCapital) els.apCapital.value = String(autopilot.capital ?? 25000);
  apRenderSizing();

  // contrato (state/marketNow) com fallback seguro
  const st = (typeof autopilot.state === 'string')
    ? autopilot.state
    : (autopilot.active ? (autopilot.side === 'sell' ? 'SHORT_ACTIVE' : 'LONG_ACTIVE') : 'FLAT');

  const mn = (autopilot.marketNow === 'buy' || autopilot.marketNow === 'sell' || autopilot.marketNow === 'wait')
    ? autopilot.marketNow
    : 'wait';

  const mnTxt = String(mn).toUpperCase();

  els.apState.classList.remove('ap-on', 'ap-off', 'ap-buy', 'ap-sell');

  if (!autopilot.enabled) {
    els.apState.classList.add('ap-off');
    els.apState.textContent = 'OFF';
    els.apMeta.textContent = `${symTf} • ${st} • MN ${mnTxt}`;
    return;
  }

  els.apState.classList.add('ap-on');

  // Se está em posição
  if (autopilot.active && (autopilot.side === 'buy' || autopilot.side === 'sell')) {
    els.apState.classList.add(autopilot.side === 'buy' ? 'ap-buy' : 'ap-sell');

    // Se contrato mandou EXIT_PENDING, mostra EXIT no label
    const isExit = (st === 'EXIT_PENDING') || !!autopilot.exitPending;
    els.apState.textContent = isExit ? 'EXIT' : (autopilot.side === 'buy' ? 'BUY' : 'SELL');

    const entry = (autopilot.entry != null && isFinite(autopilot.entry)) ? Number(autopilot.entry).toFixed(2) : '—';
    const started = autopilot.startedAt
      ? new Date(autopilot.startedAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      : '—';

    const capTxt = (currentLang === 'en') ? apMoneyEN(autopilot.capital) : apMoneyPT(autopilot.capital);
    const unitsTxt = (autopilot.units != null) ? `${autopilot.units.toLocaleString('en-US')} sh` : '—';

    // P/L e R (se existirem)
    const pnl = (autopilot.pnl != null && isFinite(autopilot.pnl)) ? Number(autopilot.pnl) : null;
    const r = (autopilot.rMultiple != null && isFinite(autopilot.rMultiple)) ? Number(autopilot.rMultiple) : null;

    const pnlTxt = (pnl == null) ? '' : ` • P/L ${(pnl >= 0 ? '+' : '')}${pnl.toFixed(2)}`;
    const rTxt = (r == null) ? '' : ` • R ${r.toFixed(2)}`;

    els.apMeta.textContent =
      `${symTf} • @ ${entry} • ${started} • ${capTxt} • ${unitsTxt} • ${st} • MN ${mnTxt}${pnlTxt}${rTxt}`;
    return;
  }

  // ON mas sem posição
  els.apState.textContent = 'ON';
  els.apMeta.textContent = `${symTf} • armado (sem posição) • ${st} • MN ${mnTxt}`;
}


function apActivate(side) {
  autopilot = apLoad(); // re-hidrata

  autopilot.enabled = true;
  autopilot.active = true;
  autopilot.side = side;

  const entry = apPickEntryFromUI() ?? apGetMarketPrice();
  autopilot.entry = (entry != null && isFinite(entry)) ? Number(entry) : autopilot.entry;

  // atualiza sizing 2.0 quando entra em posição
  apRenderSizing();
  autopilot.startedAt = Date.now();

  // ===== CONTRATO (Snapshot congelado) =====
  const panel = (typeof apCtx !== 'undefined' && apCtx && apCtx.panel) ? apCtx.panel : null;

  // 1) Base snapshot (já traz symbol/timeframe/pattern_id/setup_id)
  const snap = apBuildSnapshot(side);

  // 2) Congelar size/units no momento da entrada
  const unitsAtEntry = apComputeUnits(autopilot.capital, snap.entry_price);
  autopilot.units = unitsAtEntry;

  snap.size = unitsAtEntry;
  snap.size_text = (unitsAtEntry != null) ? unitsAtEntry.toLocaleString('en-US') : null;

  // 3) Congelar capital/units também (ajuda em reload e PnL)
  snap.capital = autopilot.capital;
  snap.units = unitsAtEntry;

  // 4) Contexto congelado (safe)
  const scores = apConsensusScores(panel);
  snap.contexto = {
    tendencia: panel?.status_geral?.tendencia ?? null,
    estrutura_confirma: panel?.estrutura_mercado?.confirma ?? null,
    ai_consensus: (scores.sell > scores.buy) ? 'sell' : (scores.buy > scores.sell) ? 'buy' : 'neutral',
    pullback_ativo: panel?.pullback_brain?.pullback_ativo ?? null,
    regime: panel?.regime ?? panel?.tags ?? null,
  };

  autopilot.snapshot = snap;

  // estado
  autopilot.state = (side === 'sell') ? AP_STATES.SHORT_ACTIVE : AP_STATES.LONG_ACTIVE;
  autopilot.exitPending = false;

  apSave(autopilot);
  apSyncUI();

  // força re-render do painel no estado "travado"
  if (typeof loadPanel === 'function') loadPanel(false);
}

function apClose() {
  autopilot = apLoad();

  // ✅ contrato: Close = apaga snapshot + OFF + FLAT (reset total)
  autopilot.enabled = false;
  autopilot.active = false;
  autopilot.side = null;
  autopilot.entry = null;
  autopilot.startedAt = null;

  autopilot.state = AP_STATES.FLAT;
  autopilot.snapshot = null;
  autopilot.exitPending = false;

  autopilot.marketNow = 'wait';
  autopilot.current_price = null;
  autopilot.pnl = null;
  autopilot.rMultiple = null;
  autopilot.lastUpdate = null;

  apSave(autopilot);

  if (els?.apToggle) els.apToggle.checked = false;
  if (typeof apSyncUI === 'function') apSyncUI();
  if (typeof loadPanel === 'function') loadPanel(false);
}




   // ====== SIZING BRAIN – CAMPOS DO CARD COMPLETO ======
const sbEls = {
  card: document.getElementById('sizing-brain-card'),
  accountBalance: document.getElementById('sb-account-balance'),
  leverage: document.getElementById('sb-leverage'),
  tradeCapital: document.getElementById('sb-trade-capital'),
  riskPercentInput: document.querySelector('input#sb-risk-percent'),
  entryPrice: document.getElementById('sb-entry-price'),
  atrValue: document.getElementById('sb-atr-value'),
  atrMultStop: document.getElementById('sb-atr-mult-stop'),
  atrMultTake: document.getElementById('sb-atr-mult-take'),
  sideRadios: document.querySelectorAll('input[name="sb-side"]'),

  outStopDistance: document.getElementById('sb-stop-distance'),
  outStopPrice: document.getElementById('sb-stop-price'),
  outTakePrice: document.getElementById('sb-take-price'),
  outPositionSize: document.getElementById('sb-position-size'),
  outRiskDollar: document.getElementById('sb-risk-dollar'),
  outRiskPercent: document.querySelector('p#sb-risk-percent'),

  calcBtn: document.getElementById('sb-calcular'),
  status: document.getElementById('sb-status'),
};

    // ====== SIZING BRAIN OFFLINE – CÁLCULO COMPLETO ======
function sbNum(el) {
  if (!el) return 0;
  const raw = (el.value || '').toString().replace(',', '.');
  const n = Number(raw);
  return Number.isFinite(n) ? n : 0;
}

function recalcSizingBrainOffline() {
  if (!sbEls.accountBalance) return;

  const account    = sbNum(sbEls.accountBalance);   // capital real da conta
  const leverage   = sbNum(sbEls.leverage);         // alavancagem (x)
  const tradeInput = sbNum(sbEls.tradeCapital);     // capital em uso neste trade
  const riskPct    = sbNum(sbEls.riskPercentInput); // risco % por trade (da conta)
  const entry      = sbNum(sbEls.entryPrice);       // preço de entrada
  const atr        = sbNum(sbEls.atrValue);         // ATR $
  const multStop   = sbNum(sbEls.atrMultStop);      // mult stop
  const multTake   = sbNum(sbEls.atrMultTake);      // mult take

  const sideRadio  = Array.from(sbEls.sideRadios || []).find(r => r.checked);
  const side       = sideRadio ? sideRadio.value : 'long';

  const statusEl   = sbEls.status;

  // validações básicas
  if (!account || !entry || !atr || !multStop || !riskPct) {
    if (statusEl) {
      statusEl.textContent =
        (typeof currentLang !== 'undefined' && currentLang === 'en')
          ? 'Fill account, risk %, entry price and ATR to calculate.'
          : 'Preencha conta, risco %, preço de entrada e ATR para calcular.';
    }
    return;
  }

  // buying power = conta * alavancagem
  const lev = leverage > 0 ? leverage : 1;
  const buyingPower = account * lev;

  // capital em uso: se não preencher, usamos o buying power
  let tradeCapital = tradeInput > 0 ? tradeInput : buyingPower;
  if (tradeCapital > buyingPower) tradeCapital = buyingPower;

  const stopDist = atr * multStop; // distância do stop em dólar
  if (!stopDist) {
    if (statusEl) {
      statusEl.textContent =
        (typeof currentLang !== 'undefined' && currentLang === 'en')
          ? 'Stop distance (ATR × mult) is zero. Check ATR and multiplier.'
          : 'Distância do stop (ATR × mult) está zero. Confira ATR e multiplicador.';
    }
    return;
  }

  // risco máximo permitido pela regra (risco % da conta)
  const riskAllowedDollar = account * (riskPct / 100);

  // limite por capital e por risco
  const maxSharesByCapital = tradeCapital / entry;
  const maxSharesByRisk    = riskAllowedDollar / stopDist;
  let shares               = Math.floor(Math.max(0, Math.min(maxSharesByCapital, maxSharesByRisk)));

  if (!Number.isFinite(shares) || shares <= 0) {
    shares = 0;
  }

  const riskUsedDollar       = shares * stopDist;
  const riskUsedPctAccount   = account > 0 ? (riskUsedDollar / account) * 100 : 0;

  // preços de stop e alvo
  let stopPrice, takePrice;
  if (side === 'short') {
    stopPrice = entry + stopDist;
    takePrice = entry - (atr * multTake);
  } else {
    stopPrice = entry - stopDist;
    takePrice = entry + (atr * multTake);
  }

  // ====== escreve nos campos ======
  if (sbEls.outStopDistance) {
    sbEls.outStopDistance.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Stop distance: '
        : 'Distância do STOP: ') +
      stopDist.toFixed(2) +
      ' USD';
  }

  if (sbEls.outStopPrice) {
    sbEls.outStopPrice.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Suggested Stop Loss: '
        : 'Stop Loss sugerido: ') +
      '$ ' +
      stopPrice.toFixed(2);
  }

  if (sbEls.outTakePrice) {
    sbEls.outTakePrice.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Suggested Take Profit: '
        : 'Take Profit sugerido: ') +
      '$ ' +
      takePrice.toFixed(2);
  }

  if (sbEls.outPositionSize) {
    sbEls.outPositionSize.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Suggested size: '
        : 'Qtd sugerida: ') +
      (shares > 0 ? shares + ' shares' : '—');
  }

  if (sbEls.outRiskDollar) {
    sbEls.outRiskDollar.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Approx. risk: '
        : 'Risco aprox.: ') +
      '$ ' +
      riskUsedDollar.toFixed(2);
  }

  if (sbEls.outRiskPercent) {
    sbEls.outRiskPercent.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Risk % trade / account: '
        : 'Risco % trade / conta: ') +
      riskUsedPctAccount.toFixed(2) +
      '%';
  }

  // ====== termômetro do Sizing Brain offline ======
  const meterFill  = document.getElementById('sb-meter-fill');
  const meterLabel = document.getElementById('sb-meter-label');

  if (meterFill && meterLabel) {
    // uso de risco = quanto do risco permitido (riskAllowedDollar) você está usando
    let usage = riskAllowedDollar > 0
      ? (riskUsedDollar / riskAllowedDollar) * 100
      : 0;

    // clamp
    usage = Math.max(0, Math.min(usage, 150));
    const width = Math.max(0, Math.min(usage, 100));

    meterFill.style.width = width.toFixed(0) + '%';
    meterFill.classList.remove('safe', 'warn', 'danger');

    let modeClass = 'safe';
    if (usage <= 60) {
      modeClass = 'safe';
    } else if (usage <= 100) {
      modeClass = 'warn';
    } else {
      modeClass = 'danger';
    }
    meterFill.classList.add(modeClass);

    meterLabel.textContent =
      (typeof currentLang !== 'undefined' && currentLang === 'en'
        ? 'Risk usage '
        : 'Uso de risco ') +
      usage.toFixed(0) +
      '%';
  }

  // ====== status em texto ======
  if (statusEl) {
    if (!shares) {
      statusEl.textContent =
        (typeof currentLang !== 'undefined' && currentLang === 'en'
          ? 'Position too small or zero. Check risk %, ATR and stop distance.'
          : 'Posição muito pequena ou zero. Confira risco %, ATR e distância do stop.');
    } else if (usage > 100) {
      statusEl.textContent =
        (typeof currentLang !== 'undefined' && currentLang === 'en'
          ? 'You are using more than 100% of the risk you defined. Consider reducing size or widening the base capital.'
          : 'Você está usando mais de 100% do risco que definiu. Considere reduzir o tamanho ou ajustar o capital base.');
    } else {
      statusEl.textContent =
        (typeof currentLang !== 'undefined' && currentLang === 'en'
          ? 'Sizing calculated. Size stays within your defined risk. Execute only if setup is A+.'
          : 'Sizing calculado. Tamanho dentro do risco que você definiu. Execute apenas se o setup for A+.');
    }
  }
}

// liga o botão "Recalcular Sizing"
if (sbEls.calcBtn) {
  sbEls.calcBtn.addEventListener('click', function (e) {
    e.preventDefault();
    recalcSizingBrainOffline();
  });
}


// dados atuais do "cérebro de pullback" para re-renderizar quando trocar PT/EN
let lastPullbackBrain = null;
let lastSizingBrain = null;


// ====== GERENCIADOR DE RISCO · ATR (FRONTEND) ======
const atrEls = {
  panel: document.getElementById('atr-risk-panel'),
  toggleBtn: document.getElementById('atr-risk-toggle'),
  body: document.getElementById('atr-risk-body'),
  length: document.getElementById('atr-length-input'),
  smoothing: document.getElementById('atr-smoothing-input'),
  mult: document.getElementById('atr-multiplier-input'),
  atrValue: document.getElementById('atr-value-input'),
  capital: document.getElementById('atr-capital-input'),
  entry: document.getElementById('atr-entry-input'),
  riskPercent: document.getElementById('atr-riskpct-input'),
  side: document.getElementById('atr-side-input'),
  outDistance: document.getElementById('atr-stop-distance'),
  outShares: document.getElementById('atr-shares'),
  outRisk: document.getElementById('atr-risk-money'),
  outReward2R: document.getElementById('atr-reward-2r'),
  outReward3R: document.getElementById('atr-reward-3r'),
  calcBtn: document.getElementById('atr-calc-btn'),
};

// abre / fecha o card
if (atrEls.toggleBtn && atrEls.body) {
  atrEls.toggleBtn.addEventListener('click', () => {
    const hidden =
      atrEls.body.style.display === 'none' || atrEls.body.style.display === '';
    atrEls.body.style.display = hidden ? 'grid' : 'none';
    atrEls.toggleBtn.textContent = hidden ? 'Fechar' : 'Abrir';
  });
}

// cálculo do risco baseado no ATR digitado
function updateAtrRisk() {
  if (!atrEls.atrValue || !atrEls.capital || !atrEls.entry) return;

  const atr = parseFloat(atrEls.atrValue.value || '0');
  const mult = parseFloat(atrEls.mult.value || '1');
  const capital = parseFloat(atrEls.capital.value || '0');
  const entry = parseFloat(atrEls.entry.value || '0');
  const riskPct = parseFloat(atrEls.riskPercent.value || '1');

  if (!atr || !capital || !entry) return;

  const stopDist = atr * mult;
  const riskPerShare = stopDist;

  const sharesByCapital = capital / entry;
  const sharesByRisk = (capital * (riskPct / 100)) / riskPerShare;
  const shares = Math.min(sharesByCapital, sharesByRisk);

  const riskMoney = shares * riskPerShare;
  const reward2R = riskMoney * 2;
  const reward3R = riskMoney * 3;

  if (atrEls.outDistance) atrEls.outDistance.textContent = stopDist.toFixed(2);
  if (atrEls.outShares) atrEls.outShares.textContent = shares.toFixed(0);
  if (atrEls.outRisk) atrEls.outRisk.textContent = '$ ' + riskMoney.toFixed(2);
  if (atrEls.outReward2R)
    atrEls.outReward2R.textContent = '$ ' + reward2R.toFixed(2);
  if (atrEls.outReward3R)
    atrEls.outReward3R.textContent = '$ ' + reward3R.toFixed(2);
}

if (atrEls.calcBtn) {
  atrEls.calcBtn.addEventListener('click', (e) => {
    e.preventDefault();
    updateAtrRisk();
  });
}

// Preenche ATR + preço de entrada a partir do JSON (panel + raw)
function prefillAtrFromPanel(panel, raw) {
  if (!panel || !atrEls) return;

  const atrBlock = panel.atr || panel.atr_info;
  const indicators = raw && raw.indicators ? raw.indicators : {};

  // ATR
  if (atrBlock && atrBlock.value != null && atrEls.atrValue) {
    atrEls.atrValue.value = Number(atrBlock.value).toFixed(2);
  } else if (typeof indicators.atr === 'number' && atrEls.atrValue) {
    atrEls.atrValue.value = indicators.atr.toFixed(2);
  }

  if (atrBlock && atrBlock.length != null && atrEls.length) {
    atrEls.length.value = atrBlock.length;
  }
  if (atrBlock && atrBlock.smoothing && atrEls.smoothing) {
    atrEls.smoothing.value = atrBlock.smoothing;
  }
  if (atrBlock && atrBlock.multiplier != null && atrEls.mult) {
    atrEls.mult.value = atrBlock.multiplier;
  }

  // PREÇO DE ENTRADA
  let entry =
    panel.entry_price ||
    panel.reference_price ||
    panel.price_now ||
    panel.last_price ||
    (raw && raw.candle && raw.candle.close);

  if (entry != null && atrEls.entry) {
    atrEls.entry.value = Number(entry).toFixed(2);
  }
}

function safeText(el, value, fallback = '—') {
  if (!el) return;
  el.textContent =
    value === undefined || value === null || value === ''
      ? fallback
      : String(value);
}

function escapeHTML(str) {
  return String(str)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

// Puxa "Estatística: ...." de dentro do comentário (PT/EN) e remove do comentário
function splitStatsFromComment(raw) {
  const out = { stats: '', comment: '' };
  if (raw === undefined || raw === null) return out;

  let s = String(raw);

  // remove aspas bonitas do começo/fim se vierem
  s = s.replace(/^[“"]+/, '').replace(/[”"]+$/, '');

  // pega a LINHA INTEIRA: "📊 Estatística (7y): ...." (PT/EN) sem remover do comentário
  const rx =
    /(?:^|\n)\s*(?:📊\s*)?(?:estat[ií]stica(?:\s*\([^)]*\))?|statistics(?:\s*\([^)]*\))?|stats(?:\s*\([^)]*\))?)\s*:\s*.+?(?=\n|$)/i;

  const m = s.match(rx);
  if (m) out.stats = m[0].trim();

  out.comment = s.trim(); // mantém intacto
  return out;
}


function formatCommentToHTML(raw) {
  if (raw === undefined || raw === null) return '<div class="comment-lines"><div class="comment-line">—</div></div>';

  let s = String(raw).trim();
  s = s.replace(/^[“"]+/, '').replace(/[”"]+$/, '');

  // quebra por linhas / bullets
  let lines = s
    .split(/\r?\n|•|\u2022/g)
    .map(x => x.trim())
    .filter(Boolean);

  // se veio tudo numa frase gigante, quebra por sentenças
  if (lines.length <= 1 && s.length > 90) {
    lines = s
      .split(/(?<=[.!?])\s+/g)
      .map(x => x.trim())
      .filter(Boolean);
  }

  const html = lines.map(line => {
    const idx = line.indexOf(':');
    // Se parecer "Título: texto", deixa o título em bold
    if (idx > 0 && idx <= 28) {
      const key = line.slice(0, idx + 1);
      const val = line.slice(idx + 1).trim();
      return `<div class="comment-line"><strong>${escapeHTML(key)}</strong> ${escapeHTML(val)}</div>`;
    }
    return `<div class="comment-line">${escapeHTML(line)}</div>`;
  }).join('');

  return `<div class="comment-lines">${html || '<div class="comment-line">—</div>'}</div>`;
}

function setFormattedComment(el, raw) {
  if (!el) return;
  el.innerHTML = formatCommentToHTML(raw);
}


function setArrow(el, dir) {
  if (!el) return;
  el.classList.remove('arrow-up', 'arrow-down');
  let symbol = '↕';
  if (dir === 'up' || dir === 'UP' || dir === 'alta' || dir === 'ALTA') {
    el.classList.add('arrow-up');
    symbol = '↑';
  } else if (dir === 'down' || dir === 'DOWN' || dir === 'baixa' || dir === 'BAIXA') {
    el.classList.add('arrow-down');
    symbol = '↓';
  }
  el.textContent = symbol;
}

function setPillTrend(el, dir, label) {
  if (!el) return;
  el.classList.remove('pill-green', 'pill-red');
  let txt = label || 'Neutro';

  if (!dir) {
    el.textContent = txt;
    return;
  }

  const d = String(dir).toLowerCase();

  if (d.includes('alta') || d === 'up') {
    el.classList.add('pill-green');
    if (!label) txt = 'Fluxo de alta';
  } else if (d.includes('baixa') || d === 'down') {
    el.classList.add('pill-red');
    if (!label) txt = 'Fluxo de baixa';
  }

  el.textContent = txt;
}

function setRiskPill(level) {
  if (!els.riskPill) return;
  const el = els.riskPill;
  el.classList.remove('pill-green', 'pill-red');
  let txt = 'Neutro';

  if (!level) {
    el.textContent = txt;
    return;
  }

  const l = String(level).toLowerCase();

  if (l.includes('alto') || l.includes('high')) {
    el.classList.add('pill-red');
    txt = 'Risco Alto';
  } else if (l.includes('baixo') || l.includes('low')) {
    el.classList.add('pill-green');
    txt = 'Risco Baixo';
  } else {
    txt = level;
  }

  el.textContent = txt;
}

// === ATUALIZAR CARTÃO DE TRADE (CITADEL) ===
function updateTradeCard(trade) {
  // se o HTML ainda não carregou, sai
  if (!els.tradeStatusText) return;

  const t = trade || {};
    lastTradeCard = t;

  const lang = currentLang === 'en' ? 'en' : 'pt';

  // helpers para pegar PT/EN
  const pick = (obj, baseKey) => {
    if (!obj) return null;
    if (lang === 'en') return obj[baseKey + '_en'] || obj[baseKey];
    return obj[baseKey + '_pt'] || obj[baseKey];
  };

  // ===== texto de status (linha de cima) =====
  const statusText =
    pick(t, 'status_text') ||
    pick(t, 'status') ||
    (lang === 'en'
      ? '✅ Valid setup | ❌ No trade'
      : '✅ Setup válido | ❌ Sem trade');

  els.tradeStatusText.textContent = statusText;

  // ===== campos “neutros” (sem idioma) =====
  safeText(els.tradeSymbol,    t.symbol   || t.ticker || '—');
  safeText(els.tradeTimeframe, t.timeframe || t.tf    || '—');
  safeText(els.tradeEntry,     t.entry_text || t.entry_range || t.entry || '—');
  safeText(els.tradeStop,      t.stop      != null ? t.stop      : '—');
  safeText(els.tradeTP1,       t.tp1       != null ? t.tp1       : '—');
  safeText(els.tradeTP2,       t.tp2       != null ? t.tp2       : '—');
  safeText(els.tradeSize,      t.size_text || t.size || '—');
  safeText(els.tradeRisk,      t.risk_text || t.risk || '—');
  safeText(els.pulseLine, pick(t, 'pulse_line') || '—');


  // ===== textos com PT/EN =====
  const modeText =
    pick(t, 'mode') ||
    (lang === 'en' ? 'Reversal at resistance' : 'Reversão em Resistência');

  const againstText =
    pick(t, 'against') ||
    (t.against_text || t.against_pct) ||
    (lang === 'en' ? '—' : '—');

  const directionText =
    pick(t, 'direction') ||
    (lang === 'en' ? 'SELL' : 'VENDA');

  const thermoText =
    pick(t, 'thermo') ||
    pick(t, 'thermometer') ||
    (lang === 'en' ? 'Moderately aggressive' : 'Agressivo moderado');

  const commentText =
    pick(t, 'comment') ||
    (lang === 'en'
      ? 'Statistically strong reversal after false breakout. If you execute, do not move the stop against the position.'
      : 'Reversão estatisticamente forte após falso rompimento. Se executar, não mova o stop contra a posição.');

  safeText(els.tradeMode,    modeText);
  safeText(els.tradeAgainst, againstText);
  safeText(els.tradeDirection, directionText);
    // ===== AUTOPILOT override (trava o card no estado da posição) =====
  autopilot = apLoad();
  apSyncUI();

  if (autopilot.enabled && autopilot.active && (autopilot.side === 'buy' || autopilot.side === 'sell')) {
    const sideLabel = apSideLabel(autopilot.side, lang);
    const entry = autopilot.entry != null ? autopilot.entry.toFixed(2) : '—';

    // status no topo
    els.tradeStatusText.textContent = (lang === 'en')
      ? `🧠 AUTOPILOT ON | Simulating position: ${sideLabel} @ ${entry}`
      : `🧠 AUTOPILOT ON | Simulando posição: ${sideLabel} @ ${entry}`;

    // força direção do card
    safeText(els.tradeDirection, sideLabel);

        // 2.0: empurra capital/units pro Cartão Citadel
    const px = apGetMarketPrice() ?? autopilot.entry;
    const units = apComputeUnits(autopilot.capital, px);

    if (els.tradeSize) {
      if (lang === 'en') {
        const capTxt = apMoneyEN(autopilot.capital);
        const uTxt = (units != null) ? `${units.toLocaleString('en-US')} shares` : '—';
        els.tradeSize.textContent = `${capTxt} · ${uTxt}`;
      } else {
        const capTxt = apMoneyPT(autopilot.capital);
        const uTxt = (units != null) ? `${units.toLocaleString('pt-BR')} ações` : '—';
        els.tradeSize.textContent = `${capTxt} · ${uTxt}`;
      }
    }


    // troca “skin” buy/sell do card
    if (els.tradeCard) {
      els.tradeCard.classList.remove('status-buy','status-sell','status-neutral');
      els.tradeCard.classList.add(autopilot.side === 'buy' ? 'status-buy' : 'status-sell');
    }

    // badge vira “HOLD / EM POSIÇÃO”
    if (els.tradeBadge) {
      els.tradeBadge.classList.remove('buy','sell');
      els.tradeBadge.classList.add(autopilot.side === 'buy' ? 'buy' : 'sell');
      els.tradeBadge.textContent = (lang === 'en') ? 'IN POSITION' : 'EM POSIÇÃO';
    }
  }

  safeText(els.tradeThermo, thermoText);

// --- estatística: pega do JSON (normal) ---
const parsed = splitStatsFromComment(commentText);

// Estatística “normal” do campo do cartão (não usa a linha do comentário)
const setupStatsText =
  pick(t, 'stats_text') ||
  pick(t, 'statistics_text') ||
  pick(t, 'stats') ||
  pick(t, 'statistics') ||
  '—';

safeText(els.tradeStats, setupStatsText, '—');

// NOVO: Estatística (7y) no topo — vem do comentário (ou cai pro JSON)
const topStatsText = parsed.stats || setupStatsText || '—';

if (els.tradeStatsTop) safeText(els.tradeStatsTop, topStatsText, '—');

if (els.tradeStatsTopLine) {
  const s = (topStatsText || '').trim();
  const hasStats = s && s !== '—' && s !== '-';
  els.tradeStatsTopLine.style.display = hasStats ? '' : 'none';

  // garante "Com estatística" no Status quando existir
  if (hasStats && els.tradeStatusText) {
    const token = (lang === 'en') ? 'With stats' : 'Com estatística';
    const cur = els.tradeStatusText.textContent || '';
    if (!cur.toLowerCase().includes(token.toLowerCase())) {
      els.tradeStatusText.textContent = `${cur} | ${token}`;
    }
  }
}

// Comentário: NÃO remove nada
setFormattedComment(els.tradeComment, parsed.comment || commentText);



  // ===== visual do cartão (cor / badge) =====
  const card  = els.tradeCard;
  const badge = els.tradeBadge;

  if (card) {
    card.classList.remove('status-buy', 'status-sell', 'status-wait', 'status-no-trade');

    const side = (t.side || t.direction || '').toString().toLowerCase();
    const state = (t.state || t.trade_state || '').toString().toLowerCase();

    let modeClass = 'status-wait';

    if (state.includes('no') || state.includes('sem')) {
      modeClass = 'status-no-trade';
    } else if (side.includes('buy') || side.includes('compra')) {
      modeClass = 'status-buy';
    } else if (side.includes('sell') || side.includes('venda')) {
      modeClass = 'status-sell';
    }

    card.classList.add(modeClass);
  }

  if (badge) {
    const rawBadge = (t.badge || t.mode_badge || '').toString().toLowerCase();

    let text;
    if (rawBadge.includes('wait') || rawBadge.includes('aguardar')) {
      text = 'WAIT';
    } else if (rawBadge.includes('no')) {
      text = 'NO TRADE';
    } else if (rawBadge) {
      text = rawBadge.toUpperCase();
    } else {
      text = 'GO FULL';
    }

    badge.textContent = text;
  }
}


function applyHeroDecision(executionPlan, riskLevel, finalSummary) {
  const lang = (typeof currentLang !== 'undefined' ? currentLang : 'pt');

  // ✅ Suporta IDs antigos (camelCase) e os da sua UI nova (kebab-case)
  const heroModePill =
    document.getElementById('heroModePill') ||
    document.getElementById('hero-mode-pill');

  const heroMain =
    document.getElementById('heroMain') ||
    document.getElementById('hero-main') ||
    null;

  const heroSummary =
    document.getElementById('heroSummary') ||
    document.getElementById('hero-summary-text') ||
    null;

  const heroSideLabel =
    document.getElementById('heroSideLabel') ||
    document.getElementById('hero-side-label') ||
    null;

  const heroSecondary =
    document.getElementById('heroSecondary') ||
    document.getElementById('hero-mini-context') ||
    null;

  const heroBadge =
    document.getElementById('status-hero-badge') ||
    document.querySelector('.status-hero-badge') ||
    null;

  // ✅ Se a UI não tiver esses elementos, simplesmente não faz nada (NUNCA quebra o painel)
  if (!heroModePill && !heroSummary && !heroSideLabel && !heroBadge && !heroMain && !heroSecondary) {
    return;
  }

  // --- Market Now / direção (com fallback seguro)
  const marketNow =
    (apCtx && apCtx.panel && (apCtx.panel.market_now || apCtx.panel.marketNow)) ||
    autopilot.marketNow ||
    null;

  const mn =
    (marketNow === 'buy' || marketNow === 'BUY') ? 'buy' :
    (marketNow === 'sell' || marketNow === 'SELL') ? 'sell' :
    'wait';

  const mnText = (mn === 'buy') ? 'BUY' : (mn === 'sell') ? 'SELL' : 'WAIT';

  // Texto principal/summary
  const summaryText = String(finalSummary || executionPlan || '—');

  // Side label (PT/EN)
  const sideLabel =
    (mn === 'buy') ? (lang === 'en' ? 'BUY' : 'COMPRA') :
    (mn === 'sell') ? (lang === 'en' ? 'SELL' : 'VENDA') :
    'WAIT';

  // ✅ Aplica sem quebrar (tudo com guard)
  if (heroSummary) heroSummary.textContent = summaryText;
  if (heroSideLabel) heroSideLabel.textContent = sideLabel;

  if (heroModePill) {
    heroModePill.textContent = mnText;
    // classes esperadas no seu CSS atual
    heroModePill.classList.remove('go-full', 'wait', 'buy', 'sell');
    if (mn === 'wait') heroModePill.classList.add('wait');
    else heroModePill.classList.add('go-full');
  }

  if (heroBadge) {
    // se for wait -> badge WAIT, senão GO FULL (como seu layout)
    heroBadge.textContent = (mn === 'wait') ? 'WAIT' : 'GO FULL';
  }

  // Se existir “main/secondary” no layout antigo, preenche também
  if (heroMain) heroMain.textContent = mnText;
  if (heroSecondary) heroSecondary.textContent = summaryText;
}



  

function applyInstitutionalDecision(panel, executionPlan, riskLevel) {
  // se o HTML não existe (ou não é essa página), sai
  if (!els.heroFavorBar || !els.heroContraBar) return;

  const baseText = executionPlan || '—';
  const t = (baseText || '').toLowerCase();

  let mode = 'wait';
  if (t.includes('compra') || t.includes('buy')) mode = 'buy';
  else if (t.includes('venda') || t.includes('sell')) mode = 'sell';

  // pega consensus real do JSON
  const c =
    (panel && (panel.ai_consensus || panel.consensus || panel.aiConsensus)) || {};

  const normPct = (v) => {
  if (v === null || v === undefined) return NaN;

  if (typeof v === 'string') {
    v = v.replace('%', '').trim().replace(',', '.');
  }

  const n = parseFloat(v);
  if (!Number.isFinite(n)) return NaN;

  // aceita 0–1 OU 0–100
  if (n >= 0 && n <= 1) return n * 100;
  return n;
};


  const buyRaw = c.buy ?? c.BUY ?? c.long ?? c.LONG ?? c.compra ?? c.call ?? c.bull ?? c.bullish ?? c.up;
const sellRaw = c.sell ?? c.SELL ?? c.short ?? c.SHORT ?? c.venda ?? c.put ?? c.bear ?? c.bearish ?? c.down;
const neuRaw  = c.neutral ?? c.NEUTRAL ?? c.flat ?? c.wait ?? c.hold ?? c.aguardar ?? c.sideways ?? c.range;

let buy = normPct(buyRaw);
let sell = normPct(sellRaw);
let neu = normPct(neuRaw);


  buy = Number.isFinite(buy) ? buy : 0;
  sell = Number.isFinite(sell) ? sell : 0;
  neu = Number.isFinite(neu) ? neu : 0;

    // transforma 3-way em 2 barras (buy vs sell) de forma “institucional”
  const dirTotal = buy + sell;
  const total = buy + sell + neu;

  let favorPct = 0;
  let contraPct = 0;

  if (dirTotal > 0) {
    const favorRaw =
      mode === 'sell' ? sell :
      mode === 'buy'  ? buy  :
      Math.max(buy, sell); // wait -> mostra o lado mais forte (entre buy/sell)

    favorPct = Math.round((favorRaw / dirTotal) * 100);
    favorPct = Math.max(0, Math.min(100, favorPct));
    contraPct = 100 - favorPct;

  } else if (total > 0) {
    // ✅ Se não há BUY/SELL (só NEUTRAL), não existe “vantagem” direcional
    // então mostramos equilíbrio (50/50) em vez de 100%
    favorPct = 50;
    contraPct = 50;
  }

  // labels + barras
  if (els.heroFavorLabel) els.heroFavorLabel.textContent = `A favor: ${favorPct}%`;
  if (els.heroContraLabel) els.heroContraLabel.textContent = `Contra: ${contraPct}%`;

  // ✅ SAFE: nunca deixa isso quebrar o resto do painel (e o TradingView)
  if (els.heroFavorBar) els.heroFavorBar.style.width = `${favorPct}%`;
  if (els.heroContraBar) els.heroContraBar.style.width = `${contraPct}%`;


  // frases (realistas, mas derivadas de dado real)
  const favorPhrase =
    favorPct >= 70
      ? 'Continuação muito provável. Fluxo bem alinhado com a direção atual. Operar a favor é mais seguro que contra.'
      : favorPct >= 55
        ? 'Leve vantagem a favor. Fluxo parcialmente alinhado; reduza tamanho e exija confirmação.'
        : 'Sem vantagem clara. A favor e contra estão equilibrados; prefira esperar ou operar menor.';

  const contraPhrase =
    contraPct >= 35
      ? 'Probabilidade moderada de reação contra ainda existe; evite alavancagem exagerada e respeite o stop.'
      : 'Contra-movimento menos provável, mas sempre possível; disciplina de stop obrigatória.';

  if (els.heroFavorPhrase) els.heroFavorPhrase.textContent = favorPhrase;
  if (els.heroContraPhrase) els.heroContraPhrase.textContent = contraPhrase;

  // minis (RISCO / CONTEXTO / EXECUÇÃO)
  if (els.heroMiniRisk) els.heroMiniRisk.textContent = riskLevel || '—';

  const ctx =
    panel?.context_tag ||
    panel?.context_short ||
    panel?.trade_window ||
    panel?.session_window ||
    panel?.session ||
    panel?.window ||
    panel?.time_window ||
    panel?.trade_style ||
    panel?.style_today ||
    panel?.style_label_pt ||
    panel?.style_label_en ||
    '—';

  if (els.heroMiniContext) els.heroMiniContext.textContent = ctx;
  if (els.heroMiniExecution) els.heroMiniExecution.textContent = baseText;
}


// Atualiza os chips HH/HL/LH/LL a partir do JSON
function updateStructureUI(struct) {
  const map = [
    { key: 'hh', status: els.structureHHStatus, dot: els.structureHHDot },
    { key: 'hl', status: els.structureHLStatus, dot: els.structureHLDot },
    { key: 'lh', status: els.structureLHStatus, dot: els.structureLHDot },
    { key: 'll', status: els.structureLLStatus, dot: els.structureLLDot },
  ];

  map.forEach(({ key, status, dot }) => {
    if (!status || !dot) return;

    let rawVal =
      struct &&
      (struct[key] ??
        struct[key.toUpperCase()] ??
        struct['recent_' + key] ??
        struct['last_' + key]);

    let label = 'off';
    let active = false;

    if (typeof rawVal === 'string') {
      const v = rawVal.toLowerCase();
      if (
        v.includes('ativo') ||
        v.includes('on') ||
        v.includes('true') ||
        v.includes('active')
      ) {
        active = true;
      }
      if (v) label = rawVal;
    } else if (typeof rawVal === 'boolean') {
      active = rawVal;
      label = rawVal ? 'ativo' : 'off';
    }

    status.textContent = label;
    if (active) dot.classList.add('on');
    else dot.classList.remove('on');
  });
}

// Atualiza o desenho do ZigZag, se o JSON mandar pontos
function updateStructureZigzag(panel) {
  const poly = document.getElementById('structure-zigzag-poly');
  if (!poly || !panel) return;

  const pts =
    panel.structure_points ||
    panel.zigzag_points ||
    panel.market_structure_points;

  if (!Array.isArray(pts) || pts.length === 0) return;

  const n = pts.length;
  const step = n > 1 ? 100 / (n - 1) : 100;

  const svgPoints = pts.map((v, i) => {
    const yNorm = Math.max(0, Math.min(1, Number(v))); // 0–1
    const x = (step * i).toFixed(2);
    const y = (30 - yNorm * 20).toFixed(2); // faixa 10–30 no SVG
    return `${x},${y}`;
  });

  poly.setAttribute('points', svgPoints.join(' '));
}

// ====== PULLBACK BRAIN – FUNÇÃO GLOBAL ======
function updatePullbackBrain(data) {
  lastPullbackBrain = data || null;

  if (!els.pullbackStatus) return;

  // helpers para classe do termômetro
  function setMeter(score, tone) {
    const fill = els.pullbackMeterFill;
    const label = els.pullbackMeterLabel;
    if (!fill || !label) return;

    let v = score;

if (typeof v === 'string') {
  v = v.replace('%', '').trim().replace(',', '.');
}
v = parseFloat(v);

if (!Number.isFinite(v)) v = 40; // fallback (só quando não vem dado)
v = Math.max(0, Math.min(100, v));


    fill.style.width = v.toFixed(0) + '%';

    fill.classList.remove('neutral', 'danger');
    if (tone === 'red' || tone === 'danger') {
      fill.classList.add('danger');
    } else if (tone === 'yellow' || tone === 'neutral') {
      fill.classList.add('neutral');
    }

    label.textContent =
      (currentLang === 'en' ? 'Confidence ' : 'Confiança ') +
      v.toFixed(0) +
      '%';
  }

  function setSideTag(side) {
    const tag = els.pullbackSideTag;
    if (!tag) return;

    const s = (side || '').toString().toLowerCase();
    tag.classList.remove('side-buy', 'side-sell', 'side-neutral');

    if (s === 'buy' || s === 'compra') {
      tag.classList.add('side-buy');
      tag.textContent = currentLang === 'en' ? 'BUY PULLBACK' : 'COMPRA';
    } else if (s === 'sell' || s === 'venda') {
      tag.classList.add('side-sell');
      tag.textContent = currentLang === 'en' ? 'SELL PULLBACK' : 'VENDA';
    } else {
      tag.classList.add('side-neutral');
      tag.textContent = currentLang === 'en' ? 'NEUTRAL' : 'NEUTRO';
    }
  }

  function setStageTag(stageTitle) {
    const tag = els.pullbackStageTag;
    if (!tag) return;

    const txt =
      stageTitle ||
      (currentLang === 'en' ? 'Waiting' : 'Aguardando');
    tag.textContent = txt;
  }

  // ===== CASO SEM DADOS (estado neutro) =====
  if (!data || Object.keys(data).length === 0) {
    els.pullbackStatus.textContent =
      currentLang === 'en' ? 'Waiting for pullback...' : 'Aguardando pullback...';

    if (els.pullbackDepth) els.pullbackDepth.textContent = '—';
    if (els.pullbackQuality) els.pullbackQuality.textContent = '—';

    if (els.pullbackHeadline) {
      els.pullbackHeadline.textContent =
        currentLang === 'en'
          ? 'No clear pullback yet.'
          : 'Ainda não há um pullback claro.';
    }

    if (els.pullbackText) {
      els.pullbackText.textContent =
        currentLang === 'en'
          ? 'The market has not offered a clean pullback in the main direction yet. Let price breathe and wait for structure.'
          : 'O mercado ainda não ofereceu um pullback limpo na direção principal. Deixe o preço respirar e espere estrutura.';
    }

    if (els.pullbackHighlightBox) {
      els.pullbackHighlightBox.style.background = 'rgba(15,23,42,0.7)';
      els.pullbackHighlightBox.style.borderColor = 'rgba(148,163,184,0.4)';
    }

    setSideTag(null);
    setStageTag(null);
    setMeter(40, 'neutral');
    return;
  }

  // ===== campos numéricos / status =====
  const depthAtr = data.depth_atr ?? data.atr_depth ?? null;
  const quality = data.quality ?? data.grade ?? null;
  const tone = (data.tone || '').toLowerCase();
  const side = data.side || data.direction || null;
  const score = data.score ?? data.confidence ?? 40;

  // título principal (usa state_title_pt/en se tiver)
  const statusTitle =
    (currentLang === 'en'
      ? (data.state_title_en || data.status_en || data.state_title || data.status)
      : (data.state_title_pt || data.status_pt || data.state_title || data.status)) ||
    (currentLang === 'en'
      ? 'Pullback detected'
      : 'Pullback detectado');

  els.pullbackStatus.textContent = statusTitle;

  if (els.pullbackDepth) {
    els.pullbackDepth.textContent =
      depthAtr != null ? depthAtr.toFixed(2) + ' ATR' : '—';
  }

  if (els.pullbackQuality) {
    els.pullbackQuality.textContent = quality || '—';
  }

  setSideTag(side);

  // estágio (1..7 – aquelas frases que fizemos: tendência, pullback fraco, reversão, etc.)
  const stageTitle =
    (currentLang === 'en'
      ? (data.stage_title_en || data.stage_title)
      : (data.stage_title_pt || data.stage_title)) || null;
  setStageTag(stageTitle);

  // ===== textos em PT / EN vindos do backend =====
  const headline =
    (currentLang === 'en'
      ? (data.headline_en || data.headline)
      : (data.headline_pt || data.headline)) ||
    (currentLang === 'en'
      ? 'Healthy pullback inside the main trend.'
      : 'Pullback saudável dentro da tendência principal.');

  const body =
    (currentLang === 'en'
      ? (data.text_en || data.text)
      : (data.text_pt || data.text)) ||
    (currentLang === 'en'
      ? 'AARON 9 sees this pullback as aligned with the main direction. Focus on trades with the trend and avoid fighting the move.'
      : 'O AARON 9 vê este pullback como alinhado com a direção principal. Foque em operações a favor e evite brigar com o movimento.');

  if (els.pullbackHeadline) els.pullbackHeadline.textContent = headline;
  if (els.pullbackText) els.pullbackText.textContent = body;

  // ===== cor do bloco (verde / amarelo / vermelho) =====
  if (els.pullbackHighlightBox) {
    if (tone === 'red' || tone === 'danger') {
      els.pullbackHighlightBox.style.background = 'rgba(248,113,113,0.06)';
      els.pullbackHighlightBox.style.borderColor = 'rgba(248,113,113,0.6)';
    } else if (tone === 'yellow' || tone === 'neutral') {
      els.pullbackHighlightBox.style.background = 'rgba(234,179,8,0.06)';
      els.pullbackHighlightBox.style.borderColor = 'rgba(234,179,8,0.6)';
    } else {
      // default = saudável / ok
      els.pullbackHighlightBox.style.background = 'rgba(34,197,94,0.08)';
      els.pullbackHighlightBox.style.borderColor = 'rgba(34,197,94,0.4)';
    }
  }

  // termômetro de confiança / “risco de reversão”
  setMeter(score, tone);
}
// ====== PB CANDLE (Digest V20) – FUNÇÃO GLOBAL ======
function updatePullbackCandleFromDigest(payload) {
  try {
    const el = (typeof els !== 'undefined' && els && els.pullbackCandle)
      ? els.pullbackCandle
      : document.getElementById('pullback-candle');
    if (!el) return;

    // reset
    el.classList.remove('on-buy', 'on-sell', 'on-conflict');

    const root = payload || {};
    const panel = root.panel || root || {};
    const digest = root.digest || panel.digest || {};

    const pb =
      panel.pullback_candle_v1 ||
      (digest && digest.pullback_candle_v1) ||
      (digest && digest.micro && digest.micro.pullback_candle_v1) ||
      root.pullback_candle_v1 ||
      null;

    if (!pb || pb.on !== true) {
      el.textContent = '—';
      return;
    }

    let side = String(pb.side || pb.direction || '').toUpperCase().trim();
    if (side === 'LONG') side = 'BUY';
    if (side === 'SHORT') side = 'SELL';

    const barsAgo = (pb.bars_ago != null && isFinite(Number(pb.bars_ago)))
      ? Number(pb.bars_ago)
      : 0;

    const nowTxt = (typeof currentLang !== 'undefined' && currentLang === 'en') ? 'NOW' : 'AGORA';
    const barsTxt = (typeof currentLang !== 'undefined' && currentLang === 'en') ? 'bars' : 'candles';
    const agoTxt = (barsAgo === 0) ? nowTxt : `${barsAgo} ${barsTxt}`;

    if (side !== 'BUY' && side !== 'SELL' && side !== 'CONFLICT') side = 'ON';
    el.textContent = `${side} · ${agoTxt}`;

    if (side === 'BUY') el.classList.add('on-buy');
    else if (side === 'SELL') el.classList.add('on-sell');
    else if (side === 'CONFLICT') el.classList.add('on-conflict');
  } catch (e) {}
}

  


// ====== SIZING BRAIN – frases baseadas em Capital EM USO + Alavancagem ======
function updateSizingPhrase() {
  const accEl = els.sizingAccountRealInput;
  const useEl = els.sizingUseInput;
  const levEl = els.sizingLeverageInput;
  const riskEl = els.sizingRiskInput;
  const stopEl = els.sizingStopInput;
  const fixedEl = els.sizingFixedQtyInput;
  const mainEl = els.sizingPhraseMain;
  const detailEl = els.sizingPhraseDetail;

  if (!accEl || !useEl || !levEl || !riskEl || !stopEl || !mainEl || !detailEl) {
    return;
  }

  function numFromInput(el) {
    if (!el) return 0;
    const raw = (el.value || '').toString().replace(',', '.');
    const n = Number(raw);
    return Number.isFinite(n) ? n : 0;
  }

  const capitalReal = numFromInput(accEl);
  const capitalUso  = numFromInput(useEl);
  const leverage    = numFromInput(levEl);
  const riskPct     = numFromInput(riskEl);
  const stopUsd     = numFromInput(stopEl);
  const fixedQty    = Math.floor(numFromInput(fixedEl));

  // === LÓGICA TIPO AARON PINE ===
  // 1) Se Capital EM USO > 0 → base = EM USO
  // 2) Senão, se Capital REAL > 0 e alavancagem > 0 → base = REAL × alavancagem
  // 3) Senão, se Capital REAL > 0 → base = REAL
  let baseCapital = 0;

  if (capitalUso > 0) {
    baseCapital = capitalUso;
  } else if (capitalReal > 0 && leverage > 0) {
    baseCapital = capitalReal * leverage;
  } else if (capitalReal > 0) {
    baseCapital = capitalReal;
  }

  const baseMsg =
    currentLang === 'en'
      ? 'Type account capital, capital in use, risk % and stop distance to see the suggested position size.'
      : 'Digite capital real, capital em uso, risco % e stop para ver o tamanho sugerido da posição.';

  if (!baseCapital || !riskPct || !stopUsd) {
    mainEl.textContent = baseMsg;
    detailEl.textContent = '';
    return;
  }

  const riskMoney  = baseCapital * (riskPct / 100);
  const sharesRisk = Math.floor(riskMoney / stopUsd);

  if (!Number.isFinite(sharesRisk) || sharesRisk <= 0) {
    mainEl.textContent =
      currentLang === 'en'
        ? 'Check the values. The risk in dollars must be greater than the stop distance.'
        : 'Verifique os valores. O risco em dólares precisa ser maior que a distância do stop.';
    detailEl.textContent = '';
    return;
  }

  function fmtUSD(v) {
    return v.toLocaleString('en-US', {
      style: 'currency',
      currency: 'USD',
      maximumFractionDigits: 0,
    });
  }

  // Mensagem principal
  if (currentLang === 'en') {
    mainEl.textContent =
      'Base capital: ' +
      fmtUSD(baseCapital) +
      '. With ' +
      riskPct.toFixed(2) +
      '% risk per trade, max risk is about ' +
      fmtUSD(riskMoney) +
      ' per trade.';
  } else {
    mainEl.textContent =
      'Base de cálculo: ' +
      fmtUSD(baseCapital) +
      '. Com risco de ' +
      riskPct.toFixed(2) +
      '% por trade, o risco máximo por trade é de aproximadamente ' +
      fmtUSD(riskMoney) +
      '.';
  }

  // Detalhe – comparação com Qtd fixa (se existir)
  if (fixedQty > 0) {
    const aboveSafe = fixedQty > sharesRisk;

    if (currentLang === 'en') {
      detailEl.textContent =
        'With a stop at ' +
        stopUsd.toFixed(2) +
        ' USD per share, the risk-based safe size is around ' +
        sharesRisk +
        ' shares. Your fixed size is ' +
        fixedQty +
        ' shares, which is ' +
        (aboveSafe ? 'ABOVE' : 'within') +
        ' the safe size.';
    } else {
      detailEl.textContent =
        'Com o stop a ' +
        stopUsd.toFixed(2) +
        ' USD por share, o tamanho seguro pelo risco fica em torno de ' +
        sharesRisk +
        ' shares. Sua quantidade fixa é ' +
        fixedQty +
        ' shares, o que está ' +
        (aboveSafe ? 'ACIMA' : 'dentro') +
        ' do tamanho considerado seguro.';
    }
  } else {
    if (currentLang === 'en') {
      detailEl.textContent =
        'With a stop at ' +
        stopUsd.toFixed(2) +
        ' USD per share, the suggested position size is around ' +
        sharesRisk +
        ' shares. You can round down if you want to be more conservative.';
    } else {
      detailEl.textContent =
        'Com o stop a ' +
        stopUsd.toFixed(2) +
        ' USD por share, o tamanho de posição sugerido é de cerca de ' +
        sharesRisk +
        ' shares. Você pode arredondar para baixo se quiser ser mais conservador.';
    }
  }
}

// Eventos para recalcular quando digitar
['input', 'change'].forEach(function (evt) {
  if (els.sizingAccountRealInput)
    els.sizingAccountRealInput.addEventListener(evt, updateSizingPhrase);
  if (els.sizingUseInput)
    els.sizingUseInput.addEventListener(evt, updateSizingPhrase);
  if (els.sizingLeverageInput)
    els.sizingLeverageInput.addEventListener(evt, updateSizingPhrase);
  if (els.sizingRiskInput)
    els.sizingRiskInput.addEventListener(evt, updateSizingPhrase);
  if (els.sizingStopInput)
    els.sizingStopInput.addEventListener(evt, updateSizingPhrase);
  if (els.sizingFixedQtyInput)
    els.sizingFixedQtyInput.addEventListener(evt, updateSizingPhrase);
});


// ====== SIZING BRAIN – FUNÇÃO GLOBAL ======
function updateSizingBrain(data) {
  lastSizingBrain = data || null;

  if (!els.sizingTarget) return;

  function fmtPct(v) {
  if (v === null || v === undefined) return null;
  if (typeof v === 'string') v = v.replace('%', '').trim().replace(',', '.');

  const n = parseFloat(v);
  if (!Number.isFinite(n)) return null;
  return n.toFixed(1) + '%';
}


  // sempre que chegar dado novo (ou trocar idioma), recalcula frase
  updateSizingPhrase();

  function setProfileTag(profile) {
    const tag = els.sizingProfileTag;
    if (!tag) return;

    const p = (profile || '').toString().toLowerCase();
    tag.classList.remove(
      'profile-conservative',
      'profile-normal',
      'profile-aggressive'
    );

    if (p.includes('conserv')) {
      tag.classList.add('profile-conservative');
      tag.textContent =
        currentLang === 'en' ? 'Conservative' : 'Conservador';
    } else if (p.includes('agress') || p.includes('aggress')) {
      tag.classList.add('profile-aggressive');
      tag.textContent =
        currentLang === 'en' ? 'Aggressive' : 'Agressivo';
    } else {
      tag.classList.add('profile-normal');
      tag.textContent =
        currentLang === 'en' ? 'Normal' : 'Normal';
    }
  }

  function setStyleTag(style, labelPt, labelEn) {
    const tag = els.sizingStyleTag;
    if (!tag) return;

    const s = (style || '').toString().toLowerCase();
    tag.classList.remove(
      'style-daytrade',
      'style-swing',
      'style-momentum',
      'style-noedge'
    );

    let txt =
      currentLang === 'en'
        ? (labelEn || '')
        : (labelPt || '');

    if (!txt) {
      if (s.includes('day')) {
        txt =
          currentLang === 'en'
            ? 'Trend day trade'
            : 'Day trade tendencial';
      } else if (s.includes('swing')) {
        txt =
          currentLang === 'en'
            ? 'Swing trade'
            : 'Swing trade';
      } else if (s.includes('momentum') || s.includes('scalp')) {
        txt =
          currentLang === 'en'
            ? 'Momentum / scalp'
            : 'Momentum / scalp';
      } else {
        txt =
          currentLang === 'en'
            ? 'No clear edge'
            : 'Sem edge claro';
      }
    }

    if (s.includes('day')) {
      tag.classList.add('style-daytrade');
    } else if (s.includes('swing')) {
      tag.classList.add('style-swing');
    } else if (s.includes('momentum') || s.includes('scalp')) {
      tag.classList.add('style-momentum');
    } else {
      tag.classList.add('style-noedge');
    }

    tag.textContent = txt;
  }

  function setMeter(score) {
    const fill = els.sizingMeterFill;
    const label = els.sizingMeterLabel;
    if (!fill || !label) return;

    let v = score;
if (typeof v === 'string') v = v.replace('%', '').trim().replace(',', '.');
v = parseFloat(v);
if (!Number.isFinite(v)) v = 40;


    fill.style.width = v.toFixed(0) + '%';
    label.textContent =
      (currentLang === 'en' ? 'Risk usage ' : 'Uso de risco ') +
      v.toFixed(0) +
      '%';
  }

  // ===== estado neutro (sem dados do backend) =====
  if (!data || Object.keys(data).length === 0) {
    if (els.sizingTarget) els.sizingTarget.textContent = '0.8–1.2%';
    if (els.sizingMaxDD) els.sizingMaxDD.textContent = '0.8%';
    if (els.sizingRiskTrade) els.sizingRiskTrade.textContent = '0.25%';
    if (els.sizingTradesCount) els.sizingTradesCount.textContent = '3';

    setProfileTag('normal');
    setStyleTag('day_trade', null, null);
    setMeter(40);

    if (els.sizingComment) {
      els.sizingComment.textContent =
        currentLang === 'en'
          ? 'Today you can think in terms of a realistic 0.8–1.2% if you focus on 2–3 A+ trades and respect your max daily loss.'
          : 'Hoje você pode pensar em algo em torno de 0.8–1.2% se focar em 2–3 trades A+ e respeitar sua perda máxima do dia.';
    }

    return;
  }

  // ===== com dados do backend (sizing_brain) =====
  const profile      = data.profile;
  const style        = data.style_today;
  const styleLabelPt = data.style_label_pt;
  const styleLabelEn = data.style_label_en;

  const tMin    = data.target_min_pct   ?? data.recommended_target_min_pct;
  const tMax    = data.target_max_pct   ?? data.recommended_target_max_pct;
  const tSingle = data.target_pct       ?? data.recommended_target_pct;

  const maxDD        = data.max_dd_pct         ?? data.recommended_max_dd_pct;
  const riskPerTrade = data.risk_per_trade_pct ?? data.recommended_risk_per_trade_pct;
  const tradesCount  = data.trades_count       ?? data.recommended_trades_count;
  const score        = data.score              ?? data.risk_usage_score ?? 40;

  // alvo
  let targetText = '';
  const tMinFmt    = fmtPct(tMin);
  const tMaxFmt    = fmtPct(tMax);
  const tSingleFmt = fmtPct(tSingle);

  if (tMinFmt && tMaxFmt) targetText = `${tMinFmt}–${tMaxFmt}`;
  else if (tSingleFmt)    targetText = tSingleFmt;

  if (!targetText) {
    targetText = currentLang === 'en' ? 'Auto' : 'Automático';
  }

  if (els.sizingTarget) els.sizingTarget.textContent = targetText;
  if (els.sizingMaxDD && fmtPct(maxDD)) {
    els.sizingMaxDD.textContent = fmtPct(maxDD);
  }
  if (els.sizingRiskTrade && fmtPct(riskPerTrade)) {
    els.sizingRiskTrade.textContent = fmtPct(riskPerTrade);
  }
  if (els.sizingTradesCount && tradesCount != null) {
    els.sizingTradesCount.textContent = String(tradesCount);
  }

  setProfileTag(profile);
  setStyleTag(style, styleLabelPt, styleLabelEn);
  setMeter(score);

  const comment =
    currentLang === 'en'
      ? (data.comment_en || data.comment || '')
      : (data.comment_pt || data.comment || '');

  if (els.sizingComment) {
    if (comment) {
      els.sizingComment.textContent = comment;
    } else {
      els.sizingComment.textContent =
        currentLang === 'en'
          ? 'Sizing Brain suggests focusing on A+ setups only, with a realistic target for the day and a strict daily loss limit.'
          : 'O Sizing Brain sugere focar apenas em setups A+, com alvo realista para o dia e limite de perda diária bem definido.';
    }
  }
}

function uniq(list) {
  return Array.from(new Set(list.filter(Boolean)));
}

function buildPatternFileCandidates(file) {
  const f = String(file || '').trim();
  if (!f) return [];

  const cand = [f];

  const hasExt = /\.[a-z0-9]{2,5}$/i.test(f);
  if (!hasExt) {
    // tenta extensões comuns
    cand.push(`${f}.jpg`, `${f}.png`, `${f}.jpeg`, `${f}.webp`);
  } else {
    // se veio jpg, tenta png equivalente (e vice-versa)
    if (f.toLowerCase().endsWith('.jpg')) cand.push(f.replace(/\.jpg$/i, '.png'));
    if (f.toLowerCase().endsWith('.png')) cand.push(f.replace(/\.png$/i, '.jpg'));

    // casos “F(1).jpg” vs “F (1).jpg”
    if (/^F\(\d+\)\./i.test(f)) cand.push(f.replace(/^F\(/i, 'F ('));
    if (/^F \(\d+\)\./i.test(f)) cand.push(f.replace(/^F \(/i, 'F('));

    // Tentativas genéricas: com e sem espaço antes do "("
    if (f.includes('(')) cand.push(f.replace('(', ' ('));
    if (f.includes(' (')) cand.push(f.replace(' (', '('));
  }

  return uniq(cand);
}


function setRefImageWithFallback(file) {
  if (!els.refPatternImg) return;

  const candidates = buildPatternFileCandidates(file);
  if (!candidates.length) return;

  let idx = 0;

  const tryLoad = () => {
    const base = encodeURI(`assets/patterns/${candidates[idx]}`);
    const bust = `${base}${base.includes('?') ? '&' : '?'}t=${Date.now()}`;

    els.refPatternImg.src = bust;
    if (els.refPatternLink) els.refPatternLink.href = base;
  };

  els.refPatternImg.onerror = () => {
    idx += 1;
    if (idx < candidates.length) tryLoad();
  };

  tryLoad();
}


function updatePatternReference(panel, patterns) {
  if (!els.refPatternImg || !els.refPatternLabel) return;

  const trade = panel.trade_card || panel.tradeCard || {};
  const ref = panel.pattern_reference || panel.pattern_ref || {};
  const day = (patterns && patterns.day) ? patterns.day : {};

  const pid = trade.pattern_id || ref.id || '';

  const namePt = ref.name_pt || ref.name || (pid ? `Padrão ${pid}` : '') || panel.pattern_day || day.name || '—';
  const nameEn = ref.name_en || ref.name || (pid ? `Pattern ${pid}` : '') || panel.pattern_day || day.name || '—';

  const setupPt = ref.setup_pt || ref.setup || day.desc || '—';
  const setupEn = ref.setup_en || ref.setup || day.desc || '—';

  const notesPt = ref.notes_pt || ref.notes || '—';
  const notesEn = ref.notes_en || ref.notes || '—';

  // imagem: prioriza o que veio do n8n; senão monta pelo pattern_id
  let img =
    ref.image_url ||
    ref.image ||
    ref.img ||
    ref.file ||
    ref.filename ||
    panel.pattern_image ||
    panel.pattern_img ||
    trade.pattern_image ||
    (pid ? pid : '') ||
    '';

  if (!img) img = 'F(1).jpg';

  // textos
  if (els.refPatternLabel) els.refPatternLabel.textContent = (currentLang === 'en') ? nameEn : namePt;
  if (els.refPatternSetup) els.refPatternSetup.textContent = (currentLang === 'en') ? setupEn : setupPt;
  if (els.refPatternNotes) els.refPatternNotes.textContent = (currentLang === 'en') ? notesEn : notesPt;
  if (els.refPatternMini) els.refPatternMini.textContent = (currentLang === 'en') ? nameEn : namePt;

  const isUrl = /^https?:\/\//i.test(img);

  if (isUrl) {
    const finalSrc = `${img}${img.includes('?') ? '&' : '?'}t=${Date.now()}`;
    els.refPatternImg.src = finalSrc;
    if (els.refPatternLink) els.refPatternLink.href = img;
  } else {
    setRefImageWithFallback(img);
  }

  // Abrir/Fechar
  if (els.refDetails && els.refSummaryRight) {
    els.refSummaryRight.textContent = els.refDetails.open
      ? (currentLang === 'en' ? 'Close' : 'Fechar')
      : (currentLang === 'en' ? 'Open' : 'Abrir');
  }
}

// ===============================
// ADAPTER: panel_json -> trade card model (Citadel)
// (não mexe no dropdown, não mexe no autopilot)
// ===============================
function adaptPanelToTradeCard(panel, raw, fallbackSymbol){
  if (!panel || typeof panel !== "object") return null;

  const statusGeral = panel.status_geral || {};
  const ai = panel.ai_advisor || panel.aiAdvisor || {};
  const meta = panel.meta || {};

  const sym = String(panel.symbol || raw?.symbol || fallbackSymbol || "").toUpperCase().trim() || "—";
  const tf  = String(panel.timeframe || raw?.timeframe || panel.timeframe_label || "").trim() || "—";

  const parseBoolish = (v) => {
    if (typeof v === "boolean") return v;
    if (typeof v === "number") return v > 0;
    const s = String(v ?? "").trim().toLowerCase();
    if (!s) return false;
    if (/(false|não|nao|no|0)/.test(s)) return false;
    if (/(true|sim|yes|1|válido|valido|valid)/.test(s)) return true;
    return false;
  };

  const setupOk = parseBoolish(statusGeral.setup_valido ?? statusGeral.setupValido ?? statusGeral.setup);

  const actionRaw = String(ai.acao_recomendada || ai.action || ai.recommendation || "").toLowerCase();
  const dirInfo =
    (actionRaw.includes("buy") || actionRaw.includes("compra")) ? { pt:"COMPRA", en:"BUY",  cls:"status-buy",  side:"buy" } :
    (actionRaw.includes("sell")|| actionRaw.includes("venda"))  ? { pt:"VENDA",  en:"SELL", cls:"status-sell", side:"sell"} :
    (actionRaw.includes("close")|| actionRaw.includes("fechar"))? { pt:"FECHAR", en:"CLOSE",cls:"status-wait", side:"close"} :
    (actionRaw.includes("wait")|| actionRaw.includes("aguard")) ? { pt:"AGUARDAR",en:"WAIT", cls:"status-wait", side:"wait"} :
                                                                 { pt:"NEUTRO", en:"NEUTRAL",cls:"status-wait", side:"neutral" };

  const updatedAt =
    panel.updated_at || panel.updated || meta.panel_ts || meta.timestamp || panel.timestamp || raw?.time || "—";
  const session = panel.session || raw?.session || "—";
  const flow =
    panel.flow_label || panel.flow || statusGeral.tendencia || "—";

  const status_text_pt = setupOk ? `✅ Setup válido | ${dirInfo.pt}` : `⏳ Aguardando | ${dirInfo.pt}`;
  const status_text_en = setupOk ? `✅ Valid setup | ${dirInfo.en}` : `⏳ Waiting | ${dirInfo.en}`;

  const pulse_line_pt = `${session} • ${flow} • atualizado: ${updatedAt}`;
  const pulse_line_en = `${session} • ${flow} • updated: ${updatedAt}`;

  const mode_pt =
    String(ai.modo_pt || ai.modo || ai.motivo || "").trim() || (setupOk ? "Setup identificado" : "Aguardando confirmação");
  const mode_en =
    String(ai.modo_en || ai.mode || ai.motivo_en || ai.motivo || "").trim() || (setupOk ? "Setup identified" : "Waiting confirmation");

  const entry_text = ai.gatilho_entrada || ai.entry || ai.entrada || "—";

  const firstNum = (x) => {
    if (x == null) return null;
    if (typeof x === "number" && isFinite(x)) return x;
    const m = String(x).match(/-?\d+(?:\.\d+)?/);
    return m ? Number(m[0]) : null;
  };

  const stopRaw = (ai.stop_loss_plano ?? ai.stop_loss ?? ai.stop);
  const stopNum = firstNum(stopRaw);
  const stop = (stopNum != null) ? stopNum.toFixed(2) : (stopRaw || "—");

  const tpPlan = (ai.take_profit_plano ?? ai.take_profit ?? ai.tp);
  let tp1 = "—", tp2 = "—";
  if (tpPlan != null) {
    const s = String(tpPlan);
    const m1 = s.match(/TP1\s*[:=]?\s*(-?\d+(?:\.\d+)?)/i);
    const m2 = s.match(/TP2\s*[:=]?\s*(-?\d+(?:\.\d+)?)/i);
    if (m1) tp1 = Number(m1[1]).toFixed(2);
    if (m2) tp2 = Number(m2[1]).toFixed(2);

    if (!m1 && !m2) {
      const nums = s.match(/-?\d+(?:\.\d+)?/g);
      if (nums && nums.length) tp1 = Number(nums[0]).toFixed(2);
      if (nums && nums.length > 1) tp2 = Number(nums[1]).toFixed(2);
      if (!nums || !nums.length) tp1 = s; // mantém texto se não tiver número
    }
  }

  const size_text = ai.size_text || "—";
  const risk_text = ai.risk_text || "—";

  const comment_pt = [
    ai.motivo ? `Motivo: ${ai.motivo}` : null,
    ai.gatilho_entrada ? `Entrada: ${ai.gatilho_entrada}` : null,
    ai.stop_loss_plano ? `Stop: ${ai.stop_loss_plano}` : null,
    ai.take_profit_plano ? `TP: ${ai.take_profit_plano}` : null,
    ai.manejo_posicao ? `Manejo: ${ai.manejo_posicao}` : null,
  ].filter(Boolean).join("\n") || "—";

  const comment_en = [
    ai.motivo_en ? `Reason: ${ai.motivo_en}` : (ai.motivo ? `Reason: ${ai.motivo}` : null),
    ai.gatilho_entrada_en ? `Entry: ${ai.gatilho_entrada_en}` : (ai.gatilho_entrada ? `Entry: ${ai.gatilho_entrada}` : null),
    ai.stop_loss_plano_en ? `Stop: ${ai.stop_loss_plano_en}` : (ai.stop_loss_plano ? `Stop: ${ai.stop_loss_plano}` : null),
    ai.take_profit_plano_en ? `TP: ${ai.take_profit_plano_en}` : (ai.take_profit_plano ? `TP: ${ai.take_profit_plano}` : null),
    ai.manejo_posicao_en ? `Management: ${ai.manejo_posicao_en}` : (ai.manejo_posicao ? `Management: ${ai.manejo_posicao}` : null),
  ].filter(Boolean).join("\n") || "—";

  return {
    symbol: sym,
    timeframe: tf,

    status_text_pt,
    status_text_en,

    pulse_line_pt,
    pulse_line_en,

    mode_pt,
    mode_en,

    against_pt: "—",
    against_en: "—",

    direction_pt: dirInfo.pt,
    direction_en: dirInfo.en,

    // garante cor do card
    side: dirInfo.side,
    direction: dirInfo.side,

    entry_text,
    stop,
    tp1,
    tp2,

    size_text,
    risk_text,

    thermo_pt: setupOk ? "Agressivo moderado" : "Neutro",
    thermo_en: setupOk ? "Moderately aggressive" : "Neutral",

    comment_pt,
    comment_en,

    badge: setupOk ? "WAIT" : "NO TRADE",
    status_class: dirInfo.cls,
    trade_state: String(ai.trade_state || "").toUpperCase() || undefined,
  };
}


// ====== LOAD PANEL (agora usando data.panel + data.raw) ======
async function loadPanel(showSpinner) {
  if (!PANEL_URL) return;
  try {
    if (els.errorBanner) els.errorBanner.style.display = 'none';
    if (els.btnRefresh && showSpinner) els.btnRefresh.disabled = true;

        const sym = (localStorage.getItem('aaron_selected_symbol') || '').trim() || 'NVDA';
    const tf  = (typeof getSelectedTimeframe === "function") ? getSelectedTimeframe() : "1m";
    const url = `${PANEL_URL}${PANEL_URL.includes('?') ? '&' : '?'}symbol=${encodeURIComponent(sym)}&timeframe=${encodeURIComponent(tf)}&t=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' });


    if (!res.ok) throw new Error('HTTP ' + res.status);

const data = await res.json();

// n8n pode devolver: {panel, raw, ui, digest}  OU  [ { json: {...} } ]  OU  [ {...} ]
const root = Array.isArray(data) ? (data[0] || {}) : (data || {});
const payload =
  (root && typeof root === 'object' && root.json && typeof root.json === 'object')
    ? root.json
    : root;

// salva debug
window.__AARON_LAST_PAYLOAD__ = payload;

// ✅ 1) Preenche o bloco “RESPONDER OUTPUT” (KPI + colunas panel/ui/digest)
if (typeof renderTradeResponderOutput === "function") {
  renderTradeResponderOutput(payload);
}

// ✅ 2) Injeta dentro do Trade Card (campos “na sua cara”)
if (typeof applyResponderIntoTradeCard === "function") {
  applyResponderIntoTradeCard(payload);
}
if (typeof updatePremonitionPanel === "function") {
  updatePremonitionPanel(payload);
}
if (typeof updateRespiroReversaoPanel === "function") {
  updateRespiroReversaoPanel(payload);
}
if (typeof updateAaronCommentaryBlock === "function") {
  updateAaronCommentaryBlock(payload);
}

// ✅ 3) Mini-resumo dentro do Trade Card (se o anchor existir)
if (typeof renderResponderInline === "function") {
  renderResponderInline(payload);
}

window.dispatchEvent(new Event("aaron:panelUpdated"));

// segue o fluxo normal do seu loadPanel

const panel = payload.panel || payload;
const raw = payload.raw || payload.raw_eye || {};

// alimenta Autopilot 2.0 com o preço atual (sem inventar)
const pxNow =
  panel.price_now ||
  panel.last_price ||
  panel.reference_price ||
  (raw && raw.candle && raw.candle.close);

if (pxNow != null && isFinite(Number(pxNow))) {
  apMarketPrice = Number(pxNow);
}
apRenderSizing();

// ✅ SYNC do dropdown PREÇO (Matcher Picker) + fonte de quote
try {
  const pxNum = (pxNow != null && isFinite(Number(pxNow))) ? Number(pxNow) : null;

  // alimenta o getQuote() do dropdown
  window.__AARON_LAST_PANEL_JSON__ = {
    symbol: panel?.symbol || raw?.symbol || sym,
    price: pxNum,
    last_price: pxNum,
  };

  // atualiza o campo "PREÇO" do dropdown
  const mpEl = document.getElementById("mp-price");
  if (mpEl) mpEl.value = (pxNum != null) ? pxNum.toFixed(2) : "—";
} catch (e) {}



    updateGarimpoTodayCard(panel?.garimpo_today || null);


    // Preenche ATR + preço de entrada
    prefillAtrFromPanel(panel, raw);

    const statusGeral = panel.status_geral || {};
    const aiAdvisor = panel.ai_advisor || {};
    const patterns = panel.patterns || {};
    const patternDay = patterns.day || {};
    const patternShort = patterns.short || {};
    const meta = panel.meta || {};

    // "cérebro" de pullback vindo do n8n
    const pullbackBrain =
      panel.pullback_brain ||
      panel.pullbackBrain ||
      
      panel.pullback ||
      {};
    updatePullbackBrain(pullbackBrain);

    // PB Candle (Digest V20)
if (typeof updatePullbackCandleFromDigest === "function") {
  updatePullbackCandleFromDigest(payload);
}


        const sizingBrain =
      panel.sizing_brain ||
      panel.sizingBrain ||
      panel.capital_brain ||
      {};
    updateSizingBrain(sizingBrain);

            // Cartão de trade (Citadel / cartão atual)
const tradeCard =
  panel.trade_card ||
  panel.current_trade ||
  panel.citadel_card ||
  panel.trade ||
  null;

// 1) Se o backend já trouxe um cartão pronto, usa ele
if (tradeCard && typeof tradeCard === "object" && Object.keys(tradeCard).length) {
  updateTradeCard(tradeCard);
} else {
  // 2) Senão, ADAPTA do panel.ai_advisor + panel.status_geral (sem inventar)
  const adapted = adaptPanelToTradeCard(panel, raw, sym);
  if (adapted) {
    window.__AARON_TRADE_FROM_PANEL__ = adapted; // debug (opcional)
    updateTradeCard(adapted);
  }
}

// ✅ GARANTIA: depois que o loadPanel atualizar o cartão, re-aplica o output do RESPONDER
try {
  if (typeof applyResponderIntoTradeCard === "function") {
    applyResponderIntoTradeCard(payload);
  }
  if (typeof renderResponderInline === "function") {
    renderResponderInline(payload);
  }
} catch (e) {}



    // Cabeçalho
    safeText(els.symbol, panel.symbol || raw.symbol || '—');
    safeText(
      els.timeframe,
      panel.timeframe ||
        raw.timeframe ||
        panel.timeframe_label ||
        '—'
    );
    safeText(
      els.session,
      panel.session || raw.session || panel.session_label || '—'
    );

    const micro = panel.microcontexto || {};
    const flowLabel = panel.flow_label || panel.flow || micro.direcao;
    safeText(els.flow, flowLabel || 'Neutro');

    const stateText =
      (panel.status && (panel.status.label || panel.status.state)) ||
      statusGeral.tendencia ||
      'ONLINE';
    safeText(els.state, stateText);

    const ts =
  meta.panel_ts ||
  meta.timestamp ||
  panel.timestamp ||
  panel.updated_at || panel.updatedAt || panel.updated_at_ms ||
  raw.time;

    if (els.lastUpdate) {
      if (!ts) {
        els.lastUpdate.textContent = 'sem timestamp';
      } else {
        try {
          const d =
            typeof ts === 'number'
              ? new Date(ts)
              : new Date(String(ts));
          els.lastUpdate.textContent = d.toLocaleString('pt-BR', {
            timeZone: 'America/Denver',
          });
        } catch (e) {
          els.lastUpdate.textContent = String(ts);
        }
      }
    }

    // Padrões / Direções
    const patternDayName =
      panel.pattern_day ||
      panel.pattern_of_day ||
      patternDay.name;
    const patternDayDesc =
      panel.pattern_day_detail ||
      panel.pattern_of_day_detail ||
      patternDay.desc;

    const patternNowName =
      panel.pattern_now ||
      panel.pattern_of_moment ||
      patternShort.name;
    const patternNowDesc =
      panel.pattern_now_detail ||
      panel.pattern_of_moment_detail ||
      patternShort.desc;

    safeText(els.patternDayLabel, patternDayName || '-');
    safeText(els.patternDayDetail, patternDayDesc || '—');
    safeText(els.patternNowLabel, patternNowName || '-');
    safeText(els.patternNowDetail, patternNowDesc || '—');

    setArrow(
      els.dirDayArrow,
      panel.direction_day ||
        panel.direction_of_day ||
        micro.direcao
    );
    setArrow(
      els.dirNowArrow,
      panel.direction_now ||
        panel.direction_of_moment ||
        micro.direcao
    );

    setPillTrend(
      els.trendDayPill,
      panel.direction_day || panel.direction_of_day || micro.direcao,
      panel.trend_day_label
    );
    setPillTrend(
      els.trendNowPill,
      panel.direction_now ||
        panel.direction_of_moment ||
        micro.direcao,
      panel.trend_now_label
    );

        // Atualiza aba de referência (imagem + textos)
    updatePatternReference(panel, patterns);

    // Listener do abre/fecha (pra atualizar o texto "Abrir/Fechar")
    if (els.refDetails && !els.refDetails.__bound) {
      els.refDetails.__bound = true;
      els.refDetails.addEventListener('toggle', () => {
        if (els.refSummaryRight) {
          els.refSummaryRight.textContent = els.refDetails.open
            ? (currentLang === 'en' ? 'Close' : 'Fechar')
            : (currentLang === 'en' ? 'Open' : 'Abrir');
        }
      });
    }


    // =======================================================
    // TEXTO DINÂMICO: DIREÇÃO DO DIA / 1–3 CANDLES
    // =======================================================

    let dayProb   = panel.direction_day_prob;
    let dayDetail = panel.direction_day_detail;
    let nowProb   = panel.direction_now_prob;
    let nowDetail = panel.direction_now_detail;

    // fallback usando prob_favor / prob_contra
    if ((!dayProb && !dayDetail) || (!nowProb && !nowDetail)) {
      const forecast = panel.ai_forecast || {};
      const probFavor  = Number(panel.prob_favor  ?? forecast.prob_continuacao ?? NaN);
      const probContra = Number(panel.prob_contra ?? forecast.prob_contra      ?? NaN);

      if (!Number.isNaN(probFavor) && !Number.isNaN(probContra)) {
        // --- DIA ---
        if (!dayProb && !dayDetail) {
          if (probFavor >= probContra) {
            dayProb = probFavor;
            dayDetail =
              `Continuação a favor: ${probFavor}% · Contra: ${probContra}%.`;
          } else {
            dayProb = probContra;
            dayDetail =
              `Maior chance de contra-movimento: ${probContra}% · Continuação: ${probFavor}%.`;
          }
        }

        // --- MOMENTO (1–3 candles) ---
        if (!nowProb && !nowDetail) {
          if (probFavor >= probContra) {
            nowProb = probFavor;
            nowDetail =
              `Curto prazo favorece continuação (${probFavor}% vs ${probContra}% de contra).`;
          } else {
            nowProb = probContra;
            nowDetail =
              `Curto prazo favorece contra-movimento (${probContra}% vs ${probFavor}% de continuação).`;
          }
        }
      }
    }

    if (els.directionDayText && (dayProb || dayDetail)) {
      els.directionDayText.textContent =
        (dayProb ? dayProb + '% · ' : '') + (dayDetail || '');
    }

    if (els.directionNowText && (nowProb || nowDetail)) {
      els.directionNowText.textContent =
        (nowProb ? nowProb + '% · ' : '') + (nowDetail || '');
    }

    // Estrutura recente: HH / HL / LH / LL
    const structureRecent =
      panel.structure_recent ||
      panel.recent_structure ||
      panel.market_structure ||
      (panel.structure && panel.structure.recent) ||
      null;

    updateStructureUI(structureRecent);
    updateStructureZigzag(panel);

    // Textos principais
    const finalSummary =
      panel.summary ||
      panel.painel_terminal ||
      '—';

    const riskLevel =
  panel.risk_level ||
  aiAdvisor.risk_text ||
  aiAdvisor.risco ||
  panel.trade_card?.risk_text ||
  '—';

const riskComment =
  panel.risk_comment ||
  aiAdvisor.motivo ||
  aiAdvisor.motivo_pt ||
  panel.trade_card?.comment_pt ||
  panel.painel_terminal ||
  '—';


    const contextComment =
      panel.context_comment ||
      panel.painel_terminal ||
      '—';

    const executionPlan =
  panel.execution_plan ||
  aiAdvisor.acao_recomendada ||
  panel.trade_card?.direction_pt ||
  panel.trade_card?.direction_en ||
  '—';


    safeText(els.summary, finalSummary);
    setRiskPill(riskLevel);
    safeText(els.riskText, riskComment);
    safeText(els.contextText, contextComment);
    safeText(els.executionText, executionPlan);

    // AUTOPILOT CONTRACT: PANEL_UPDATE (MarketNow + P/L + R + EXIT_PENDING)
if (typeof apOnPanelUpdate === 'function') {
  apOnPanelUpdate(panel, { executionPlan, riskLevel, finalSummary });
}


    // MODO CEGO usa os mesmos textos (NUNCA pode quebrar o loadPanel)
try {
  applyHeroDecision(executionPlan, riskLevel, finalSummary);
} catch (e) {
  console.warn('[HERO] applyHeroDecision falhou, mas o painel continua:', e);
}

applyInstitutionalDecision(panel, executionPlan, riskLevel);



  } catch (err) {
    console.error('Erro ao carregar painel', err);
    if (els.errorBanner) {
      els.errorBanner.style.display = 'block';
      els.errorBanner.innerHTML =
        '<strong>Erro ao carregar painel.</strong> Verifique o webhook "aaron10_panel_json" no n8n e tente novamente.';
    }
  } finally {
    if (els.btnRefresh) els.btnRefresh.disabled = false;
  }
}

// ====== INICIALIZAÇÃO ======
// ========= AARON 10 – ALPACA CHART + STUDIES =========
let a10Chart = null;
let a10CandleSeries = null;
let a10Ema21Series = null;
let a10VwapSeries = null;
let a10PriceLines = {};

// 🔥 fonte da verdade do gráfico (para live incremental)
let a10ChartCandles = [];              // candles que estão na tela
let a10LastPayloadKey = '';
let a10LastStudyUpdateAt = 0;
const A10_STUDY_THROTTLE_MS = 1500;

function a10ResetLiveChart(reason = '') {
  try {
    // zera base local
    a10ChartCandles = [];

    // limpa séries (se já existirem)
    if (a10CandleSeries) a10CandleSeries.setData([]);
    if (a10Ema21Series) a10Ema21Series.setData([]);
    if (a10VwapSeries)  a10VwapSeries.setData([]);

    // remove price lines antigas (prev day / session hi/lo / orb etc)
    if (a10CandleSeries && Array.isArray(a10PriceLines) && a10PriceLines.length) {
      for (const pl of a10PriceLines) {
        try { a10CandleSeries.removePriceLine(pl); } catch (_) {}
      }
    }
    a10PriceLines = [];

    // debug globals (opcional, mas ajuda MUITO)
    window.__A10_LIVE_HAS_BARS__ = false;
    window.__A10_LIVE_LAST_45__ = null;
    window.__A10_LIVE_LAST_RAW__ = null;

    console.log('[A10] reset live chart', reason);
  } catch (e) {
    console.warn('[A10] reset live chart failed', e);
  }
}

function a10UnixSec(t) {
  if (typeof t === 'number') {
    if (t > 1e12) return Math.floor(t / 1000); // ms
    if (t > 1e10) return Math.floor(t / 1000); // ms (só garantia)
    return Math.floor(t); // sec
  }
  if (typeof t === 'string') {
    const ms = Date.parse(t);
    if (!Number.isNaN(ms)) return Math.floor(ms / 1000);
  }
  return null;
}

function a10ExtractCandles(payload) {
  const raw = payload?.raw || payload?.data || payload || {};
  const panel = payload?.panel || raw?.panel || raw || {};
  const symbol = String(panel.symbol || panel.ticker || payload.symbol || '')
    .toUpperCase()
    .trim();

  const candidates = [
    raw?.intraday?.candles,
    raw?.intraday?.bars,
    raw?.candles,
    raw?.bars,

    // alguns fluxos devolvem objeto por símbolo
    raw?.intraday?.bars_by_symbol,
    raw?.bars_by_symbol,

    panel?.intraday?.candles,
    panel?.intraday?.bars,
    panel?.candles,
    panel?.bars,
    panel?.recent_candles,

    payload?.candles,
    payload?.bars,
  ];

  function pickArray(x) {
    if (!x) return null;

    // já é array
    if (Array.isArray(x)) return x;

    // Alpaca multi-symbol: { bars: { "NVDA":[...] } }
    if (typeof x === 'object') {
      if (x.bars && typeof x.bars === 'object') {
        if (symbol && Array.isArray(x.bars[symbol])) return x.bars[symbol];
      }

      // objeto direto: { "NVDA":[...] }
      if (symbol && Array.isArray(x[symbol])) return x[symbol];

      // fallback: se existir só 1 array dentro do objeto, usa ele
      for (const k of Object.keys(x)) {
        if (Array.isArray(x[k])) return x[k];
      }
    }

    return null;
  }

  const arr = candidates.map(pickArray).find((a) => Array.isArray(a)) || [];

  // ✅ dedupe por time: se vier repetido, o “último ganha”
  const map = new Map();

  for (const c of arr) {
    const time = a10UnixSec(c?.t ?? c?.time ?? c?.timestamp ?? c?.datetime);
    const open = Number(c?.o ?? c?.open);
    const high = Number(c?.h ?? c?.high);
    const low  = Number(c?.l ?? c?.low);
    const close= Number(c?.c ?? c?.close);
    const volume = Number(c?.v ?? c?.volume ?? 0);

    if (!time) continue;
    if (!Number.isFinite(open) || !Number.isFinite(high) || !Number.isFinite(low) || !Number.isFinite(close)) continue;

    // sanidade: garante high/low consistentes mesmo se vierem estranhos
    const hi = Math.max(high, open, close, low);
    const lo = Math.min(low, open, close, high);

    map.set(time, {
      time,
      open,
      high: hi,
      low: lo,
      close,
      volume: Number.isFinite(volume) ? volume : 0
    });
  }

  return Array.from(map.values()).sort((a, b) => a.time - b.time);
}


function a10ComputeEMA(candles, period) {
  const alpha = 2 / (period + 1);
  let ema = null;
  const out = [];
  for (const c of candles) {
    ema = (ema == null) ? c.close : (c.close - ema) * alpha + ema;
    out.push({ time: c.time, value: ema });
  }
  return out;
}

function a10ComputeVWAP(candles) {
  let cumPV = 0;
  let cumV = 0;
  const out = [];

  for (const c of candles) {
    const v = c.volume || 0;
    if (!v) continue;

    const tp = (c.high + c.low + c.close) / 3;
    cumPV += tp * v;
    cumV += v;

    if (cumV > 0) out.push({ time: c.time, value: cumPV / cumV });
  }

  return out;
}

function a10IsETAfterOpen(unixSec) {
  // 09:30 ET (aprox via Intl)
  const d = new Date(unixSec * 1000);
  const parts = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/New_York',
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  }).formatToParts(d);

  const hh = Number(parts.find(p => p.type === 'hour')?.value || 0);
  const mm = Number(parts.find(p => p.type === 'minute')?.value || 0);
  return (hh > 9) || (hh === 9 && mm >= 30);
}

function a10ComputeSessionHL(candles) {
  const sessionCandles = candles.filter(c => a10IsETAfterOpen(c.time));
  if (!sessionCandles.length) return null;

  let hi = -Infinity, lo = Infinity;
  for (const c of sessionCandles) {
    if (c.high > hi) hi = c.high;
    if (c.low  < lo) lo = c.low;
  }
  if (!Number.isFinite(hi) || !Number.isFinite(lo)) return null;
  return { hi, lo };
}

function a10ComputeORB(candles, minutes = 5) {
  // ORB: primeiros X minutos após 09:30 ET (assumindo 1m candles)
  const afterOpen = candles.filter(c => a10IsETAfterOpen(c.time));
  if (afterOpen.length < minutes) return null;

  const slice = afterOpen.slice(0, minutes);
  let hi = -Infinity, lo = Infinity;
  for (const c of slice) {
    if (c.high > hi) hi = c.high;
    if (c.low  < lo) lo = c.low;
  }
  if (!Number.isFinite(hi) || !Number.isFinite(lo)) return null;
  return { hi, lo };
}

function a10ToggleState() {
  return {
    sessionHL: !!document.getElementById('st-session-hl')?.checked,
    prevDay:   !!document.getElementById('st-prevday')?.checked,
    orb:       !!document.getElementById('st-orb')?.checked,
    vwap:      !!document.getElementById('st-vwap')?.checked,
    ema21:     !!document.getElementById('st-ema21')?.checked,
  };
}

function a10ClearPriceLine(key) {
  try {
    if (a10PriceLines[key] && a10CandleSeries) {
      a10CandleSeries.removePriceLine(a10PriceLines[key]);
    }
  } catch (e) {}
  a10PriceLines[key] = null;
}

function a10SetPriceLine(key, price, title, color, style) {
  a10ClearPriceLine(key);
  if (!a10CandleSeries || !Number.isFinite(price)) return;

  a10PriceLines[key] = a10CandleSeries.createPriceLine({
    price,
    title,
    color,
    lineWidth: 1,
    lineStyle: style, // 0 solid | 1 dotted | 2 dashed | 3 large dashed
    axisLabelVisible: true,
  });
}

function a10InitChart() {
  const el = document.getElementById('aaron10-chart');
  if (!el) return;
  if (a10Chart) return;
  if (!window.LightweightCharts) {
    console.warn('[A10] LightweightCharts não carregou.');
    return;
  }

  // Utah (Mountain Time) - labels do eixo X + crosshair
  const A10_TZ = 'America/Denver';

  const fmtTime = new Intl.DateTimeFormat('en-US', {
    timeZone: A10_TZ,
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  });

  const fmtDate = new Intl.DateTimeFormat('en-US', {
    timeZone: A10_TZ,
    month: '2-digit',
    day: '2-digit',
  });

  function a10FmtUtah(time, wantDate) {
    // suporte caso venha BusinessDay (por segurança)
    if (time && typeof time === 'object' && 'year' in time) {
      const d = new Date(Date.UTC(time.year, (time.month || 1) - 1, time.day || 1));
      return fmtDate.format(d);
    }
    const sec = Number(time);
    if (!Number.isFinite(sec)) return '';
    const d = new Date(sec * 1000);
    return wantDate ? fmtDate.format(d) : fmtTime.format(d);
  }

  a10Chart = LightweightCharts.createChart(el, {
    layout: {
      attributionLogo: false, // <<< REMOVE o "TV" do canto
      background: { type: 'solid', color: '#020617' },
      textColor: '#e5e7eb',
    },
    grid: {
      vertLines: { color: 'rgba(148,163,184,0.08)' },
      horzLines: { color: 'rgba(148,163,184,0.08)' },
    },
    rightPriceScale: { borderColor: 'rgba(148,163,184,0.22)' },

    localization: {
      // label de tempo do crosshair (tooltip)
      timeFormatter: (time) => a10FmtUtah(time, false),
    },

    timeScale: {
      timeVisible: true,
      secondsVisible: false,
      // labels do eixo X
      tickMarkFormatter: (time, tickMarkType) => {
        const tmt = LightweightCharts.TickMarkType || {};
        const isDate =
          tickMarkType === tmt.DayOfMonth ||
          tickMarkType === tmt.Month ||
          tickMarkType === tmt.Year;
        return a10FmtUtah(time, isDate);
      },
    },

    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
  });

  a10CandleSeries = a10Chart.addCandlestickSeries({
    upColor: '#4ade80',
    downColor: '#f97373',
    borderUpColor: '#4ade80',
    borderDownColor: '#f97373',
    wickUpColor: '#4ade80',
    wickDownColor: '#f97373',
    wickDownColor: '#f97373',
  });

  a10Ema21Series = a10Chart.addLineSeries({ lineWidth: 2 });
  a10VwapSeries  = a10Chart.addLineSeries({ lineWidth: 2 });

  // Resize automático
  const ro = new ResizeObserver(() => {
    try {
      a10Chart.applyOptions({ width: el.clientWidth, height: el.clientHeight });
    } catch (e) {}
  });
  ro.observe(el);
}

// =======================================================
// WINDOWS (Janela de entrada) — preencher o quadro WINDOWS
// =======================================================
function a10TfToMinutes(tf) {
  const s = String(tf || "1m").trim().toLowerCase();
  const m = s.match(/^(\d+)\s*m/);
  if (m) return Math.max(1, parseInt(m[1], 10) || 1);
  const h = s.match(/^(\d+)\s*h/);
  if (h) return Math.max(1, (parseInt(h[1], 10) || 1) * 60);
  return 1;
}

function a10Num(x) {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

function a10Fmt2(n) {
  return (n == null || !Number.isFinite(n)) ? "—" : Number(n).toFixed(2);
}

function a10Clamp01(x) { return Math.max(0, Math.min(1, x)); }

function a10CandleParts(c) {
  if (!c) return null;
  const o = a10Num(c.open), h = a10Num(c.high), l = a10Num(c.low), cl = a10Num(c.close);
  if (o == null || h == null || l == null || cl == null) return null;

  const body = Math.abs(cl - o);
  const range = Math.max(1e-9, h - l);
  const upperWick = h - Math.max(o, cl);
  const lowerWick = Math.min(o, cl) - l;

  return { o, h, l, cl, body, range, upperWick, lowerWick };
}

function a10GetMicroCtx(payload, candles) {
  const raw   = payload?.raw || payload?.data || payload || {};
  const panel = payload?.panel || raw?.panel || raw || {};
  const digest = payload?.digest || panel?.digest || raw?.digest || {};

  const mp = digest?.micro_path_live || panel?.micro_path_live || payload?.micro_path_live || null;

  const current =
    a10Num(panel.price_now ?? panel.last_price ?? payload.price_now ?? payload.last_price) ??
    a10Num(candles?.[candles.length - 1]?.close);

  const microTarget =
    a10Num(mp?.micro_live_target) ??
    a10Num(panel?.premonition_micro?.micro_take ?? panel?.premonition_micro?.take_profit) ??
    a10Num(panel?.micro_take ?? panel?.micro_target_price) ??
    a10Num(digest?.premonition?.micro_target_price) ??
    a10Num(payload?.micro_take ?? payload?.micro_target_price);

  const microProb =
    a10Num(mp?.micro_live_prob_pct) ??
    a10Num(panel?.premonition_micro?.micro_prob_pct ?? panel?.micro_prob_pct) ??
    a10Num(digest?.premonition?.micro_prob_pct) ??
    a10Num(payload?.micro_prob_pct);

  const dir =
    (current != null && microTarget != null)
      ? (microTarget > current ? "BUY" : (microTarget < current ? "SELL" : null))
      : null;

  const tf =
    panel.timeframe ||
    payload.timeframe ||
    (window.a10LiveWanted && window.a10LiveWanted.timeframe) ||
    "1m";

  const tfMin = a10TfToMinutes(tf);

  return { current, microTarget, microProb, dir, tfMin };
}

// Heurística simples (bem sua ideia):
// SELL: candle "setup" fecha abaixo do anterior + wick superior grande (rejeição).
// BUY : espelhado (fecha acima + wick inferior grande).
function a10ComputeWindowSignal(candles, payload) {
  const ctx = a10GetMicroCtx(payload, candles);
  const { dir, microProb, tfMin } = ctx;

  // Elementos do quadro
  const elStatus = document.getElementById("win-status");
  const elPred   = document.getElementById("win-predicted");
  const elConf   = document.getElementById("win-confidence");
  const elRule   = document.getElementById("win-rule"); // (se existir)

  // se o quadro nem existe, sai silencioso
  if (!elStatus && !elPred && !elConf && !elRule) return;

  // defaults
  let status = "WAIT";
  let predictedTxt = "—";
  let confTxt = "—";
  let ruleTxt = "Regra: close abaixo do candle anterior + confirmação no próximo";

  if (!candles || candles.length < 3 || !dir) {
    // Sem candles suficientes ou sem direção
    elStatus && (elStatus.textContent = "WAIT");
    elPred   && (elPred.textContent   = "—");
    elConf   && (elConf.textContent   = "—");
    elRule   && (elRule.textContent   = ruleTxt);
    return;
  }

  // usa: prev (fechado), setup (fechado), live (candle atual)
  const prev  = a10CandleParts(candles[candles.length - 3]);
  const setup = a10CandleParts(candles[candles.length - 2]);
  const live  = a10CandleParts(candles[candles.length - 1]);

  if (!prev || !setup || !live) return;

  // força do wick vs body (seu “wick maior que o corpo”)
  const wickBodyRatioSell = setup.upperWick / Math.max(1e-9, setup.body);
  const wickBodyRatioBuy  = setup.lowerWick / Math.max(1e-9, setup.body);

  const closesLower = setup.cl < prev.cl; // SELL setup
  const closesHigher = setup.cl > prev.cl; // BUY setup

  const hasRejectionSell =
    (wickBodyRatioSell >= 1.2) && (setup.upperWick / setup.range >= 0.25);

  const hasRejectionBuy =
    (wickBodyRatioBuy >= 1.2) && (setup.lowerWick / setup.range >= 0.25);

  const isSetupSell = (dir === "SELL") && closesLower && hasRejectionSell;
  const isSetupBuy  = (dir === "BUY")  && closesHigher && hasRejectionBuy;

  // confirmação (candle atual já está indo a favor)
  const isConfirmingSell = isSetupSell && (live.cl < setup.cl);
  const isConfirmingBuy  = isSetupBuy  && (live.cl > setup.cl);

  // previsão / gatilho (números!)
  if (isConfirmingSell || isConfirmingBuy) {
    status = "NOW";
    const trig = (dir === "SELL") ? setup.cl : setup.cl;
    predictedTxt = `NOW • confirmando • (gatilho: close ${dir === "SELL" ? "<" : ">"} ${a10Fmt2(trig)}) • ~0m`;
  } else if (isSetupSell || isSetupBuy) {
    status = "WAIT";
    const trig = (dir === "SELL") ? setup.cl : setup.cl;
    predictedTxt = `~1 candle (${tfMin}m) • (gatilho: close ${dir === "SELL" ? "<" : ">"} ${a10Fmt2(trig)})`;
  } else {
    // sem janela
    status = "WAIT";
    predictedTxt = "—";
  }

  // confiança (%): microProb + força do wick (bem simples)
  const base = (microProb != null) ? Math.max(0, Math.min(100, microProb)) : 50;

  const wickScore =
    (dir === "SELL")
      ? a10Clamp01((wickBodyRatioSell - 1.0) / 1.5)
      : a10Clamp01((wickBodyRatioBuy  - 1.0) / 1.5);

  let conf = 0.65 * base + 0.35 * (wickScore * 100);
  if (status === "NOW") conf += 7; // bônus por confirmação
  conf = Math.max(0, Math.min(99, conf));

  confTxt = `${Math.round(conf)}%`;

  // escreve no quadro
  elStatus && (elStatus.textContent = status);
  elPred   && (elPred.textContent   = predictedTxt);
  elConf   && (elConf.textContent   = confTxt);
  elRule   && (elRule.textContent   = ruleTxt);
}

function a10UpdateWindowsCardFromCandles(payload, candles) {
  try { a10ComputeWindowSignal(candles, payload); } catch (e) {
    console.warn("[WINDOWS] falhou sem quebrar o painel:", e);
  }
}

function a10UpdateChartFromPayload(payload) {
  try {
    if (!payload) return;
    a10InitChart();
    if (!a10Chart || !a10CandleSeries) return;

    const panel = payload.panel || payload.raw?.panel || {};
    const symbol =
      panel.symbol ||
      panel.ticker ||
      payload.symbol ||
      (a10LiveWanted && a10LiveWanted.symbol) ||
      '—';

    const tf =
      panel.timeframe ||
      panel.tf ||
      panel.interval ||
      payload.timeframe ||
      payload.tf ||
      (a10LiveWanted && a10LiveWanted.timeframe) ||
      '1m';

    const metaEl = document.getElementById('chart-meta');
    if (metaEl) metaEl.textContent = `${symbol} · ${tf} · Alpaca`;

    const incoming = a10ExtractCandles(payload);
    if (!incoming.length) return;

    const hasBase = Array.isArray(a10ChartCandles) && a10ChartCandles.length > 0;
    const isIncremental = hasBase && incoming.length <= 3;

    function mergeOne(c){
      if (!c || !c.time) return false;

      if (!Array.isArray(a10ChartCandles) || a10ChartCandles.length === 0) {
        a10ChartCandles = [c];
        a10CandleSeries.setData(a10ChartCandles);
        return true;
      }

      const last = a10ChartCandles[a10ChartCandles.length - 1];

      if (c.time === last.time) {
        a10ChartCandles[a10ChartCandles.length - 1] = c;
        a10CandleSeries.update(c);
        return true;
      }

      if (c.time > last.time) {
        a10ChartCandles.push(c);
        a10CandleSeries.update(c);
        return true;
      }

      // raro: out-of-order — tenta achar e substitui; depois setData pra garantir
      for (let i = a10ChartCandles.length - 1; i >= 0; i--) {
        if (a10ChartCandles[i].time === c.time) {
          a10ChartCandles[i] = c;
          a10CandleSeries.setData(a10ChartCandles);
          return true;
        }
        if (a10ChartCandles[i].time < c.time) break;
      }

      return false;
    }

    if (!isIncremental) {
      // FULL SNAPSHOT
      const last = incoming[incoming.length - 1];
      const payloadKey = `${symbol}|${tf}|len:${incoming.length}|t:${last.time}|h:${last.high}|l:${last.low}|c:${last.close}|v:${last.volume}`;
      if (payloadKey === a10LastPayloadKey) return;
      a10LastPayloadKey = payloadKey;

      a10ChartCandles = incoming;
      a10CandleSeries.setData(a10ChartCandles);
    } else {
      // LIVE INCREMENTAL
      let changed = false;
      for (const c of incoming) changed = mergeOne(c) || changed;
      if (!changed) return;

      // throttle estudos (candles continuam live mesmo se pular aqui)
      const now = Date.now();
      if (now - a10LastStudyUpdateAt < A10_STUDY_THROTTLE_MS) return;
      a10LastStudyUpdateAt = now;
    }


    window.a10ChartCandles = a10ChartCandles;
const candles = a10ChartCandles;
if (!candles || !candles.length) return;

// ✅ WINDOWS: preencher números do quadro
a10UpdateWindowsCardFromCandles(payload, candles);

const t = a10ToggleState();


    // EMA 21
    if (a10Ema21Series) {
      a10Ema21Series.applyOptions({ visible: t.ema21 });
      if (t.ema21) a10Ema21Series.setData(a10ComputeEMA(candles, 21));
    }

    // VWAP
    if (a10VwapSeries) {
      a10VwapSeries.applyOptions({ visible: t.vwap });
      if (t.vwap) a10VwapSeries.setData(a10ComputeVWAP(candles));
    }

    // Session High / Low
    if (t.sessionHL) {
      const hl = a10ComputeSessionHL(candles);
      if (hl) {
        a10SetPriceLine('sessionHi', hl.hi, 'Session High', 'rgba(74,222,128,0.85)', 2);
        a10SetPriceLine('sessionLo', hl.lo, 'Session Low',  'rgba(248,113,113,0.85)', 2);
      }
    } else {
      a10ClearPriceLine('sessionHi');
      a10ClearPriceLine('sessionLo');
    }

    // ORB 5m
    if (t.orb) {
      const orb = a10ComputeORB(candles, 5);
      if (orb) {
        a10SetPriceLine('orbHi', orb.hi, 'ORB High', 'rgba(34,211,238,0.85)', 1);
        a10SetPriceLine('orbLo', orb.lo, 'ORB Low',  'rgba(34,211,238,0.85)', 1);
      }
    } else {
      a10ClearPriceLine('orbHi');
      a10ClearPriceLine('orbLo');
    }

    // Prev Day levels (se vier no payload; se não vier, só ignora)
    if (t.prevDay) {
      const pd = panel.prev_day || panel.prevDay || payload.prev_day || payload.prevDay || null;
      const pdHigh = Number(pd?.high ?? pd?.h ?? panel.prev_day_high ?? panel.pd_high);
      const pdLow  = Number(pd?.low  ?? pd?.l ?? panel.prev_day_low  ?? panel.pd_low);
      if (Number.isFinite(pdHigh)) a10SetPriceLine('pdHigh', pdHigh, 'PD High', 'rgba(59,130,246,0.85)', 3);
      if (Number.isFinite(pdLow))  a10SetPriceLine('pdLow',  pdLow,  'PD Low',  'rgba(59,130,246,0.85)', 3);
    } else {
      a10ClearPriceLine('pdHigh');
      a10ClearPriceLine('pdLow');
    }
  } catch (e) {
    console.warn('[A10] updateChart falhou (mas o painel continua):', e);
  }
}


function a10BindStudiesUI() {
  document.querySelectorAll('.pill-toggle input').forEach((el) => {
    el.addEventListener('change', () => {
      a10LastPayloadKey = ''; // força redraw
      a10UpdateChartFromPayload(window.__AARON_LAST_PAYLOAD__);
    });
  });
}

// ====== INICIALIZAÇÃO ======
function initAaron9() {
  // liga chart + estudos
  a10InitChart();
  a10BindStudiesUI();
// Premonição: se o painel estiver OFF (sem URL), ainda mostra o DEMO
if (!PANEL_URL) {
  try { updatePremonitionPanel(null); } catch (e) {}
  try { updateRespiroReversaoPanel(null); } catch (e) {}

}

  // sempre que o painel atualizar, atualiza o chart
      window.addEventListener('aaron:panelUpdated', () => {
    // Só “protege” o chart contra snapshot do polling se estiver chegando BAR de verdade
    const lastBarAt = window.__A10_LIVE_LAST_BAR_AT__ || 0;
    const liveBarFresh = A10_USE_LIVE_CANDLES && lastBarAt && (Date.now() - lastBarAt) < 90000; // 90s


    if (liveBarFresh) return; // live de verdade -> não sobrescreve com polling

    a10UpdateChartFromPayload(window.__AARON_LAST_PAYLOAD__); // sem BAR -> deixa polling atualizar
  });




    // botão ATUALIZAR
  if (els.btnRefresh) {
    els.btnRefresh.addEventListener('click', function () {
      loadPanel(true);
    });
  }

  // evita leak de conexões WS ao fechar/recarregar a aba
  window.addEventListener('beforeunload', () => {
    try { a10LiveClose(); } catch(e) {}
  });

  loadPanel(false);
  setInterval(() => loadPanel(false), REFRESH_MS);
}





// AUTOPILOT init
autopilot = apLoad();
apSyncUI();

function apArmFromButton(side) {
  // força o toggle visual ficar ON também
  if (els.apToggle && !els.apToggle.checked) {
    els.apToggle.checked = true;
  }

  apActivate(side); // seta enabled=true, salva e sincroniza UI

  // garante que o resto do painel atualiza imediatamente
  if (typeof loadPanel === 'function') loadPanel(false);
}


if (els.apToggle) {
  els.apToggle.addEventListener('change', () => {
    const turningOn = !!els.apToggle.checked;

    if (!turningOn) {
      apClose();          // ✅ contrato: OFF = reset total
      return;
    }

    // ON (armado, sem posição)
    autopilot = apLoad();
    autopilot.enabled = true;
    autopilot.active = false;
    autopilot.side = null;
    autopilot.entry = null;
    autopilot.startedAt = null;

    // ✅ garante “sem resquícios”
    autopilot.state = AP_STATES.FLAT;
    autopilot.snapshot = null;
    autopilot.exitPending = false;
    autopilot.marketNow = autopilot.marketNow ?? 'wait';

    apSave(autopilot);
    apSyncUI();
    if (typeof loadPanel === 'function') loadPanel(false);
  });
}


// ===== AUTOPILOT: handlers robustos (BUY/SELL armam o toggle e ativam) =====
const arm = (side) => {
  try {
    // liga o toggle (se existir)
    if (els.apToggle && !els.apToggle.checked) els.apToggle.checked = true;

    // ativa o autopilot no lado escolhido
    if (typeof apActivate === 'function') apActivate(side);

    // se você usa a função do contrato, pode chamar também:
    if (typeof apArmFromButton === 'function') apArmFromButton(side);

    // reflete na UI
    if (typeof apSyncUI === 'function') apSyncUI();

    // atualiza painel (se existir)
    if (typeof loadPanel === 'function') loadPanel(false);
  } catch (e) {
    console.error('[AP] erro ao armar:', e);
  }
};

if (els.apBuy) {
  els.apBuy.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    arm('buy');
  });
}

if (els.apSell) {
  els.apSell.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    arm('sell');
  });
}

if (els.apClose) {
  els.apClose.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    try {
      if (typeof apClose === 'function') apClose();
      if (els.apToggle) els.apToggle.checked = false;
      if (typeof apSyncUI === 'function') apSyncUI();
      if (typeof loadPanel === 'function') loadPanel(false);
    } catch (err) {
      console.error('[AP] erro no close:', err);
    }
  });
}


// AUTOPILOT 2.0: quando muda capital, recalcula units e reflete no Citadel
if (els.apCapital) {
  els.apCapital.addEventListener('input', () => {
    apRenderSizing();
    apSyncUI();
    if (typeof loadPanel === 'function') loadPanel(false);
  });
 }

// ================ TOGGLE DE IDIOMA PT / EN ==================

const I18N = {
  pt: {
    // TOPO
    'top.live_feed': 'FEED AO VIVO',
    'top.symbol': 'Símbolo',
    'top.timeframe': 'Timeframe',
    'top.session': 'Sessão',
    'top.last_update': 'Última atualização:',
    'top.refresh': 'ATUALIZAR',

        // GARIMPO DE HOJE
    'garimpo_badge': 'Garimpo de Hoje',
    'garimpo_best_label': 'Melhor ativo para hoje',
    'garimpo_metric_confidence': 'Confiança do cérebro',
    'garimpo_metric_gap': 'Gap',
    'garimpo_metric_premarket': 'Pré-market vs média',
    'garimpo_metric_atr': 'ATR% (volatilidade)',
    'garimpo_comment':
      'Hoje este é o ativo com melhor combinação de fluxo, liquidez e volatilidade para o seu perfil.',
    'garimpo_view_page': 'Ver página do garimpo',


    // RISCO · ATR
    'risk.title': 'Gerenciador de risco · ATR',
    'risk.subtitle': 'Ajuste os parâmetros do ATR e calcule risco / reward da operação.',
    'risk.toggle_open': 'Abrir',
    'risk.toggle_close': 'Fechar',

    // CARD TRADINGVIEW
    'card.tv_title': 'Painel de Preço em Tempo Real',
    'card.tv_sub': 'Alpaca PRO + Estrutura do Dia',


    // RESUMO INSTITUCIONAL
    'summary.title': 'Resumo institucional',
    'summary.subtitle': 'Leitura consolidada do AARON 9',
    'summary.risk_mgmt': 'Gestão de risco',

    // RADAR
    'radar.day_title': 'Direção geral do dia',
    'radar.now_title': 'Direção prevista · 1–3 candles',

    // OUTROS
    'comment.title': 'Comentário do Painel',
    'panel.risk_title': 'Risco',
    'panel.context_title': 'Contexto',
    'panel.execution_title': 'Execução',

    // PULLBACK
    'pullback.title': 'Pullback Brain · Zona de respiro',
    'pullback.depth': 'Profundidade',
    'pullback.quality': 'Qualidade',

        // SIZING BRAIN
    'sizing.title': 'Sizing Brain · Gestão de capital do dia',
    'sizing.target_label': 'Alvo razoável hoje',
    'sizing.max_dd': 'Máx. perda',
    'sizing.risk_trade': 'Risco / trade',
    'sizing.trades': 'Trades A+',
    'sizing.conservative': 'Conservador',
    'sizing.aggressive': 'Agressivo',

        // CARTÃO DE TRADE CITADEL
    'trade_card.title': 'AARON – Cartão de Trade Atual',
    'trade_card.status_label': 'Status:',
    'trade_card.stats_label': 'Estatística:',
    'trade_card.asset_label': 'Ativo:',
    'trade_card.timeframe_label': 'Timeframe:',
    'trade_card.mode_label': 'Modo:',
    'trade_card.against_label': 'Contra:',
    'trade_card.dir_label': 'Direção sugerida:',
    'trade_card.entry_label': 'Entrada:',
    'trade_card.stop_label': 'Stop:',
    'trade_card.tp_label': 'TP1:',
    'trade_card.size_label': 'Tamanho:',
    'trade_card.risk_label': 'Risco:',
    'trade_card.thermo_label': 'Termômetro:',
    'trade_card.comment_label': 'Comentário do AARON:',


  },

  en: {
    // TOP
    'top.live_feed': 'LIVE FEED',
    'top.symbol': 'Symbol',
    'top.timeframe': 'Timeframe',
    'top.session': 'Session',
    'top.last_update': 'Last update:',
    'top.refresh': 'REFRESH',

        // GARIMPO TODAY
    'garimpo_badge': 'Garimpo Today',
    'garimpo_best_label': 'Best asset for today',
    'garimpo_metric_confidence': 'Brain confidence',
    'garimpo_metric_gap': 'Gap',
    'garimpo_metric_premarket': 'Pre-market vs average',
    'garimpo_metric_atr': 'ATR% (volatility)',
    'garimpo_comment':
      'Today this is the asset with the best combination of flow, liquidity and volatility for your profile.',
    'garimpo_view_page': 'View Garimpo page',


    // RISK · ATR
    'risk.title': 'Risk manager · ATR',
    'risk.subtitle': 'Adjust ATR parameters and calculate trade risk / reward.',
    'risk.toggle_open': 'Open',
    'risk.toggle_close': 'Close',

    // TRADINGVIEW CARD
    'card.tv_title': 'Real-Time Price Panel',
    'card.tv_sub': 'Alpaca PRO + Daily Structure',

    // SUMMARY
    'summary.title': 'Institutional summary',
    'summary.subtitle': 'Consolidated reading from AARON 9',
    'summary.risk_mgmt': 'Risk management',

    // RADAR
    'radar.day_title': 'Overall direction of the day',
    'radar.now_title': 'Expected direction · 1–3 candles',

    // OTHERS
    'comment.title': 'Panel commentary',
    'panel.risk_title': 'Risk',
    'panel.context_title': 'Context',
    'panel.execution_title': 'Execution',

    // PULLBACK
    'pullback.title': 'Pullback Brain · Pullback zone',
    'pullback.depth': 'Depth',
    'pullback.quality': 'Quality',

        // SIZING BRAIN
    'sizing.title': 'Sizing Brain · Daily capital plan',
    'sizing.target_label': 'Reasonable target today',
    'sizing.max_dd': 'Max loss',
    'sizing.risk_trade': 'Risk / trade',
    'sizing.trades': 'A+ trades',
    'sizing.conservative': 'Conservative',
    'sizing.aggressive': 'Aggressive',

        // CITADEL TRADE CARD
    'trade_card.title': 'AARON – Current Trade Card',
    'trade_card.status_label': 'Status:',
    'trade_card.stats_label': 'Statistics:',
    'trade_card.asset_label': 'Asset:',
    'trade_card.timeframe_label': 'Timeframe:',
    'trade_card.mode_label': 'Mode:',
    'trade_card.against_label': 'Against:',
    'trade_card.dir_label': 'Suggested direction:',
    'trade_card.entry_label': 'Entry:',
    'trade_card.stop_label': 'Stop:',
    'trade_card.tp_label': 'TP1:',
    'trade_card.size_label': 'Size:',
    'trade_card.risk_label': 'Risk:',
    'trade_card.thermo_label': 'Thermometer:',
    'trade_card.comment_label': 'AARON\'s comment:',


  },
};

// currentLang já foi definido no topo do <script> (ANTES de qualquer apSyncUI/loadPanel)
currentLang = window.currentLang || currentLang || 'pt';


function applyLang(lang) {
  const dict = I18N[lang] || I18N.pt;
  currentLang = lang;
  window.currentLang = currentLang;
  try { localStorage.setItem('AARON_LANG', currentLang); } catch(e) {}


  // troca TODO elemento com data-i18n
  document.querySelectorAll('[data-i18n]').forEach((el) => {
    const key = el.getAttribute('data-i18n');
    const txt = dict[key];
    if (txt) el.textContent = txt;
  });

  // pill de estado (AGUARDANDO / WAITING)
  const statePill = document.getElementById('state-pill');
  if (statePill) {
    statePill.textContent = lang === 'en' ? 'WAITING' : 'AGUARDANDO';
  }

  // botão refresh
  const btnRefresh = document.getElementById('btn-refresh');
  if (btnRefresh) {
    btnRefresh.textContent =
      dict['top.refresh'] || (lang === 'en' ? 'REFRESH' : 'ATUALIZAR');
  }

  // texto de "Abrir / Fechar" do card ATR, se já estiver aberto
  const atrToggle = document.getElementById('atr-risk-toggle');
  const atrBody = document.getElementById('atr-risk-body');
  if (atrToggle && atrBody) {
    const isOpen = atrBody.style.display && atrBody.style.display !== 'none';
    if (isOpen) {
      atrToggle.textContent =
        dict['risk.toggle_close'] || (lang === 'en' ? 'Close' : 'Fechar');
    } else {
      atrToggle.textContent =
        dict['risk.toggle_open'] || (lang === 'en' ? 'Open' : 'Abrir');
    }
  }

  // re-renderiza o Pullback Brain no idioma atual
  if (typeof updatePullbackBrain === 'function') {
    updatePullbackBrain(lastPullbackBrain);
  }
  if (typeof updateSizingBrain === 'function') {
    updateSizingBrain(lastSizingBrain);
  }
  if (typeof updateSizingPhrase === 'function') {
    updateSizingPhrase();
  }

  // re-renderiza o Garimpo de Hoje no idioma atual (PT / EN)
  if (typeof updateGarimpoTodayCard === 'function' &&
      typeof garimpoTodayData !== 'undefined') {
    updateGarimpoTodayCard(garimpoTodayData);
  }
}


 // ====== SIZING BRAIN – CÁLCULO LOCAL DO GERENCIADOR DE RISCO ======
function recalcSizingBrainLocal() {
  if (!sbEls.card) return;

  function num(el) {
    if (!el) return 0;
    const raw = (el.value || '').toString().replace(',', '.');
    const v = Number(raw);
    return Number.isFinite(v) ? v : 0;
  }

  const account = num(sbEls.accountBalance);    // Capital real da conta
  const lev     = num(sbEls.leverage);         // Alavancagem x
  const tradeCap= num(sbEls.tradeCapital);     // Capital em uso neste trade
  const riskPct = num(sbEls.riskPercentInput); // Risco máx. por trade (% conta)
  const entry   = num(sbEls.entryPrice);       // Preço de entrada
  const atr     = num(sbEls.atrValue);         // ATR atual ($)
  const multStop= num(sbEls.atrMultStop) || 1; // Mult ATR STOP
  const multTake= num(sbEls.atrMultTake) || (multStop * 2); // Mult ATR TAKE

  // lado: long / short
  let side = 'long';
  if (sbEls.sideRadios && sbEls.sideRadios.length) {
    sbEls.sideRadios.forEach(r => {
      if (r.checked) side = r.value;
    });
  }

  const statusEl = sbEls.status;
  function setStatus(msg) {
    if (statusEl) statusEl.textContent = msg;
  }

  // validações básicas
  if (!account || !riskPct || !entry || !atr || !multStop) {
    setStatus('Preencha capital, risco, preço de entrada, ATR e multiplicadores para calcular.');
    return;
  }

  // distância do stop e do alvo em dólares por share
  const stopDist = atr * multStop;
  const takeDist = atr * multTake;

  // base de capital para limitar o tamanho (EM USO se tiver, senão conta × alavancagem, senão só conta)
  let baseCapital = 0;
  if (tradeCap > 0) {
    baseCapital = tradeCap;
  } else if (account > 0 && lev > 0) {
    baseCapital = account * lev;
  } else {
    baseCapital = account;
  }

  // risco máximo em dinheiro (por trade) baseado % da conta real
  const maxRiskMoney = account * (riskPct / 100);

  // tamanho de posição pelo risco e pelo capital
  const sharesByRisk    = maxRiskMoney / stopDist;
  const sharesByCapital = baseCapital && entry ? baseCapital / entry : sharesByRisk;
  let shares = Math.floor(Math.min(sharesByRisk, sharesByCapital));

  if (!Number.isFinite(shares) || shares <= 0) {
    setStatus('Verifique os valores: o risco em dólares precisa ser maior que a distância do stop.');
    return;
  }

  // preços de stop e take
  const stopPrice = side === 'short'
    ? entry + stopDist
    : entry - stopDist;

  const takePrice = side === 'short'
    ? entry - takeDist
    : entry + takeDist;

  // risco real com a quantidade ajustada
  const realRiskMoney = shares * stopDist;
  const realRiskPct   = account ? (realRiskMoney / account) * 100 : 0;

  // ==== atualiza os textos do card ====
  if (sbEls.outStopDistance)
    sbEls.outStopDistance.textContent = `Distância do STOP: ${stopDist.toFixed(2)} USD`;

  if (sbEls.outStopPrice)
    sbEls.outStopPrice.textContent = `Stop Loss sugerido: ${stopPrice.toFixed(2)}`;

  if (sbEls.outTakePrice)
    sbEls.outTakePrice.textContent = `Take Profit sugerido: ${takePrice.toFixed(2)}`;

  if (sbEls.outPositionSize)
    sbEls.outPositionSize.textContent = `Qtd sugerida: ${shares.toFixed(0)}`;

  if (sbEls.outRiskDollar)
    sbEls.outRiskDollar.textContent = `Risco aprox.: $ ${realRiskMoney.toFixed(2)}`;

    if (sbEls.outRiskPercent)
    sbEls.outRiskPercent.textContent =
      `Risco % trade / conta: ${realRiskPct.toFixed(2)}%`;

  setStatus(
    `Ok: ${shares.toFixed(0)} shares, risco ≈ ${realRiskPct.toFixed(2)}% (${realRiskMoney.toFixed(2)} USD).`
  );

  // NOVO · Termômetro offline do gerenciador de risco
  const sbMeterFill  = document.getElementById('sb-meter-fill');
  const sbMeterLabel = document.getElementById('sb-meter-label');
  if (sbMeterFill && sbMeterLabel) {
    // ratio = quanto do risco planejado você está usando
    const ratio = riskPct > 0 ? realRiskPct / riskPct : 0; // 1 = exatamente o risco que você planejou
    let score   = ratio * 100;                             // transforma em "porcentagem de uso"
    score       = Math.max(0, Math.min(130, score));       // trava para não explodir
    const width = Math.max(8, Math.min(100, score));       // largura da barra

    sbMeterFill.style.width = width.toFixed(0) + '%';

    sbMeterFill.classList.remove('safe', 'warn', 'danger');
    if (ratio <= 0.6) {
      sbMeterFill.classList.add('safe');    // bem conservador
    } else if (ratio <= 1.0) {
      sbMeterFill.classList.add('warn');    // perto do limite planejado
    } else {
      sbMeterFill.classList.add('danger');  // acima do risco planejado
    }

    sbMeterLabel.textContent =
      (currentLang === 'en'
        ? `Risk usage ${realRiskPct.toFixed(2)}% (plan ${riskPct.toFixed(2)}%)`
        : `Uso de risco ${realRiskPct.toFixed(2)}% (alvo ${riskPct.toFixed(2)}%)`);
  }

  // Alimenta o bloco de baixo (Aaron Pine) com a distância do stop em USD/share
  if (els.sizingStopInput) {
    els.sizingStopInput.value = stopDist.toFixed(2);
    if (typeof updateSizingPhrase === 'function') {
      updateSizingPhrase();
    }
  }
}
   
// conecta o botão "Recalcular Sizing" ao cálculo local
if (sbEls.calcBtn) {
  sbEls.calcBtn.addEventListener('click', function (ev) {
    ev.preventDefault();
    recalcSizingBrainLocal();
  });
}


// liga o toggle dos botões PT / EN
const langToggleEl = document.getElementById('lang-toggle');
if (langToggleEl) {
  langToggleEl.addEventListener('click', (ev) => {
    const btn = ev.target.closest('.lang-btn');
    if (!btn) return;

    const lang = btn.getAttribute('data-lang');
    if (!lang) return;

    langToggleEl.querySelectorAll('.lang-btn').forEach((b) =>
      b.classList.remove('active')
    );
    btn.classList.add('active');

    applyLang(lang);
  });
}

// idioma inicial (puxa do localStorage via currentLang)
applyLang(currentLang);


// garante que roda depois que o DOM existe
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAaron9);
} else {
  initAaron9();
}

   // ================== GARIMPO DE HOJE - DADOS EXEMPLO ==================
let lastGarimpoToday = null;

function updateGarimpoTodayCard(data) {
  lastGarimpoToday = data || null;

  const tickerEl = document.getElementById('garimpo-ticker');
  const profileEl = document.getElementById('garimpo-profile');
  const gapEl = document.getElementById('garimpo-gap');
  const pmEl = document.getElementById('garimpo-premarket');
  const atrEl = document.getElementById('garimpo-atr');
  const confEl = document.getElementById('garimpo-confidence');

  if (!tickerEl) return;

  const d = data || {};
  const lang = (window.currentLang === 'en' ? 'en' : 'pt');

  const profile =
    (d.profile && typeof d.profile === 'object')
      ? (d.profile[lang] || d.profile.pt || '—')
      : (d.profile || '—');

  tickerEl.textContent = d.ticker || '—';
  if (profileEl) profileEl.textContent = profile;
  if (gapEl) gapEl.textContent = d.gapPct || '—';
  if (pmEl) pmEl.textContent = d.preMarketRatio || '—';
  if (atrEl) atrEl.textContent = d.atrPct || '—';
  if (confEl) confEl.textContent = d.confidence || '—';
}

// chamada inicial (vazio até chegar JSON do n8n)
updateGarimpoTodayCard(null);


// ================== GARIMPO DE HOJE - TEXTOS PT/EN =================
if (typeof I18N !== 'undefined' && I18N.pt && I18N.en) {
  Object.assign(I18N.pt, {
    garimpo_badge: 'Garimpo de Hoje',
    garimpo_best_label: 'Melhor ativo para hoje',
    garimpo_comment:
      'Hoje este é o ativo com melhor combinação de fluxo, liquidez e volatilidade para o seu perfil.',
    garimpo_metric_gap: 'Gap',
    garimpo_metric_premarket: 'Pré-market vs média',
    garimpo_metric_atr: 'ATR% (volatilidade)',
    garimpo_metric_confidence: 'Confiança do cérebro',
    garimpo_btn_full: 'Ver página do garimpo',
  });

  Object.assign(I18N.en, {
    garimpo_badge: "Today's Mining Pick",
    garimpo_best_label: 'Best stock to trade today',
    garimpo_comment:
      "Today this is the asset with the best combination of flow, liquidity and volatility for your profile.",
    garimpo_metric_gap: 'Gap',
    garimpo_metric_premarket: 'Pre-market vs avg.',
    garimpo_metric_atr: 'ATR% (volatility)',
    garimpo_metric_confidence: "Brain's confidence",
    garimpo_btn_full: 'Open full mining page',
  });
}

    function openGarimpoPage() {
  // Se o arquivo da página com os 4 quadros se chamar garimpo.html
  window.location.href = 'garimpo.html';
}


// ================== FIM GARIMPO DE HOJE ==================
// ===== Institutional Window (MT / Utah) =====
(function(){
  const elWrap  = document.getElementById('inst-window');
  const elTag   = document.getElementById('inst-tag');
  const elRange = document.getElementById('inst-range');
  const elMsg   = document.getElementById('inst-msg');
  if (!elWrap || !elTag || !elRange || !elMsg) return;

  const WINDOWS = [
    { start: 5*60,      end: 7*60+30, tag:'PRE-MKT',      range:'5:00–7:30 MT',   msg:'CAUTION — liquidez subindo',      tone:'caution' },
    { start: 7*60+30,   end: 8*60+30, tag:'OPEN DRIVE',   range:'7:30–8:30 MT',   msg:'ON ✅ — melhor janela do dia',      tone:'on' },
    { start: 8*60+30,   end: 9*60+30, tag:'MID-MORNING',  range:'8:30–9:30 MT',   msg:'ON ✅ — boas continuações',        tone:'on' },
    { start: 9*60+30,   end: 11*60+30,tag:'LUNCH / CHOP', range:'9:30–11:30 MT',  msg:'OFF ⚠️ — ruído alto',              tone:'off' },
    { start: 13*60,     end: 14*60,   tag:'POWER HOUR',   range:'13:00–14:00 MT', msg:'ON ✅ — fluxo forte',              tone:'on' },
  ];

  function getMtMinutesNow(){
    const parts = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/Denver',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    }).formatToParts(new Date());
    const hh = parseInt(parts.find(p => p.type === 'hour')?.value || '0', 10);
    const mm = parseInt(parts.find(p => p.type === 'minute')?.value || '0', 10);
    return hh*60 + mm;
  }

  function pickWindow(mins){
    for (const w of WINDOWS){
      if (mins >= w.start && mins < w.end) return w;
    }
    return { tag:'OFF HOURS', range:'—', msg:'OFF ⚠️ — fora das janelas institucionais', tone:'off' };
  }

    function paint(){
    const mins = getMtMinutesNow();
    const w = pickWindow(mins);

    elTag.textContent = w.tag;

    const nowRange = (() => {
      try{
        return new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/Denver',
          hour: 'numeric',
          minute: '2-digit'
        }).format(new Date()) + ' MT';
      }catch(_e){
        return '—';
      }
    })();

    elRange.textContent = (w.range && w.range !== '—') ? w.range : nowRange;
    elMsg.textContent = w.msg;


    elWrap.classList.remove('inst-on','inst-off','inst-caution');
    if (w.tone === 'on') elWrap.classList.add('inst-on');
    else if (w.tone === 'caution') elWrap.classList.add('inst-caution');
    else elWrap.classList.add('inst-off');
  }

  paint();
  setInterval(paint, 10 * 1000);
})();

</script>
<script>
/* ===================== MATCHER PICKER (AUTO PILOT LOOK) ===================== */
(function matcherPicker_addOnly(){
  if (window.__AARON_MATCHER_PICKER_INSTALLED__) return;
  window.__AARON_MATCHER_PICKER_INSTALLED__ = true;

  const DEFAULT_SYMBOLS = ['NVDA','TSLA','AMD','AAPL','MSFT','AMZN','META','GOOGL','NFLX','SPY','QQQ','IWM','PLTR'];

  const SYMBOLS =
    (Array.isArray(window.AARON_SYMBOLS) && window.AARON_SYMBOLS.length)
      ? window.AARON_SYMBOLS
      : DEFAULT_SYMBOLS;

  function injectStyles(){
    const id = "aaron-matcher-picker-style";
    if (document.getElementById(id)) return;

    const style = document.createElement("style");
    style.id = id;
    style.textContent = `
      /* ====== MATCHER com o mesmo “DNA” do AUTOPILOT v2 ====== */
      #matcher-picker.autopilot-v2{
        padding: 14px;
        border: 1px solid rgba(148,163,184,0.18);
        background:
          radial-gradient(1200px 500px at 20% 0%, rgba(56,189,248,0.10), transparent 60%),
          radial-gradient(900px 420px at 85% 10%, rgba(34,197,94,0.08), transparent 55%),
          rgba(2,6,23,0.35);
      }

      #matcher-picker .ap2-top{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:12px;
        margin-bottom:10px;
      }

      #matcher-picker .ap2-sub{
        margin-top:2px;
        font-size:0.78rem;
        opacity:0.75;
      }

      #matcher-picker .ap2-controls{
        display:flex;
        align-items:center;
        gap:10px;
      }

      #matcher-picker .ap2-sizing{
        margin: 10px 0 12px 0;
        padding: 12px;
        border-radius: 16px;
        border: 1px solid rgba(148,163,184,0.16);
        background: rgba(0,0,0,0.18);
        box-shadow: inset 0 0 0 1px rgba(2,6,23,0.15);
      }

      #matcher-picker .ap2-input-row{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      @media (max-width: 520px){
        #matcher-picker .ap2-input-row{ grid-template-columns: 1fr; }
      }

      #matcher-picker .ap2-field{
        display:flex;
        flex-direction: column;
        gap: 6px;
      }

      #matcher-picker .ap2-label{
        font-size: 0.72rem;
        opacity: .78;
        letter-spacing: .08em;
        text-transform: uppercase;
      }

      #matcher-picker .ap2-input{
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(148,163,184,0.20);
        background: rgba(2,6,23,0.35);
        color: rgba(226,232,240,0.96);
        outline: none;
      }

      #matcher-picker .ap2-input:focus{
        border-color: rgba(34,211,238,0.45);
        box-shadow: 0 0 0 4px rgba(34,211,238,0.10);
      }

      /* select com cara “premium” (seta discreta) */
      #matcher-picker select.ap2-input{
        appearance:none;
        padding-right: 34px;
        background-image:
          linear-gradient(45deg, transparent 50%, rgba(148,163,184,0.85) 50%),
          linear-gradient(135deg, rgba(148,163,184,0.85) 50%, transparent 50%);
        background-position:
          calc(100% - 16px) 50%,
          calc(100% - 11px) 50%;
        background-size: 6px 6px, 6px 6px;
        background-repeat: no-repeat;
      }

      /* evita cortar o popup */
#matcher-picker.autopilot-v2{ overflow: visible; }

/* força dark widgets quando possível */
#matcher-picker{ color-scheme: dark; }

/* esconde o select nativo */
#matcher-picker .ap2-field{ position:relative; }
#matcher-picker .mp-native-select{
  position:absolute;
  width:1px; height:1px;
  opacity:0;
  pointer-events:none;
}

/* dropdown custom (lista bonita) */
#matcher-picker .ap2-select{ position:relative; }
#matcher-picker .ap2-select-btn{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  cursor:pointer;
}
#matcher-picker #mp-symbol-text{
  font-weight: 900;
  letter-spacing: .04em;
}

/* caret */
#matcher-picker .ap2-caret{
  width: 9px; height: 9px;
  transform: rotate(45deg);
  border-right: 2px solid rgba(148,163,184,0.85);
  border-bottom: 2px solid rgba(148,163,184,0.85);
  opacity: .9;
  margin-right: 2px;
}
#matcher-picker .ap2-select.open .ap2-caret{
  transform: rotate(-135deg);
}

/* popup */
#matcher-picker .ap2-pop{
  position:absolute;
  left:0; right:0;
  top: calc(100% + 8px);
  z-index: 99999;
  padding: 10px;
  border-radius: 14px;
  border: 1px solid rgba(148,163,184,0.22);
  background: rgba(2,6,23,0.92);
  backdrop-filter: blur(10px);
  box-shadow:
    0 18px 50px rgba(0,0,0,0.55),
    inset 0 0 0 1px rgba(56,189,248,0.10);
  display:none;
}
#matcher-picker .ap2-select.open .ap2-pop{ display:block; }

#matcher-picker .ap2-select-search{
  width:100%;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.20);
  background: rgba(15,23,42,0.55);
  color: rgba(226,232,240,0.96);
  outline:none;
}
#matcher-picker .ap2-select-search:focus{
  border-color: rgba(34,211,238,0.45);
  box-shadow: 0 0 0 4px rgba(34,211,238,0.10);
}

#matcher-picker .ap2-list{
  margin-top: 8px;
  max-height: 260px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap: 6px;
  padding-right: 4px;
}

#matcher-picker .ap2-opt{
  width:100%;
  text-align:left;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(148,163,184,0.10);
  background: rgba(15,23,42,0.22);
  color: rgba(226,232,240,0.95);
  cursor:pointer;
  font-weight: 800;
  letter-spacing: .06em;
  transition: transform .08s ease, background .12s ease, border-color .12s ease;
}
#matcher-picker .ap2-opt:hover{
  background: rgba(56,189,248,0.12);
  border-color: rgba(56,189,248,0.26);
}
#matcher-picker .ap2-opt:active{ transform: translateY(1px); }

#matcher-picker .ap2-opt.active{
  background: rgba(34,197,94,0.12);
  border-color: rgba(34,197,94,0.32);
}

/* scrollbar (chrome) */
#matcher-picker .ap2-list::-webkit-scrollbar{ width: 10px; }
#matcher-picker .ap2-list::-webkit-scrollbar-thumb{
  background: rgba(148,163,184,0.22);
  border-radius: 999px;
}


      #matcher-picker .mp-hint{
        margin-top:10px;
        font-size: 11px;
        opacity: .85;
        color: rgba(148,163,184,0.90);
      }

      #matcher-picker .ap2-bottom{
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
      }

      /* ap-btn existe global, mas o “premium” do autopilot é ID-scoped.
         Então replicamos o ajuste aqui também: */
      #matcher-picker .ap-btn{
        border-radius: 14px;
        padding: 9px 12px;
        letter-spacing: .6px;
        background: rgba(15,23,42,0.25);
        border-color: rgba(148,163,184,0.28);
      }

      #matcher-picker .ap-btn:active{
        transform: translateY(1px);
      }

      /* alinha o “Preço” como no print */
      #matcher-picker #mp-price{
        text-align:right;
        font-weight:900;
      }
    `;
    document.head.appendChild(style);
  }

  function buildBlock(){
    const row = document.createElement("div");
    row.id = "matcher-picker-row";

    row.innerHTML = `
      <section id="matcher-picker" class="decision-card autopilot-v2" aria-label="Matcher Symbol Picker">
        <div class="ap2-top">
          <div>
            <div class="decision-title">MATCHER • SYMBOL</div>
            <div class="ap2-sub">Escolha 1 ativo para enviar ao workflow X</div>
          </div>

          <div class="ap2-controls">
            <div class="badge-outline" title="Somente seleção (não altera o painel)">
              <span class="dot"></span>
              <span>Selector</span>
            </div>
          </div>
        </div>

        <div class="ap2-sizing">
          <div class="ap2-input-row">
            <div class="ap2-field">
  <label class="ap2-label" for="mp-symbol-btn">Ativo</label>

  <!-- select real (mantém compatibilidade), mas invisível -->
  <select id="mp-symbol" class="ap2-input mp-native-select" aria-hidden="true" tabindex="-1"></select>

  <!-- dropdown bonito -->
  <div class="ap2-select" id="mp-symbol-dd">
    <button id="mp-symbol-btn"
            class="ap2-input ap2-select-btn"
            type="button"
            aria-haspopup="listbox"
            aria-expanded="false">
      <span id="mp-symbol-text">—</span>
      <span class="ap2-caret" aria-hidden="true"></span>
    </button>

    <div id="mp-symbol-pop" class="ap2-pop" role="listbox" aria-label="Ativos">
      <input id="mp-symbol-search"
             class="ap2-select-search"
             type="text"
             placeholder="Buscar..."
             autocomplete="off" />
      <div class="ap2-list" id="mp-symbol-list"></div>
    </div>
  </div>
</div>


            <div class="ap2-field">
              <label class="ap2-label" for="mp-price">Preço</label>
              <input id="mp-price" class="ap2-input" type="text" value="—" readonly />
            </div>
          </div>

          <div class="mp-hint">Evento: <code>aaron:symbolSelected</code></div>
        </div>

        <div class="ap2-bottom">
          <button class="ap-btn" id="mp-copy" type="button">Copiar símbolo</button>
        </div>
      </section>
    `;
    return row;
  }

  function getQuote(symbol){
    const q = (window.AARON_QUOTES && window.AARON_QUOTES[symbol]) ? window.AARON_QUOTES[symbol] : null;
    if (q && typeof q.price === "number") return q.price;

    const p = window.__AARON_LAST_PANEL_JSON__;
    if (p){
      const pSym = (p.symbol || p.ticker || (p.trade && p.trade.symbol) || (p.execution && p.execution.symbol));
      const pPrice = p.price ?? p.last_price ?? (p.trade && (p.trade.price || p.trade.last_price));
      if (pSym && String(pSym).toUpperCase().includes(symbol) && typeof pPrice === "number") return pPrice;
    }
    return null;
  }

  function refreshPrice(priceEl, symbol){
    const v = getQuote(symbol);
    priceEl.value = (typeof v === "number") ? v.toFixed(2) : "—";
  }

  function emit(symbol, priceEl){
    localStorage.setItem("aaron_selected_symbol", symbol);
    window.AARON_SELECTED_SYMBOL = symbol;

    window.dispatchEvent(new CustomEvent("aaron:symbolSelected", { detail: { symbol } }));
    refreshPrice(priceEl, symbol);
  }

  function install(){
    injectStyles();
    if (document.getElementById("matcher-picker-row")) return;

    const row = buildBlock();

    // âncora: COLUNA DIREITA, antes do primeiro card (Resumo institucional)
    const cols = document.querySelectorAll("main.layout > section.column");
    const rightCol = (cols && cols.length >= 2) ? cols[1] : null;
    if (!rightCol) return;

    const firstCard = rightCol.querySelector(".card, .decision-card") || rightCol.firstElementChild;
    if (firstCard) firstCard.insertAdjacentElement("beforebegin", row);
    else rightCol.appendChild(row);

    const sel = row.querySelector("#mp-symbol");
    const priceEl = row.querySelector("#mp-price");
    const copyBtn = row.querySelector("#mp-copy");

    SYMBOLS.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s;
      opt.textContent = s;
      sel.appendChild(opt);
    });

    const saved = localStorage.getItem("aaron_selected_symbol");
    if (saved && SYMBOLS.includes(saved)) sel.value = saved;

    sel.addEventListener("change", () => emit(sel.value, priceEl));

    // ===== dropdown bonito (espelha o <select>) =====
const dd = row.querySelector("#mp-symbol-dd");
const btn = row.querySelector("#mp-symbol-btn");
const txt = row.querySelector("#mp-symbol-text");
const search = row.querySelector("#mp-symbol-search");
const list = row.querySelector("#mp-symbol-list");

function closeDD(){
  dd.classList.remove("open");
  btn.setAttribute("aria-expanded", "false");
}

function openDD(){
  dd.classList.add("open");
  btn.setAttribute("aria-expanded", "true");
  search.value = "";
  renderOptions("");
  setTimeout(() => search.focus(), 0);
}

function renderOptions(filter){
  const f = String(filter || "").trim().toUpperCase();
  list.innerHTML = "";
  SYMBOLS
    .filter(s => !f || s.includes(f))
    .forEach(s => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "ap2-opt" + (s === sel.value ? " active" : "");
      b.setAttribute("role", "option");
      b.setAttribute("aria-selected", s === sel.value ? "true" : "false");
      b.textContent = s;
      b.addEventListener("click", () => {
        sel.value = s;           // espelha no select real
        txt.textContent = s;     // atualiza UI
        emit(s, priceEl);        // mantém teu comportamento
        closeDD();
      });
      list.appendChild(b);
    });
}

btn.addEventListener("click", () => {
  dd.classList.contains("open") ? closeDD() : openDD();
});

btn.addEventListener("keydown", (e) => {
  if (e.key === "Enter" || e.key === " " || e.key === "ArrowDown") {
    e.preventDefault();
    openDD();
  }
  if (e.key === "Escape") {
    e.preventDefault();
    closeDD();
  }
});

search.addEventListener("input", () => renderOptions(search.value));
search.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    e.preventDefault();
    closeDD();
    btn.focus();
  }
});

// fecha clicando fora
document.addEventListener("pointerdown", (e) => {
  if (!dd.contains(e.target)) closeDD();
}, { capture: true });

// inicializa texto + lista
txt.textContent = sel.value || "—";
renderOptions("");
// ===== /dropdown bonito =====


    copyBtn.addEventListener("click", () => {
      const symbol = sel.value;
      navigator.clipboard?.writeText(symbol).then(() => {
        copyBtn.textContent = "Copiado ✓";
        setTimeout(() => copyBtn.textContent = "Copiar símbolo", 900);
      }).catch(() => {
        const ta = document.createElement("textarea");
        ta.value = symbol;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      });
    });

    emit(sel.value, priceEl);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", install);
  } else {
    install();
  }
})();
</script>
<script>
(function(){
  "use strict";

  function el(id){ return document.getElementById(id); }
    // SL FLEX dock: garante que o card fique no lugar certo (abaixo do STOP RISK)
  function dockSLFlex(){
    const dock = document.getElementById("slflex-dock");
    const card = document.getElementById("slflex-card");
    if (dock && card && card.parentElement !== dock) dock.appendChild(card);
  }
  window.addEventListener("DOMContentLoaded", dockSLFlex);

  function t(id){ return (el(id)?.textContent || "").trim(); }
  function numFrom(s){
    const m = String(s || "").match(/-?\d+(?:\.\d+)?/);
    return m ? Number(m[0]) : null;
  }
  function fmt2(n){ return (n == null || !Number.isFinite(n)) ? "—" : Number(n).toFixed(2); }
  function fmtPct(n){ return (n == null || !Number.isFinite(n)) ? "—" : `${Math.round(Number(n))}%`; }

  function fmtTimeMT(date){
    try{
      // MT = America/Denver
      return new Intl.DateTimeFormat("en-US", {
        timeZone: "America/Denver",
        hour: "numeric",
        minute: "2-digit"
      }).format(date);
    }catch(_e){
      const hh = String(date.getHours()).padStart(2,"0");
      const mm = String(date.getMinutes()).padStart(2,"0");
      return `${hh}:${mm}`;
    }
  }

  function updateExecMicroBox(){
    if (!el("prem-exec-micro")) return;
    // Current (pega do KPI da direita ou do header)
    const current = numFrom(t("prem-right-current-price") || t("prem-head-current-price"));

    // Payload & ctx (não depende do bloco do retângulo amarelo)
    const payload = window.__AARON_LAST_PAYLOAD__ || {};
    const panel   = payload.panel || payload || {};
    const digest  = payload.digest || {};
    const ctx     = window.__A10_EG_CTX || {};

    const numPick = (...vals) => {
      for (const v of vals) {
        if (v === null || v === undefined) continue;
        const n = Number(v);
        if (Number.isFinite(n)) return n;
      }
      return null;
    };

    const exec1x1 =
      panel.exec_1x1 ||
      payload.exec_1x1 ||
      digest.exec_1x1 ||
      payload.digest?.exec_1x1 ||
      payload.ui?.exec_1x1 ||
      null;

    // ATR14 / Micro Take (preferindo ctx, que já é alimentado pelo updatePremonitionPanel)
    const atr14     = numPick(ctx.atr14, digest.atr14, panel.atr14, digest.indicators?.atr14, panel.indicators?.atr14, exec1x1?.atr14);
    const microTake = numPick(ctx.microTake, digest.micro_target, digest.micro_take, panel.micro_target, panel.micro_take, exec1x1?.micro_take, exec1x1?.microTake);

    // Prob / ETA (preferindo premonição)
    const prob = (window.__A10_PREM_MICRO_PCT != null && Number.isFinite(Number(window.__A10_PREM_MICRO_PCT)))
      ? Number(window.__A10_PREM_MICRO_PCT)
      : numPick(numFrom(t("prem-right-prob")), exec1x1?.micro_prob_pct);

    const etaMin = numPick(
      digest.micro_eta_min, digest.eta_micro_min,
      panel.micro_eta_min, panel.eta_micro_min,
      exec1x1?.micro_eta_min,
      numFrom(t("prem-right-eta"))
    );

    // Optimal Entry (Respiro): usa o JSON se vier; senão tenta extrair do respiro; senão ATR (fallback)
    const respiroLine =
      t("top_respiro_value") ||
      t("rr-respiro-full") ||
      t("prem-respiro-full");

    let optEntry = numPick(exec1x1?.optimal_entry, exec1x1?.optimalEntry);
    if (optEntry == null) optEntry = numFrom(respiroLine);

    // fallback: estima usando ATR14 e a direção do Micro Take vs Current
    if (optEntry == null && current != null && atr14 != null && Number.isFinite(current) && Number.isFinite(atr14)) {
      const k = 2.5; // fallback (~2.5x ATR14)
      if (microTake != null && Number.isFinite(microTake)) {
        optEntry = (microTake >= current) ? (current - atr14 * k) : (current + atr14 * k);
      }
    }

    // Prob pullback = 100 - prob
    const pullProb = (prob != null && Number.isFinite(prob)) ? (100 - Number(prob)) : null;

    // ETA do respiro (heurístico): eta_micro + 1
    const optEta = (etaMin != null && Number.isFinite(etaMin)) ? (Math.round(Number(etaMin)) + 1) : null;

    // Hora aproximada em MT
    const optTime = (optEta != null) ? fmtTimeMT(new Date(Date.now() + optEta * 60 * 1000)) : "—";

    // Atualiza o bloco grande (prem-exec-micro)
    if (el("execm-current"))        el("execm-current").textContent        = (current != null) ? fmt2(current) : "—";
    if (el("execm-atr14"))          el("execm-atr14").textContent          = (atr14 != null) ? fmt2(atr14) : "—";

    if (el("execm-micro-take"))     el("execm-micro-take").textContent     = (microTake != null) ? fmt2(microTake) : "—";
    if (el("execm-micro-prob"))     el("execm-micro-prob").textContent     = fmtPct(prob);
    if (el("execm-micro-eta"))      el("execm-micro-eta").textContent      = (etaMin != null && Number.isFinite(etaMin)) ? `~${Math.round(Number(etaMin))}m` : "—";

    if (el("execm-opt-entry"))      el("execm-opt-entry").textContent      = (optEntry != null) ? fmt2(optEntry) : "—";
    if (el("execm-pullback-prob"))  el("execm-pullback-prob").textContent  = fmtPct(pullProb);

    if (el("execm-opt-eta"))        el("execm-opt-eta").textContent        = (optEta != null) ? `~${optEta}m` : "—";
    if (el("execm-opt-time"))       el("execm-opt-time").textContent       = (optEta != null) ? optTime : "—";

        // ===== MICRO PATH (LIVE) • card lateral (somente UI) =====
    const microProb = (prob != null && Number.isFinite(Number(prob))) ? Number(prob) : null;
    const microTakeNum = (microTake != null && Number.isFinite(Number(microTake))) ? Number(microTake) : null;
    const etaMicro = (etaMin != null && Number.isFinite(Number(etaMin))) ? Math.round(Number(etaMin)) : null;

    const dirPath = (current != null && microTakeNum != null && Number.isFinite(Number(current)))
      ? (microTakeNum >= Number(current) ? "BUY" : "SELL")
      : null;

    const sign = (dirPath === "BUY") ? 1 : (dirPath === "SELL") ? -1 : 0;

    // Path A2 (extensão) — heurístico: 0.125×ATR14, ETA +2
    const a2Price = (microTakeNum != null && atr14 != null && Number.isFinite(Number(atr14)) && sign !== 0)
      ? (microTakeNum + sign * Number(atr14) * 0.125)
      : null;

    const a2Prob = (microProb != null) ? Math.max(0, Math.min(100, microProb * 0.68)) : null;
    const a2Eta  = (etaMicro != null) ? (etaMicro + 2) : null;

    // Path B (falha antes) — heurístico: prob = 100 - microProb; alvo = espelho 1x1; ETA +1
    const bProb  = (microProb != null) ? (100 - microProb) : null;
    const bPrice = (current != null && microTakeNum != null && Number.isFinite(Number(current)))
      ? (2 * Number(current) - microTakeNum)
      : null;
    const bEta   = (etaMicro != null) ? (etaMicro + 1) : null;

    if (el("mpl-current"))  el("mpl-current").textContent  = (current != null) ? fmt2(current) : "—";
    if (el("mpl-atr14"))    el("mpl-atr14").textContent    = (atr14 != null) ? fmt2(atr14) : "—";

    if (el("mpl-a1-pct"))   el("mpl-a1-pct").textContent   = fmtPct(microProb);
    if (el("mpl-a1-price")) el("mpl-a1-price").textContent = (microTakeNum != null) ? fmt2(microTakeNum) : "—";
    if (el("mpl-a1-eta"))   el("mpl-a1-eta").textContent   = (etaMicro != null) ? `~${etaMicro}m` : "—";

    if (el("mpl-a2-pct"))   el("mpl-a2-pct").textContent   = fmtPct(a2Prob);
    if (el("mpl-a2-price")) el("mpl-a2-price").textContent = (a2Price != null) ? fmt2(a2Price) : "—";
    if (el("mpl-a2-eta"))   el("mpl-a2-eta").textContent   = (a2Eta != null) ? `~${a2Eta}m` : "—";

    if (el("mpl-b-pct"))    el("mpl-b-pct").textContent    = fmtPct(bProb);
    if (el("mpl-b-price"))  el("mpl-b-price").textContent  = (bPrice != null) ? fmt2(bPrice) : "—";
    if (el("mpl-b-eta"))    el("mpl-b-eta").textContent    = (bEta != null) ? `~${bEta}m` : "—";
    // ===== /MICRO PATH (LIVE) =====


    // ===== EXEC (MICRO) MINI • PLAN 1x1 (somente UI) =====
    const dir = (current != null && microTake != null && Number.isFinite(current) && Number.isFinite(microTake))
      ? (microTake >= current ? "BUY" : "SELL")
      : null;

    const risk1x1 = (current != null && microTake != null && Number.isFinite(current) && Number.isFinite(microTake))
      ? Math.abs(current - microTake)
      : null;

    const stop1x1 = (risk1x1 != null && dir)
      ? (dir === "SELL" ? (current + risk1x1) : (current - risk1x1))
      : null;

    if (el("execm-mini-dir"))      el("execm-mini-dir").textContent      = dir || "—";
    if (el("execm-mini-current"))  el("execm-mini-current").textContent  = (current != null) ? fmt2(current) : "—";
    if (el("execm-mini-atr14"))    el("execm-mini-atr14").textContent    = (atr14 != null) ? fmt2(atr14) : "—";

    if (el("execm-mini-tp"))       el("execm-mini-tp").textContent       = (microTake != null) ? fmt2(microTake) : "—";
    if (el("execm-mini-prob"))     el("execm-mini-prob").textContent     = fmtPct(prob);
    if (el("execm-mini-eta"))      el("execm-mini-eta").textContent      = (etaMin != null && Number.isFinite(etaMin)) ? `~${Math.round(Number(etaMin))}m` : "—";

    if (el("execm-mini-entry"))    el("execm-mini-entry").textContent    = (current != null) ? fmt2(current) : "—";
    if (el("execm-mini-sl"))       el("execm-mini-sl").textContent       = (stop1x1 != null) ? fmt2(stop1x1) : "—";
    if (el("execm-mini-risk"))     el("execm-mini-risk").textContent     = (risk1x1 != null) ? fmt2(risk1x1) : "—";

    if (el("execm-mini-reentry"))  el("execm-mini-reentry").textContent  = (optEntry != null) ? fmt2(optEntry) : "—";
    if (el("execm-mini-revprob"))  el("execm-mini-revprob").textContent  = fmtPct(pullProb);
    if (el("execm-mini-reveta"))   el("execm-mini-reveta").textContent   = (optEta != null) ? `~${optEta}m` : "—";
                // ===== STOP LOSS REENTRY (quadro amarelo) =====
    const payloadSL = window.__AARON_LAST_PAYLOAD__ || {};
    const panelSL   = payloadSL.panel || payloadSL || {};

    const exec1x1SL =
      panelSL.exec_1x1 ||
      payloadSL.exec_1x1 ||
      payloadSL.digest?.exec_1x1 ||
      payloadSL.ui?.exec_1x1 ||
      null;

    const best =
      exec1x1SL?.reentry_post_stop_v1?.best ||
      exec1x1SL?.reentry_post_stop?.best ||
      exec1x1SL?.post_stop?.best ||
      null;

        const asNum = (v) => {
      if (v === null || v === undefined || v === "") return null;
      if (typeof v === "number") return Number.isFinite(v) ? v : null;
      const s = String(v).trim().replace(",", ".");
      const m = s.match(/-?\d+(?:\.\d+)?/);
      if (!m) return null;
      const n = Number(m[0]);
      return Number.isFinite(n) ? n : null;
    };



    const dirFixed = (() => {
      const d = String(exec1x1SL?.dir ?? exec1x1SL?.side ?? exec1x1SL?.direction ?? "").toUpperCase();
      if (d.includes("SELL") || d.includes("SHORT") || d === "S") return "SELL";
      if (d.includes("BUY")  || d.includes("LONG")  || d === "B") return "BUY";
      return null;
    })();

    // direção do plano pelo MICRO (não depende do JSON) — robusto (microTake pode vir string)
const microTakeN = (microTake == null ? null : Number(microTake));
const microTakeOk = (microTakeN != null && Number.isFinite(microTakeN));

const dirFromMicro = (() => {
  if (current == null || !microTakeOk) return null;
  if (microTakeN > current) return "BUY";
  if (microTakeN < current) return "SELL";
  return null;
})();

const dirUse = dirFromMicro || dirFixed || dir;

// SL 1x1 automático (espelhado em relação ao TP=microTake) — NUNCA mexe no microTake
const slAuto1x1 = (current != null && microTakeOk)
  ? (2 * current - microTakeN)
  : null;

// SL 1x1: tenta usar o JSON só se for 1x1 de verdade e do lado certo;
// caso contrário, usa o 1x1 automático do micro
const slFromJson = asNum(exec1x1SL?.orders_v12?.stop ?? exec1x1SL?.orders_v12?.sl ?? exec1x1SL?.stop);
const sl1x1Micro = (slAuto1x1 != null && Number.isFinite(slAuto1x1)) ? slAuto1x1 : stop1x1;

// default: sempre o 1x1 do micro
let slPrice = sl1x1Micro ?? slFromJson ?? null;

if (current != null && dirUse && slFromJson != null && sl1x1Micro != null) {
  // BUY => SL abaixo do current | SELL => SL acima do current
  const sideOk = (dirUse === "BUY") ? (slFromJson < current) : (slFromJson > current);

  // 1x1 => distância até SL tem que bater com a distância até o TP (risk1x1)
  const distJson = Math.abs(current - slFromJson);
  const dist1x1  = (risk1x1 != null && Number.isFinite(risk1x1)) ? risk1x1 : Math.abs(current - sl1x1Micro);

  const distOk = Math.abs(distJson - dist1x1) <= Math.max(0.02, dist1x1 * 0.15);

  // só aceita o SL do JSON se passar nos dois testes
  if (sideOk && distOk) slPrice = slFromJson;
}

// SANITY final (garantia absoluta do lado certo)
if (current != null && slPrice != null && dirUse) {
  const wrongSide =
    (dirUse === "BUY"  && slPrice >= current) ||
    (dirUse === "SELL" && slPrice <= current);

  if (wrongSide) slPrice = sl1x1Micro ?? slPrice;
}



    // depth ATR estatístico (fallback 0.8 se não vier)
    const depthAtr = (() => {
      const v = asNum(best?.depth_atr ?? best?.depthAtr);
      return (v != null && v > 0) ? v : 0.8;
    })();

    // tempo estatístico (mediana)
    const tMed = asNum(best?.t_stop_to_reentry_med ?? best?.t_stop_to_reentry_p50 ?? best?.t_med);

    // chance estatística
    let chance = asNum(best?.stop_then_target_pct ?? best?.stop_then_target_uncond_pct ?? best?.hit_rate_pct);
    if (chance != null && chance > 0 && chance <= 1) chance = chance * 100;
    // ===== STOP RISK (1x1) — NOVO QUADRO =====
        // ===== SL FLEX — garantir dock no STOP RISK =====
    try { dockSLFlex(); } catch(e){}
    // ===== /SL FLEX =====


    // Probabilidades: preferir LIVE (reversal_classifier) e, se não houver, usar híbrido (stats + Micro LIVE)
const toPct100 = (x) => {
  const n = asNum(x);
  if (n == null) return null;
  return (n > 0 && n <= 1) ? (n * 100) : n;
};

const revProbStats  = toPct100(
  exec1x1SL?.reversal_prob_pct ??
  exec1x1SL?.reversalProbPct ??
  exec1x1SL?.rev_prob_pct ??
  exec1x1SL?.reversao_prob_pct ??
  exec1x1SL?.prob_reversao_pct ??
  exec1x1SL?.reversal_probability ??
  null
);

const pullProbStats = toPct100(
  exec1x1SL?.prob_pullback_pct ??
  exec1x1SL?.pullback_prob_pct ??
  exec1x1SL?.pullbackProbPct ??
  exec1x1SL?.prob_respiro_pct ??
  exec1x1SL?.respiro_prob_pct ??
  exec1x1SL?.pullback_probability ??
  null
);


const rc = exec1x1SL?.reversal_classifier || payload.reversal_classifier || panel.reversal_classifier || digest.reversal_classifier || null;
const rcOpp  = toPct100(rc?.opp_pct);   // opposite/trap → REVERSÃO
const rcCont = toPct100(rc?.cont_pct);  // continuation → RESPIRO/CONTINUAÇÃO

const microProbNow = (prob != null && Number.isFinite(Number(prob))) ? Number(prob) : null;
const microFailNow = (microProbNow != null) ? (100 - microProbNow) : null;

const W_STATS = 0.80, W_LIVE = 0.20;

const revProb = (rcOpp != null)
  ? rcOpp
  : (revProbStats != null && microFailNow != null)
    ? (W_STATS * revProbStats + W_LIVE * microFailNow)
    : revProbStats;

const pullProbUse = (rcCont != null)
  ? rcCont
  : (pullProbStats != null && microFailNow != null)
    ? (W_STATS * pullProbStats + W_LIVE * (microFailNow * 0.50))
    : pullProbStats;

const stopToMicro = asNum(exec1x1SL?.stop_to_target_eta_min ?? exec1x1SL?.stop_to_micro_eta_min);


    // stop_then_target_pct (se existir) senão usa chance
    let stopThenMicroPct = asNum(exec1x1SL?.stop_then_target_pct) ?? chance;
    if (stopThenMicroPct != null && stopThenMicroPct > 0 && stopThenMicroPct <= 1) stopThenMicroPct *= 100;

    // Heurística: stop risk = 0.60*reversal + 0.40*(100 - microProb)
    const microProbForRisk = (prob != null && Number.isFinite(Number(prob))) ? Number(prob) : null;
    const stopRiskPct = (revProb != null && microProbForRisk != null)
      ? (0.60 * revProb + 0.40 * (100 - microProbForRisk))
      : (revProb != null ? revProb : null);

    const clamp = (v) => Math.max(0, Math.min(100, v ?? 0));
    const riskLevel =
      (stopRiskPct == null) ? null :
      (stopRiskPct >= 65 ? "ALTO" :
       stopRiskPct >= 40 ? "MÉDIO" : "BAIXO");

    if (el("sr-stop-first-pct")) el("sr-stop-first-pct").textContent = fmtPct(stopRiskPct);

    if (el("sr-risk-badge")) {
      const b = el("sr-risk-badge");
      b.textContent = (riskLevel && stopRiskPct != null)
        ? `Stop Risk: ${riskLevel} (${Math.round(stopRiskPct)}%)`
        : "Stop Risk: —";
            // ===== SL FLEX (Respiro Profundo) — NOVO BLOCO (retângulo amarelo inferior) =====
    if (el("slflex-card")) {
      const rd = exec1x1SL?.respiro_depth_atr || exec1x1SL?.pullback_depth_atr || exec1x1SL?.respiroDepthAtr || null;

      const p25 = asNum(rd?.p25 ?? rd?.p25_atr ?? rd?.q25);
      const p50 = asNum(rd?.p50 ?? rd?.p50_atr ?? rd?.q50);
      const p75 = asNum(rd?.p75 ?? rd?.p75_atr ?? rd?.q75);

      const stopAtrNow = asNum(exec1x1SL?.stop_atr ?? exec1x1SL?.sl_atr ?? exec1x1SL?.stopAtr);

      // Probabilidades (usa as mesmas do STOP RISK)
      if (el("slflex-prob-respiro")) el("slflex-prob-respiro").textContent = (pullProbStats != null) ? fmtPct(pullProbStats) : "—";
      if (el("slflex-prob-reversao")) el("slflex-prob-reversao").textContent = (revProb != null) ? fmtPct(revProb) : "—";


      if (el("slflex-depth-p25")) el("slflex-depth-p25").textContent = fmt2(p25);
      if (el("slflex-depth-p50")) el("slflex-depth-p50").textContent = fmt2(p50);
      if (el("slflex-depth-p75")) el("slflex-depth-p75").textContent = fmt2(p75);

      if (el("slflex-stop-atr")) el("slflex-stop-atr").textContent = fmt2(stopAtrNow);

      // Sugestão de multiplicador (1x1 → 1x1.2/1.5/2.0) baseado no P50
      let mult = null;
      if (stopAtrNow != null && stopAtrNow > 0 && p50 != null) {
        const r = p50 / stopAtrNow;
        mult = (r <= 1.05) ? 1.0 : (r <= 1.25) ? 1.2 : (r <= 1.55) ? 1.5 : 2.0;
      }

      const sugAtr = (mult != null && stopAtrNow != null) ? (stopAtrNow * mult) : null;

      if (el("slflex-suggest-mult")) el("slflex-suggest-mult").textContent = (mult != null) ? `1x${mult.toFixed(1)}` : "—";
      if (el("slflex-suggest-atr")) el("slflex-suggest-atr").textContent = (sugAtr != null) ? fmt2(sugAtr) : "—";

      // Termômetro (0 → 2.5 ATR)
      const maxAtr = 2.5;
      const pct = (v) => (v == null || !Number.isFinite(v)) ? null : Math.max(0, Math.min(100, (v / maxAtr) * 100));

      const pStop = pct(stopAtrNow);
      const pP50  = pct(p50);
      const pP75  = pct(p75);

      if (el("slflex-fill")) el("slflex-fill").style.width = (pP50 != null) ? `${pP50}%` : "0%";
      if (el("slflex-mark-stop")) el("slflex-mark-stop").style.left = (pStop != null) ? `calc(${pStop}% - 6px)` : "0%";
      if (el("slflex-mark-p50")) el("slflex-mark-p50").style.left = (pP50 != null) ? `calc(${pP50}% - 6px)` : "0%";
      if (el("slflex-mark-p75")) el("slflex-mark-p75").style.left = (pP75 != null) ? `calc(${pP75}% - 6px)` : "0%";

      // Leitura
      let read = "Leitura: —";
      if (stopAtrNow != null && p25 != null && p50 != null && p75 != null) {
        if (stopAtrNow >= p75) read = "Leitura: SL 1x1 OK — difícil tomar stop por respiro.";
        else if (stopAtrNow >= p50) read = "Leitura: SL 1x1 razoável — respiro profundo às vezes.";
        else if (stopAtrNow >= p25) read = `Leitura: SL 1x1 apertado — considere SL 1x${(mult ?? 1.2).toFixed(1)} para evitar stops em respiro.`;
        else read = "Leitura: SL 1x1 MUITO apertado — respiro tende a passar do seu SL.";
      }

      if (el("slflex-advice")) el("slflex-advice").textContent = read;
    }
    // ===== /SL FLEX =====


      b.style.color =
        (riskLevel === "ALTO") ? "#fb7185" :
        (riskLevel === "MÉDIO") ? "#facc15" :
        (riskLevel === "BAIXO") ? "#34d399" : "";
    }

    if (el("sr-meter-fill")) {
      const f = el("sr-meter-fill");
      f.style.width = `${clamp(stopRiskPct).toFixed(0)}%`;
      f.style.background =
        (riskLevel === "ALTO") ? "rgba(251,113,133,.85)" :
        (riskLevel === "MÉDIO") ? "rgba(250,204,21,.85)" :
        (riskLevel === "BAIXO") ? "rgba(52,211,153,.85)" :
        "rgba(255,255,255,.18)";
    }

    if (el("sr-market-msg")) {
      const msgEl = el("sr-market-msg");
      if (revProb != null && revProb >= 60) msgEl.textContent = "Mercado em Reversão/Chop.";
      else if (pullProbUse != null && pullProbUse >= 40) msgEl.textContent = "Mercado em Respiro (pullback) — ruído alto.";
      else msgEl.textContent = "Mercado neutro — risco moderado.";
    }

    if (el("sr-respiro-atr")) el("sr-respiro-atr").textContent = "0.25";
    if (el("sr-stop-reentry-eta")) el("sr-stop-reentry-eta").textContent = (tMed != null) ? `~${Math.round(tMed)}m` : "—";
    if (el("sr-stop-target-pct")) el("sr-stop-target-pct").textContent = (stopThenMicroPct != null) ? `${stopThenMicroPct.toFixed(2)}%` : "—";
    if (el("sr-after-stop-micro-pct")) el("sr-after-stop-micro-pct").textContent = (stopThenMicroPct != null) ? `${stopThenMicroPct.toFixed(2)}%` : "—";
    if (el("sr-stop-to-micro-eta")) el("sr-stop-to-micro-eta").textContent = (stopToMicro != null) ? `~${Math.round(stopToMicro)}m` : "—";
    // ===== RESPIRO x REVERSÃO (MICRO) — BLOCO AMARELO =====
const normPct = (x) => (x == null) ? null : ((x > 0 && x <= 1) ? x * 100 : x);

const respiroPct = normPct(pullProbUse);
const reversaoPct = normPct(revProb);
// ===== MICRO MAP (NOW) — 3 linhas (Micro / Respiro / Reversão) =====
(function renderMicroMapNow(){
  // helpers locais (não conflitam com o resto do painel)
  const fmtPct2d = (x) => {
    const n = asNum(normPct(x));
    return (n == null) ? "—" : `${n.toFixed(2)}%`;
  };
  const fmtEta = (m) => {
    const n = asNum(m);
    return (n == null) ? "—" : `~${Math.max(0, Math.round(n))}m`;
  };

  // Preferir dados do matcher (micro_path_live / v1) onde existirem
const mp =
  // 1) se vier grudado no exec_1x1 (raramente)
  exec1x1SL?.micro_path_v1 ||
  exec1x1SL?.micro_path ||

  // 2) Digest V19 (LAST_PAYLOAD / real-time)
  panelSL?.micro_path_live ||
  payloadSL?.micro_path_live ||
  payloadSL?.digest?.micro_path_live ||
  payloadSL?.ui?.micro_path_live ||

  // 3) fallback do payload “normal”
  panel?.micro_path_live ||
  digest?.micro_path_live ||
  payload?.micro_path_live ||

  // 4) versões antigas (v1 / legacy)
  panelSL?.micro_path_v1 ||
  panelSL?.micro_path ||
  panel?.micro_path_v1 ||
  panel?.micro_path ||
  payload?.micro_path_v1 ||
  payload?.micro_path ||

  null;


// (mbt) micro base time — só p/ consistência/debug
const mbt =
  mp?.base_time || mp?.base_ts ||
  payload?.micro_base_time || payload?.micro_base_ts ||
  null;

const curMap = asNum(mp?.current) ?? asNum(current);

// ATR usado no Micro Map: mp.atr14 > micro_path_live.atr14 > atr14
const atrMap =
  asNum(mp?.atr14) ??
  asNum(payload?.micro_path_live?.atr14) ??
  asNum(atr14);

  const microTarget = asNum(mp?.micro_live_target) ?? asNum(microTake);
  const microOk = (curMap != null && microTarget != null);

  const dirMap = (() => {
    if (!microOk) return null;
    if (microTarget > curMap) return "BUY";
    if (microTarget < curMap) return "SELL";
    return null;
  })();

  const arrowMicro = (dirMap === "BUY") ? "↑" : (dirMap === "SELL") ? "↓" : "";
  const arrowOpp  = (dirMap === "BUY") ? "↓" : (dirMap === "SELL") ? "↑" : "";

  // micro prob/eta — usa micro_path_v1 se tiver, senão cai no que já existe
  const microProb = asNum(mp?.micro_live_prob_pct ?? mp?.micro_live?.prob_pct ?? prob);
  const microEta  = asNum(mp?.micro_live_eta_min ?? mp?.micro_live?.eta_min ?? etaMin);

  const microLine = microOk
    ? `MICRO LIVE — NOW: ${fmtEta(microEta)} • ${fmtPct2d(microProb)} • Target ${fmt2(microTarget)} ${arrowMicro}`
    : `MICRO LIVE — NOW: —`;

  // ===== RESPIRO (p75) =====
  const p75Obj = mp?.respiro?.levels?.p75 || null;

  // preço pronto do matcher (melhor)
  let respiroPrice = asNum(p75Obj?.price);

  // fallback: calcular via depth_atr * atr14
  const depthP75 =
    asNum(p75Obj?.depth_atr) ??
    asNum(mp?.respiro?.depth_p75_atr) ??
    asNum(exec1x1SL?.respiro_depth_atr?.p75) ??
    null;

  if (respiroPrice == null && microOk && dirMap && atrMap != null && depthP75 != null) {
    respiroPrice = (dirMap === "SELL")
      ? (curMap + depthP75 * atrMap)
      : (curMap - depthP75 * atrMap);
  }

  const respiroProb =
    asNum(p75Obj?.prob_touch_pct) ??
    asNum(mp?.respiro?.prob_touch_pct_p75) ??
    asNum(respiroPct);

  const respiroEta =
    asNum(p75Obj?.eta_min) ??
    ((microEta != null) ? (microEta + 1) : null);

    // ===== REVERSÃO (gatilho) + SL duro (1x1) =====
  const slHard = microOk ? (2 * curMap - microTarget) : null; // SL 1x1 (DURO)

  // gatilho de reversão (SOFT). Se não vier do matcher, cai no SL duro.
  let revTrigger =
    asNum(mp?.reversal?.trigger_price) ??
    slHard;

  const revProb =
    asNum(mp?.reversal?.prob_stop_before_target_pct) ??
    asNum(reversaoPct);

  const revEta =
    asNum(mp?.reversal?.eta_min) ??
    microEta;

  // ===== CLAMPS (pra nunca existir "RESPIRO passa do STOP") =====
  const eps = (slHard != null && curMap != null)
    ? Math.max(0.01, Math.min(0.05, Math.abs(Number(slHard) - Number(curMap)) * 0.05))
    : 0.01;

  let noteRespiro = "";
  let noteRev = "";

  // 1) garante que o gatilho nunca fique além do SL duro
  if (dirMap && revTrigger != null && slHard != null) {
    if (dirMap === "SELL" && revTrigger > slHard) { revTrigger = slHard; noteRev = " (capado pelo SL 1x1)"; }
    if (dirMap === "BUY"  && revTrigger < slHard) { revTrigger = slHard; noteRev = " (capado pelo SL 1x1)"; }
  }

  // 2) RESPIRO não pode passar do REV gatilho e nem do SL duro
  //    SELL: cur < respiro < revTrigger <= slHard
  //    BUY : cur > respiro > revTrigger >= slHard
  if (dirMap && respiroPrice != null) {
    const capBase =
      (revTrigger != null && slHard != null) ? Math.min(revTrigger, slHard)
      : (revTrigger != null ? revTrigger : (slHard != null ? slHard : null));

    const floorBase =
      (revTrigger != null && slHard != null) ? Math.max(revTrigger, slHard)
      : (revTrigger != null ? revTrigger : (slHard != null ? slHard : null));

    if (dirMap === "SELL" && capBase != null) {
      const cap = Math.max(curMap + eps, capBase - eps);
      if (respiroPrice > cap) { respiroPrice = cap; noteRespiro = " (capado)"; }
    }

    if (dirMap === "BUY" && floorBase != null) {
      const floor = Math.min(curMap - eps, floorBase + eps);
      if (respiroPrice < floor) { respiroPrice = floor; noteRespiro = " (capado)"; }
    }
  }

  const respiroLine = (respiroPrice != null && dirMap)
    ? `RESPIRO (max / p75): ${fmtEta(respiroEta)} • ${fmtPct2d(respiroProb)} • Pode esticar até ${fmt2(respiroPrice)} ${arrowOpp} (${dirMap === "SELL" ? "antes de cair" : "antes de subir"})${noteRespiro}`
    : `RESPIRO (max / p75): —`;

  const reversaoLine = (revTrigger != null && dirMap)
    ? `REVERSÃO (gatilho): ${fmtEta(revEta)} • ${fmtPct2d(revProb)} • Se tocar ${fmt2(revTrigger)} ${arrowOpp} → invalida o micro ${dirMap} • SL 1x1: ${fmt2(slHard)}${noteRev}`
    : `REVERSÃO (gatilho): —`;


  const mm1 = el("mm-micro-line");
  const mm2 = el("mm-respiro-line");
  const mm3 = el("mm-reversao-line");

  if (mm1) {
    mm1.textContent = microLine;
    mm1.style.color = (dirMap === "BUY") ? "var(--success)" : (dirMap === "SELL") ? "#fb7185" : "";
  }
  if (mm2) {
    mm2.textContent = respiroLine;
    mm2.style.color = "#facc15";
  }
  if (mm3) {
    mm3.textContent = reversaoLine;
    mm3.style.color = "var(--danger)";
  }
    // preço + horário estimado do RESPIRO / REVERSÃO (no card)
  const nowMs = Date.now();

  const rrvResMeta = el("rrv-respiro-meta");
  if (rrvResMeta) {
    const m = (respiroEta != null && Number.isFinite(Number(respiroEta))) ? Math.max(0, Number(respiroEta)) : null;
    const tt = (m != null) ? fmtTimeMT(new Date(nowMs + m * 60000)) : null;
    const p  = (respiroPrice != null) ? fmt2(respiroPrice) : null;
    rrvResMeta.textContent = (p && tt) ? `${p} @ ${tt} (MT)` : (p || "—");
  }

  const rrvRevMeta = el("rrv-reversao-meta");
  if (rrvRevMeta) {
    const m = (revEta != null && Number.isFinite(Number(revEta))) ? Math.max(0, Number(revEta)) : null;
    const tt = (m != null) ? fmtTimeMT(new Date(nowMs + m * 60000)) : null;
    const p  = (revTrigger != null) ? fmt2(revTrigger) : null;
    rrvRevMeta.textContent = (p && tt) ? `${p} @ ${tt} (MT)` : (p || "—");
  }

})();
// ===== /MICRO MAP (NOW) =====


if (el("rrv-respiro-pct"))  el("rrv-respiro-pct").textContent  = fmtPct(respiroPct);
if (el("rrv-reversao-pct")) el("rrv-reversao-pct").textContent = fmtPct(reversaoPct);

if (el("rrv-respiro-fill"))  el("rrv-respiro-fill").style.width  = `${clamp(respiroPct).toFixed(0)}%`;
if (el("rrv-reversao-fill")) el("rrv-reversao-fill").style.width = `${clamp(reversaoPct).toFixed(0)}%`;
// direcao da REVERSAO (oposto do lado do micro)
const pbSide = String(exec1x1SL?.pullback_brain?.side ?? panelSL?.pullback_brain?.side ?? "").toLowerCase();
const baseSide = (dirUse === "BUY" || dirUse === "SELL") ? dirUse : (pbSide === "buy" ? "BUY" : (pbSide === "sell" ? "SELL" : null));
const revDir = baseSide ? (baseSide === "BUY" ? "SELL" : "BUY") : null;

const revDirLabel = (revDir === "BUY") ? "↑ BUY" : (revDir === "SELL") ? "↓ SELL" : "—";
const revDirEl = el("rrv-reversao-dir");
if (revDirEl) {
  revDirEl.textContent = revDirLabel;
  revDirEl.style.borderColor = (revDir === "BUY") ? "rgba(52,211,153,.45)" : (revDir === "SELL") ? "rgba(251,113,133,.45)" : "rgba(255,255,255,.25)";
  revDirEl.style.background  = (revDir === "BUY") ? "rgba(52,211,153,.12)" : (revDir === "SELL") ? "rgba(251,113,133,.12)" : "rgba(255,255,255,.08)";
  revDirEl.style.color       = (revDir === "BUY") ? "#34d399" : (revDir === "SELL") ? "#fb7185" : "rgba(255,255,255,.75)";
}

const domEl  = el("rrv-dominant");
const readEl = el("rrv-reading");

if (domEl || readEl) {
  const a = (respiroPct != null) ? respiroPct : -1;
  const b = (reversaoPct != null) ? reversaoPct : -1;

  let dom = "—";
  let read = "—";

  if (a < 0 && b < 0) {
    dom = "—";
    read = "Sem dados.";
  } else {
    const high = Math.max(a, b);
    const diff = Math.abs(a - b);

    if (high < 35) {
      dom = "NEUTRO";
      read = "Probabilidades baixas → esperar confirmação do micro.";
    } else if (diff <= 10) {
      dom = "CHOP";
      read = "Respiro e reversão próximos → reduzir tamanho e aguardar.";
    } else if (a > b) {
      dom = "RESPIRO";
      read = "Pullback provável → melhor entrada é no respiro (Optimal Entry).";
    } else {
      dom = "REVERSÃO";
      read = "Risco de inverter → cautela; micro pode falhar antes.";
    }
  }

  if (domEl) {
    domEl.textContent = dom;
    domEl.style.color =
      (dom === "RESPIRO") ? "#34d399" :
      (dom === "REVERSÃO") ? "#fb7185" :
      (dom === "CHOP") ? "#facc15" :
      (dom === "NEUTRO") ? "rgba(255,255,255,.8)" : "";
  }

  if (readEl) readEl.textContent = read;
}
// ===== /RESPIRO x REVERSÃO (MICRO) =====

    // ===== /STOP RISK =====

    // status: SL atingiu ou não
    const slHit = (current != null && slPrice != null && dirUse)
      ? (dirUse === "SELL" ? (current >= slPrice) : (current <= slPrice))
      : null;

    const statusTxt = (slHit === null)
      ? "—"
      : (slHit ? "⚠️ SL atingido — executar reentrada" : "✅ SL não atingido — continuar");

    const ruleTxt = (slPrice != null && dirUse)
      ? (dirUse === "SELL"
          ? `Se current < ${fmt2(slPrice)} → ✅ SL não atingido — continuar · Se current ≥ ${fmt2(slPrice)} → ⚠️ SL atingido — executar reentrada`
          : `Se current > ${fmt2(slPrice)} → ✅ SL não atingido — continuar · Se current ≤ ${fmt2(slPrice)} → ⚠️ SL atingido — executar reentrada`)
      : "—";

    // TP travado = micro target (usa o microTake do UI)
const tpLocked = (microTakeOk) ? microTakeN : null;

// Reentrada = SL ± (depthAtr × ATR14) com trava para nunca passar do TP travado
const kRaw = (atr14 != null && Number.isFinite(atr14)) ? (atr14 * depthAtr) : null;

// cap: no máximo 60% da distância SL→TP (evita reentrada acima do TP)
const distSLTP = (tpLocked != null && slPrice != null) ? Math.abs(tpLocked - slPrice) : null;
const kCap = (distSLTP != null) ? Math.max(0, distSLTP * 0.60) : null;
const k = (kRaw != null && kCap != null) ? Math.min(kRaw, kCap) : kRaw;

// BUY: reentry acima do SL | SELL: reentry abaixo do SL
const reentry = (slPrice != null && k != null && dirUse)
  ? (dirUse === "SELL" ? (slPrice - k) : (slPrice + k))
  : null;


    // SL 1x1 da reentrada (1x1 ancorado no TP travado)
    const reRisk = (reentry != null && tpLocked != null) ? Math.abs(reentry - tpLocked) : null;
    const reSL = (reentry != null && reRisk != null && dirUse)
      ? (dirUse === "SELL" ? (reentry + reRisk) : (reentry - reRisk))
      : null;

    // inject DOM
    if (el("slr-optentry")) el("slr-optentry").textContent = (reentry != null) ? fmt2(reentry) : "—";
    if (el("slr-sl")) el("slr-sl").textContent = (slPrice != null) ? fmt2(slPrice) : "—";

    if (el("slr-status")) {
      const sEl = el("slr-status");
      sEl.textContent = statusTxt;
      sEl.style.color = (slHit === true) ? "#fb7185" : (slHit === false) ? "#34d399" : "";
    }

    if (el("slr-rule")) el("slr-rule").textContent = ruleTxt;

    if (el("slr-wait")) el("slr-wait").textContent = (tMed != null) ? `~${Math.round(tMed)}m` : "—";
    if (el("slr-entrytime")) {
  const when = (tMed != null && Number.isFinite(tMed))
    ? fmtTimeMT(new Date(Date.now() + (tMed * 60 * 1000)))
    : "—";
  el("slr-entrytime").textContent = when;
}


    if (el("slr-reentry")) el("slr-reentry").textContent = (reentry != null) ? fmt2(reentry) : "—";

    if (el("slr-reentry-note")) {
      const noteEl = el("slr-reentry-note");
      if (reentry != null && slPrice != null && atr14 != null && Number.isFinite(atr14)) {
        const sign = (dirUse === "SELL") ? "−" : "+";
        noteEl.textContent = ` (${fmt2(slPrice)} ${sign} ${depthAtr.toFixed(2)}×ATR14; ATR14=${fmt2(atr14)})`;
      } else {
        noteEl.textContent = "";
      }
    }

    if (el("slr-tp"))     el("slr-tp").textContent     = (tpLocked != null) ? fmt2(tpLocked) : "—";
    if (el("slr-resl"))   el("slr-resl").textContent   = (reSL != null) ? fmt2(reSL) : "—";
    if (el("slr-chance")) el("slr-chance").textContent = (chance != null) ? `${chance.toFixed(2)}%` : "—";
    // ===== /STOP LOSS REENTRY =====


    // ===== /EXEC (MICRO) MINI • PLAN 1x1 =====
  }

  // Atualiza continuamente sem encostar em nada do teu pipeline
  setInterval(updateExecMicroBox, 750);

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", updateExecMicroBox);
  } else {
    updateExecMicroBox();
  }
})();
/* ===== QUICK P&L (front-end only) — NÃO mexe no Premonition Micro Live ===== */
(function(){
  const $ = (id) => document.getElementById(id);

  const num = (s) => {
    if (s == null) return null;
    const raw = String(s).trim();
    if (!raw || raw === "—") return null;
    // remove tudo exceto dígitos, ponto, vírgula e sinal
    const cleaned = raw.replace(/[^\d.,-]/g, "").replace(",", ".");
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  };

  const fmt2 = (n) => (n == null || !Number.isFinite(n)) ? "—" : n.toFixed(2);

  const fmtMoney = (n) => {
    if (n == null || !Number.isFinite(n)) return "—";
    const abs = Math.abs(n);
    const txt = abs.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    return (n < 0 ? "-$" : "$") + txt;
  };

  const fmtInt = (n) => (n == null || !Number.isFinite(n)) ? "—" : Math.round(n).toLocaleString("en-US");

  function updatePnL(){
    const box = $("prem-pnlcalc");
    if (!box) return;

    const capEl  = $("pnl-capital");
    const modeEl = $("pnl-entrymode");

    const cap  = num(capEl?.value);
    const mode = modeEl?.value || "now";

    // lê do painel (já renderizado)
    const current = num($("prem-right-current-price")?.textContent);
    const opt     = num($("slr-optentry")?.textContent);
    const tp      = num($("slr-tp")?.textContent);
    const sl      = num($("slr-sl")?.textContent);

    const entry = (mode === "opt") ? opt : current;

    // direção inferida pelo TP vs entrada (não depende de mexer no micro)
    let dir = null;
    if (entry != null && tp != null){
      if (tp > entry) dir = "BUY";
      else if (tp < entry) dir = "SELL";
    }

    // delta até TP (lucro por share)
    let delta = null;
    if (entry != null && tp != null && dir){
      delta = (dir === "BUY") ? (tp - entry) : (entry - tp);
    }

    // risco até SL (perda por share)
    let lossPer = null;
    if (entry != null && sl != null && dir){
      lossPer = (dir === "BUY") ? (entry - sl) : (sl - entry);
      if (lossPer != null) lossPer = Math.abs(lossPer);
    }

    const shares = (cap != null && entry != null && cap > 0 && entry > 0)
      ? Math.floor(cap / entry)
      : null;

    const profit = (shares != null && delta != null)   ? (shares * delta)   : null;
    const loss   = (shares != null && lossPer != null) ? (shares * lossPer) : null;
    const rr     = (profit != null && loss != null && loss > 0) ? (profit / loss) : null;

    if ($("pnl-delta")) $("pnl-delta").textContent = (delta != null) ? fmt2(delta) : "—";
    if ($("pnl-delta-cents")) $("pnl-delta-cents").textContent = (delta != null) ? `(${Math.round(delta * 100)}¢)` : "";

    if ($("pnl-shares")) $("pnl-shares").textContent = (shares != null) ? fmtInt(shares) : "—";

    const pEl = $("pnl-profit");
    if (pEl){
      pEl.textContent = (profit != null) ? fmtMoney(profit) : "—";
      pEl.style.color = (profit != null) ? "#34d399" : "";
    }

    const lEl = $("pnl-loss");
    if (lEl){
      lEl.textContent = (loss != null) ? fmtMoney(-Math.abs(loss)) : "—";
    }

    const foot = $("pnl-foot");
    if (foot){
      const bits = [];
      if (dir) bits.push(`Dir: ${dir}`);
      if (entry != null) bits.push(`Entrada: ${fmt2(entry)}`);
      if (tp != null) bits.push(`TP: ${fmt2(tp)}`);
      if (sl != null) bits.push(`SL: ${fmt2(sl)}`);
      if (rr != null) bits.push(`RR≈${rr.toFixed(2)}x`);
      foot.textContent = bits.length ? bits.join(" · ") : "—";
    }
  }

  function loadPnL(){
    try{
      const capSaved  = localStorage.getItem("a10_pnl_capital");
      const modeSaved = localStorage.getItem("a10_pnl_entrymode");
      if ($("pnl-capital") && capSaved) $("pnl-capital").value = capSaved;
      if ($("pnl-entrymode") && modeSaved) $("pnl-entrymode").value = modeSaved;
    }catch(_e){}
  }

  function bindPnL(){
    const capEl  = $("pnl-capital");
    const modeEl = $("pnl-entrymode");

    if (capEl){
      capEl.addEventListener("input", () => {
        try{ localStorage.setItem("a10_pnl_capital", capEl.value); }catch(_e){}
        updatePnL();
      });
    }

    if (modeEl){
      modeEl.addEventListener("change", () => {
        try{ localStorage.setItem("a10_pnl_entrymode", modeEl.value); }catch(_e){}
        updatePnL();
      });
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      loadPnL();
      bindPnL();
      updatePnL();
    });
  } else {
    loadPnL();
    bindPnL();
    updatePnL();
  }

  // acompanha o painel (mesma cadência do exec micro)
  setInterval(updatePnL, 750);
})();
/* ===== EE BRAIN (Entry Brain) — onde/quando entrar (Target = Micro Live) ===== */
(function(){
  const $ = (id) => document.getElementById(id);

  const num = (v) => {
    if (v == null) return null;
    const s = String(v).replace(/[^0-9.\-]/g, "");
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  const fmt2 = (n) => (n == null || !Number.isFinite(n)) ? "—" : n.toFixed(2);
    function wrapPricesHTML(text, current){
    if (!text) return "—";

    const cur = Number.isFinite(current) ? current : null;
    const re = /-?\d+(?:\.\d+)?/g;

    let out = "";
    let last = 0;
    let m;

    while ((m = re.exec(text)) !== null){
      const raw = m[0];
      const idx = m.index;

      out += text.slice(last, idx);

      const n = parseFloat(raw);
      const after = text.slice(idx + raw.length);
      const afterTrim = after.replace(/^\s+/, "");

      const isPct = afterTrim.startsWith("%");          // não mexe em "70%"
      const isSmall = !Number.isFinite(n) || Math.abs(n) < 1; // não mexe em 0.07 etc

      if (isPct || isSmall){
        out += raw;
      } else {
        let cls = "ee-at";
        if (cur != null){
          if (n > cur) cls = "ee-above";
          else if (n < cur) cls = "ee-below";
        }
        out += `<span class="ee-price ${cls}">${raw}</span>`;
      }

      last = idx + raw.length;
    }

    out += text.slice(last);
    return out;
  }

  function eeFootHTML(stopRisk,respiroPct,reversaoPct){
    const sr = (stopRisk!=null && Number.isFinite(stopRisk)) ? Math.round(stopRisk) : null;
    const rp = (respiroPct!=null && Number.isFinite(respiroPct)) ? Math.round(respiroPct) : null;
    const rv = (reversaoPct!=null && Number.isFinite(reversaoPct)) ? Math.round(reversaoPct) : null;

    const a = (sr==null) ? "—" : `<span class="ee-pct ee-warn">${sr}%</span>`;
    const b = (rp==null) ? "—" : `<span class="ee-pct ee-ok">${rp}%</span>`;
    const c = (rv==null) ? "—" : `<span class="ee-pct ee-bad">${rv}%</span>`;
    return `StopRisk ${a} · Respiro ${b} · Reversão ${c}`;
  }
  const fmtPct = (p) => (p == null || !Number.isFinite(p)) ? "—" : `${Math.round(p)}%`;

  function parseEtaMin(txt){
    if (!txt) return null;
    const s = String(txt);
    let m = s.match(/~\s*(\d+(?:\.\d+)?)\s*(m|min)/i);
    if (m) return parseFloat(m[1]);
    m = s.match(/em\s*~?\s*(\d+(?:\.\d+)?)\s*min/i);
    if (m) return parseFloat(m[1]);
    return null;
  }

  function setBadge(state){
    const el = $("ee-status-badge");
    if (!el) return;
    el.classList.remove("go","wait","no");
    if (state === "GO"){ el.classList.add("go"); el.textContent = "GO"; }
    else if (state === "NO"){ el.classList.add("no"); el.textContent = "NO"; }
    else { el.classList.add("wait"); el.textContent = "WAIT"; }
  }

  function updateEEBrain(){
    if (!$("ee-brain-card")) return;

    // fontes confiáveis do seu painel (já existem)
    const current = num($("mpl-current")?.textContent) ?? num($("prem-right-current-price")?.textContent);
    const atr14   = num($("mpl-atr14")?.textContent);

    const target     = num($("mpl-a1-price")?.textContent) ?? num($("slr-tp")?.textContent);
    const targetPct  = num($("mpl-a1-pct")?.textContent) ?? num($("prem-right-prob")?.textContent);
    const etaTxt     = ($("mpl-a1-eta")?.textContent || $("prem-right-eta")?.textContent || "").trim();
    const etaMin     = parseEtaMin(etaTxt);

    const stopRisk   = num($("sr-stop-first-pct")?.textContent);
    const respiroPct = num($("rrv-respiro-pct")?.textContent);
    const reversaoPct= num($("rrv-reversao-pct")?.textContent);

    const optEntry   = num($("slr-optentry")?.textContent);
    const sl         = num($("slr-sl")?.textContent);
    const tp         = num($("slr-tp")?.textContent) ?? target;

    const d25 = num($("slflex-depth-p25")?.textContent);
    const d50 = num($("slflex-depth-p50")?.textContent);
    const d75 = num($("slflex-depth-p75")?.textContent);

    // preencher header
    if ($("ee-target")) $("ee-target").textContent = (target != null) ? fmt2(target) : "—";
    if ($("ee-target-pct")) $("ee-target-pct").textContent = fmtPct(targetPct);
    if ($("ee-target-eta")) $("ee-target-eta").textContent = (etaMin != null) ? `~${Math.round(etaMin)}m` : (etaTxt || "—");

    // sem dados? sai
    if (current == null || atr14 == null || tp == null){
      setBadge("WAIT");
      if ($("ee-plan")) $("ee-plan").textContent = "—";
      if ($("ee-entry")) $("ee-entry").textContent = "—";
      if ($("ee-trigger")) $("ee-trigger").innerHTML = "—";
      if ($("ee-cancel")) $("ee-cancel").innerHTML = "—";
      if ($("ee-foot")) $("ee-foot").innerHTML = "—";
      if ($("ee-foot")) $("ee-foot").textContent = "—";
      return;
    }

    const dir = (tp > current) ? "BUY" : "SELL";
    const sign = (dir === "BUY") ? -1 : +1;

    const pb25 = (d25 != null) ? current + sign * atr14 * d25 : null;
    const pb50 = (d50 != null) ? current + sign * atr14 * d50 : null;
    const pb75 = (d75 != null) ? current + sign * atr14 * d75 : null;

    if ($("ee-pb25")) $("ee-pb25").textContent = fmt2(pb25);
    if ($("ee-pb50")) $("ee-pb50").textContent = fmt2(pb50);
    if ($("ee-pb75")) $("ee-pb75").textContent = fmt2(pb75);

    // escolhe profundidade recomendada baseado no StopRisk
    let depthRec = d25 ?? d50 ?? d75;
    if (stopRisk != null){
      if (stopRisk >= 65) depthRec = d75 ?? d50 ?? d25;
      else if (stopRisk >= 45) depthRec = d50 ?? d25 ?? d75;
      else depthRec = d25 ?? d50 ?? d75;
    }
    const pbRec = (depthRec != null) ? (current + sign * atr14 * depthRec) : null;

    // regime simples
    const isReversalHeavy =
      (reversaoPct != null && reversaoPct >= 60) ||
      (respiroPct != null && reversaoPct != null && (reversaoPct - respiroPct) >= 20);

    const isPullbackHeavy =
      (respiroPct != null && respiroPct >= 40) &&
      (reversaoPct == null || respiroPct >= (reversaoPct + 5));

    // decide plano
    let plan = "—";
    let entry = optEntry ?? pbRec;
    let status = "WAIT";

    // confiança (heurística)
    let conf = (targetPct != null) ? targetPct : 60;
    if (stopRisk != null) conf -= Math.max(0, stopRisk - 40) * 0.5;
    if (reversaoPct != null) conf -= Math.max(0, reversaoPct - 55) * 0.4;
    conf = Math.max(1, Math.min(99, conf));

    const zone = 0.10 * atr14;   // “perto o suficiente”
    const zConf = 0.06 * atr14;  // banda pra confirmação

    if (isReversalHeavy || (stopRisk != null && stopRisk >= 55)){
      plan = `RETEST (confirmar) · ${dir}`;
      status = "WAIT";
      entry = optEntry ?? pbRec ?? current;
    } else if (isPullbackHeavy){
      plan = `PULLBACK (melhor preço) · ${dir}`;
      entry = optEntry ?? pbRec ?? current;
      if (Math.abs(current - entry) <= zone && (stopRisk == null || stopRisk <= 50)) status = "GO";
    } else {
      plan = `CONTINUAÇÃO (break) · ${dir}`;
      entry = current + ((dir === "BUY") ? +0.12 * atr14 : -0.12 * atr14);
      if ((targetPct != null && targetPct >= 70) && (stopRisk == null || stopRisk <= 45)) status = "GO";
    }

    // trava: entrada nunca “passa” do TP
    if (entry != null && tp != null){
      if (dir === "BUY" && entry > tp) entry = tp - 0.05 * atr14;
      if (dir === "SELL" && entry < tp) entry = tp + 0.05 * atr14;
    }
// ===== ENTRY ENGINE (AARON) — usa a MESMA fórmula (entry ± zConf) =====
if ($("ee-engine-card")) {
  const touchPx = entry;
  const confirmPx = (dir === "BUY") ? (entry + zConf) : (entry - zConf);
  const cancelPx  = (dir === "BUY") ? (entry - zConf) : (entry + zConf);

  // micro prob (Premonition Micro Live) — vem do targetPct (já calculado acima)
  const microP = (targetPct != null && Number.isFinite(targetPct)) ? targetPct : null;
  const armP = (microP != null) ? microP : conf;

  // status do gate (price-based + arm)
  let st = "LOADING";
  if (dir === "BUY") {
    if (current <= cancelPx) st = "FAILED";
    else if (current >= confirmPx) st = "CONFIRMED";
    else if (armP >= 55) st = "ARMED";
  } else {
    if (current >= cancelPx) st = "FAILED";
    else if (current <= confirmPx) st = "CONFIRMED";
    else if (armP >= 55) st = "ARMED";
  }

  // pill
  const pill = $("ee-engine-pill");
  if (pill){
    pill.classList.remove("loading","armed","confirmed","failed");
    if (st === "ARMED"){ pill.classList.add("armed"); pill.textContent = "ARMED"; }
    else if (st === "CONFIRMED"){ pill.classList.add("confirmed"); pill.textContent = "CONFIRMED"; }
    else if (st === "FAILED"){ pill.classList.add("failed"); pill.textContent = "FAILED"; }
    else { pill.classList.add("loading"); pill.textContent = "LOADING"; }
  }

  if ($("ee-engine-dir")) $("ee-engine-dir").textContent = dir;

  // mostra micro prob (se não tiver, cai pro conf)
  if ($("ee-engine-prob")) $("ee-engine-prob").textContent = fmtPct(microP ?? conf);

  // ===== MODE + RULE =====
  const p = (microP ?? conf);

  let modeText = "NOISE ZONE ⚠️";
  let ruleText = "ENTER ONLY ON CONFIRM CLOSE";
  let modeClass = "noise";

  if (p != null && p >= 70) {
    modeText = "AARON STRONG ✅";
    ruleText = "TOUCH OK · HOLD UNTIL CANCEL";
    modeClass = "strong";
  } else if (p != null && p <= 49) {
    modeText = "NO TRADE ⛔";
    ruleText = "WAIT";
    modeClass = "notrade";
  }

  const modeEl = $("ee-engine-mode");
  if (modeEl){
    modeEl.classList.remove("strong","noise","notrade");
    modeEl.classList.add(modeClass);
    modeEl.textContent = `MODE: ${modeText}`;
  }
  if ($("ee-engine-rule")) $("ee-engine-rule").textContent = ruleText;
  // ===== /MODE + RULE =====

  // numbers
  if ($("ee-engine-touch")) $("ee-engine-touch").textContent = fmt2(touchPx);
  if ($("ee-engine-confirm")) $("ee-engine-confirm").textContent = fmt2(confirmPx);
  if ($("ee-engine-cancel")) $("ee-engine-cancel").textContent = fmt2(cancelPx);

  const note = (dir === "BUY")
    ? `Touch ${fmt2(touchPx)} · Confirm close ≥ ${fmt2(confirmPx)} · Cancel close ≤ ${fmt2(cancelPx)}`
    : `Touch ${fmt2(touchPx)} · Confirm close ≤ ${fmt2(confirmPx)} · Cancel close ≥ ${fmt2(cancelPx)}`;

  if ($("ee-engine-note")) $("ee-engine-note").textContent = note;
}
    // preencher UI
    if ($("ee-plan")) $("ee-plan").textContent = plan;
    if ($("ee-entry")) $("ee-entry").textContent = fmt2(entry);
    if ($("ee-conf")) $("ee-conf").textContent = fmtPct(conf);

    // regras (gatilho/cancel)
    let trigger = "—";
    let cancel = "—";

    if (plan.startsWith("PULLBACK")){
      trigger = (dir === "BUY")
        ? `Esperar tocar ${fmt2(entry)} ± ${fmt2(zConf)} e fechar acima (reclaim).`
        : `Esperar tocar ${fmt2(entry)} ± ${fmt2(zConf)} e fechar abaixo (reclaim).`;

      cancel = (sl != null)
        ? `Cancelar se bater SL ${fmt2(sl)} antes do reclaim.`
        : `Cancelar se falhar o reclaim (sem confirmação).`;
    }
    else if (plan.startsWith("RETEST")){
      const reclaim = (dir === "BUY") ? (entry + zConf) : (entry - zConf);

      trigger = (dir === "BUY")
        ? `Touch ${fmt2(entry)} → entrar só após fechar acima de ${fmt2(reclaim)}.`
        : `Touch ${fmt2(entry)} → entrar só após fechar abaixo de ${fmt2(reclaim)}.`;

      cancel = (dir === "BUY")
        ? `Cancelar se fechar abaixo de ${fmt2(entry - zConf)} (falha retest).`
        : `Cancelar se fechar acima de ${fmt2(entry + zConf)} (falha retest).`;
    }
    else if (plan.startsWith("CONTINUAÇÃO")){
      trigger = (dir === "BUY")
        ? `Entrar no rompimento acima de ${fmt2(entry)} com micro ainda ≥70%.`
        : `Entrar no rompimento abaixo de ${fmt2(entry)} com micro ainda ≥70%.`;

      cancel = (dir === "BUY")
        ? `Cancelar se retornar abaixo de ${fmt2(entry - zConf)}.`
        : `Cancelar se retornar acima de ${fmt2(entry + zConf)}.`;
    }

        if ($("ee-trigger")) $("ee-trigger").innerHTML = wrapPricesHTML(trigger, current);
    if ($("ee-cancel")) $("ee-cancel").innerHTML = wrapPricesHTML(cancel, current);

    if ($("ee-foot")){
      $("ee-foot").innerHTML = eeFootHTML(stopRisk, respiroPct, reversaoPct);
    }

    setBadge(status);
  }

  setInterval(updateEEBrain, 750);
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", updateEEBrain);
  else updateEEBrain();
})();
</script>



</body>
</html>